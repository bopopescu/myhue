{"version":3,"sources":["webpack:///./desktop/core/src/desktop/js/api/apiHelper.js","webpack:///./desktop/core/src/desktop/js/api/apiQueueManager.js","webpack:///./desktop/core/src/desktop/js/api/cancellablePromise.js","webpack:///./desktop/core/src/desktop/js/catalog/catalogUtils.js","webpack:///./desktop/core/src/desktop/js/catalog/dataCatalog.js","webpack:///./desktop/core/src/desktop/js/catalog/dataCatalogEntry.js","webpack:///./desktop/core/src/desktop/js/catalog/generalDataCatalog.js","webpack:///./desktop/core/src/desktop/js/catalog/multiTableEntry.js","webpack:///./desktop/core/src/desktop/js/sql/sqlUtils.js","webpack:///./desktop/core/src/desktop/js/sql/sqlWorkerHandler.js","webpack:///./desktop/core/src/desktop/js/utils/hueDebug.js","webpack:///./desktop/core/src/desktop/js/utils/huePubSub.js","webpack:///./desktop/core/src/desktop/js/utils/hueUtils.js","webpack:///./desktop/core/src/desktop/js/utils/i18n.js"],"names":["DOCUMENTS_API","HDFS_API_PREFIX","encodeURIComponent","ADLS_API_PREFIX","S3_API_PREFIX","NAV_URLS","NAV_OPT_URLS","fetchCached","options","cacheIdentifier","this","getAssistCacheIdentifier","cachedData","$","totalStorage","cachedId","hash","url","refreshCache","hasExpired","timestamp","cacheType","editor","showSpinner","fetchFunction","data","Date","getTime","e","promise","resolve","successCallback","genericNavOptMultiTableFetch","apiHelper","deferred","Deferred","dbTables","paths","forEach","path","join","ko","mapping","toJSON","Object","keys","request","simplePost","silenceErrors","hueTimestamp","now","errorCallback","reject","CancellablePromise","QueryResult","sourceType","compute","response","_classCallCheck","id","hueUtils","UUID","type","result","status","ApiHelper","self","queueManager","apiQueueManager","huePubSub","subscribe","clearAllCaches","clearDbCache","clearAll","window","performance","navigation","location","href","indexOf","hueDebug","cacheTimeout","CACHEABLE_TTL","LOGGED_USERNAME","hostname","getTotalStorageUserPrefix","owner","value","secure","protocol","defaultValue","observable","noInit","cachedValue","getFromTotalStorage","newValue","publish","setInTotalStorage","traceback","code","errorResponse","errorMessage","statusText","responseText","errorJs","JSON","parse","message","err","error","prototype","toString","call","logError","document","trigger","getReadyState","readyState","abort","post","dataType","done","successResponseIsError","assistErrorCallback","fail","get","ajax","method","contentType","userids","simpleGet","undefined","clonedPath","concat","length","shift","replace","offset","success","pathParts","encodeURI","pageSize","page","filter","bind","extend","storeInCache","timeout","files","always","hideSpinner","GIT_API_PREFIX","fileType","content","collection","name","collectionName","engine","analysis","fieldName","terms","prefix","alwaysCallback","stats","facet","query","qs","q","fqs","notSupportedCallback","suffix","parent","queryMetric","metricName","start","Math","floor","pastMs","end","step","stepMs","combinedDeferred","when","clusterName","timestampIndex","j","arguments","values","i","parseFloat","key","push","sort","a","b","configuration","app","properties","is_default","isDefault","group_id","groupId","user_id","userId","uuid","getQueued","firstInQueue","addToQueue","traditional","text","limit","include_trashed","fetchContents","parent_uuid","parentUuid","xhr","myXhr","ajaxSettings","upload","progressHandler","addEventListener","formData","cache","processData","source_doc_uuid","sourceId","destination_doc_uuid","destinationId","skip_trash","skipTrash","uuids","databaseName","tableName","fields","invalidate","flush_all","cluster","stringify","database","table","isQuery","slice","notebook","snippet","source","notFound","source_type","comment","new_table_name","column","new_column_name","new_column_type","partitions","partition_spec","format","partition_keys_json","partition_values_json","fetchAnalysis","promises","pop","watch_url","pollForAnalysis","delay","setTimeout","isSuccess","isFailure","cancellablePromises","waitTimeout","clearTimeout","waitForAvailable","notebookJson","snippetJson","query_status","_this","executable","adaptExecutableToNotebook","handle","cancel","cancelDeferred","cancelStatement","Promise","rows","startOver","_this2","bigdataParse","_this3","async","operation","sampleResponse","queryResult","meta","full_headers","whenAvailable","resultRequest","sampleCount","isView","entity","identity","modifiedCustomMetadata","deletedCustomMetadataKeys","tags","entityId","details","tries","query_id","queryId","onCancel","fix","start_time","query_s","sources","field_facets","facets","raw_query","rawQuery","statements","statement","getStatement","snippetId","statement_raw","variables","settings","snippets","notebookId","isSaved","sessions","ApiQueueManager","callQueue","otherCancellables","cancelCallbacks","cancelled","cancelPrevented","state","cancelActiveRequest","cancelPromises","cancellable","callback","then","apply","pipe","progress","__webpack_require__","r","__webpack_exports__","_api_apiHelper__WEBPACK_IMPORTED_MODULE_0__","applyCancellable","preventCancel","fetchAndSave","apiHelperFunction","attributeName","entry","apiOptions","dataCatalog","saveLater","setSilencedErrors","STORAGE_POSTFIX","cacheEnabled","generateEntryCacheId","namespace","pathSet","uniquePaths","DataCatalog","entries","temporaryEntries","multiTableEntries","store","localforage","createInstance","multiTableStore","HAS_OPTIMIZER","rootPath","clear","catch","keyPrefix","deletePromises","keysDeferred","deleteDeferred","removeItem","dataCatalogEntry","default","identifier","setItem","version","definition","sourceMeta","sample","navigatorMeta","navOptMeta","navOptPopularity","popularEntries","pathsToLoad","catalogUtils","existingPromises","existingDeferred","getEntry","tableEntry","navOptPopularityForChildrenPromise","existingPopularEntries","navOptLoaded","getChildren","childEntries","childEntry","loadDeferred","fetchNavOptPopularity","perTable","splitNavOptValuesPerTable","listName","tableMeta","dbName","tablePromises","tableDeferred","trackedPromise","applyNavOptResponseToChildren","identifiersToClean","addEntryMeta","sourceMetaPromise","navigatorMetaPromise","is_view","analysisPromise","removeTable","sourceIdentifier","sourceDeferred","sourceEntry","DataCatalogEntry","isTemporary","index","childrenPromise","existingTemporaryDatabases","databaseIdentifier","databaseDeferred","databaseEntry","existingTemporaryTables","tableIdentifier","indexToDelete","splice","childrenDeferred","columns","extended_columns","samplePromise","columnPath","columnIdentifier","columnDeferred","columnEntry","partitionKey","sampleRow","notFount","delete","temporaryOnly","getItem","storeEntry","mergeAttribute","ttl","promiseName","optimizer","mergeEntry","cachedOnly","console","warn","MultiTableEntry","multiTableCatalogEntry","mergeMultiTableEntry","multiTableEntry","topAggs","topColumns","topFilters","topJoins","generalDataCatalog","GeneralDataCatalog","sourceBoundCatalogs","getCatalog","Error","addTemporaryTable","getMultiTableEntry","getAllNavigatorTags","updateAllNavigatorTags","enableCache","disableCache","reloadSourceMeta","invalidatePromise","reloadNavigatorMeta","canHaveNavigatorMetadata","commentObservable","getResolvedComment","reloadAnalysis","refreshAnalysis","reloadPartitions","reloadSample","reloadNavOptMeta","canHaveNavOptMetadata","navOptMetaPromise","getFromMultiTableCatalog","catalogEntry","functionName","isTableOrView","split","reset","saveTimeout","partitionsPromise","navigatorMetaForChildrenPromise","getKnownEntry","cancellablePromise","getSourceType","IS_K8S_ONLY","invalidateSourceMetadata","saveDeferred","cascade","clearStorageCascade","save","clearPromise","persistCatalogEntry","getSourceMeta","partitionKeys","partition_keys","entities","databases","tables_meta","_typeof","isComplex","isMapValue","Array","isField","children","some","rejectUnknown","searchEntities","childEntryIndex","toLowerCase","matchingChildEntry","original_name","originalName","childPromise","entriesByName","updatedIndex","isDatabase","top_tables","topTable","matchingChild","getQualifiedPath","addNavOptPopularity","columnName","filterColumns","groupbyColumns","joinColumns","orderbyColumns","selectColumns","HAS_CATALOG","isColumn","description","originalDescription","resolveWithSourceMeta","getNavigatorMeta","updateNavigatorProperties","getComment","updateSourceMetadata","navMeta","addNavTags","deleteNavTags","test","includeComment","title","getType","hasResolvedComment","qualified","displayName","primary_key","table_type","getRawType","substring","fetchSample","revertToSpecific","parentSample","colSample","has_more","_loop","parentRow","allNavigatorTagsPromise","reloadAllTags","fetchAllNavigatorTags","allTags","tagsToAdd","tagsToRemove","newTag","removedTag","genericNavOptReload","promiseAttribute","dataAttribute","genericNavOptGet","topAggsPromise","topColumnsPromise","topFiltersPromise","topJoinsPromise","persistMultiTableEntry","jquery__WEBPACK_IMPORTED_MODULE_0__","jquery__WEBPACK_IMPORTED_MODULE_0___default","n","_api_cancellablePromise__WEBPACK_IMPORTED_MODULE_1__","_catalog_dataCatalog__WEBPACK_IMPORTED_MODULE_2__","hiveReservedKeywords","ALL","ALTER","AND","ARRAY","AS","AUTHORIZATION","BETWEEN","BIGINT","BINARY","BOOLEAN","BOTH","BY","CACHE","CASE","CAST","CHAR","COLUMN","COMMIT","CONF","CONSTRAINT","CREATE","CROSS","CUBE","CURRENT","CURRENT_DATE","CURRENT_TIMESTAMP","CURSOR","DATABASE","DATE","DAYOFWEEK","DECIMAL","DELETE","DESCRIBE","DISTINCT","DIV","DOUBLE","DROP","ELSE","END","EXCHANGE","EXISTS","EXTENDED","EXTERNAL","EXTRACT","FALSE","FETCH","FLOAT","FLOOR","FOLLOWING","FOR","FOREIGN","FROM","FULL","FUNCTION","GRANT","GROUP","GROUPING","HAVING","IF","IMPORT","IN","INNER","INSERT","INT","INTEGER","INTERSECT","INTERVAL","INTO","IS","JOIN","LATERAL","LEFT","LESS","LIKE","LOCAL","MACRO","MAP","MORE","NONE","NOT","NULL","NUMERIC","OF","ON","ONLY","OR","ORDER","OUT","OUTER","OVER","PARTIALSCAN","PARTITION","PERCENT","PRECEDING","PRECISION","PRESERVE","PRIMARY","PROCEDURE","RANGE","READS","REDUCE","REFERENCES","REGEXP","REVOKE","RIGHT","RLIKE","ROLLBACK","ROLLUP","ROW","ROWS","SELECT","SET","SMALLINT","START","SYNC","TABLE","TABLESAMPLE","THEN","TIME","TIMESTAMP","TO","TRANSFORM","TRIGGER","TRUE","TRUNCATE","UNBOUNDED","UNION","UNIQUEJOIN","UPDATE","USER","USING","UTC_TIMESTAMP","VALUES","VARCHAR","VIEWS","WHEN","WHERE","WINDOW","WITH","extraHiveReservedKeywords","ASC","CLUSTER","DESC","DISTRIBUTE","FORMATTED","INDEX","INDEXES","LIMIT","LOCK","SCHEMA","SORT","impalaReservedKeywords","ADD","AGGREGATE","ALLOCATE","ANALYTIC","ANTI","ANY","API_VERSION","ARE","ARRAY_AGG","ARRAY_MAX_CARDINALITY","ASENSITIVE","ASYMMETRIC","AT","ATOMIC","AVRO","BEGIN_FRAME","BEGIN_PARTITION","BLOB","BLOCK_SIZE","CACHED","CALLED","CARDINALITY","CASCADE","CASCADED","CHANGE","CHARACTER","CLASS","CLOB","CLOSE_FN","COLLATE","COLLECT","COLUMNS","COMMENT","COMPRESSION","COMPUTE","CONDITION","CONNECT","CONTAINS","CONVERT","COPY","CORR","CORRESPONDING","COVAR_POP","COVAR_SAMP","CURRENT_DEFAULT_TRANSFORM_GROUP","CURRENT_PATH","CURRENT_ROLE","CURRENT_ROW","CURRENT_SCHEMA","CURRENT_TIME","CURRENT_TRANSFORM_GROUP_FOR_TYPE","CYCLE","DATA","DATABASES","DATETIME","DEALLOCATE","DEC","DECFLOAT","DECLARE","DEFINE","DELIMITED","DEREF","DETERMINISTIC","DISCONNECT","DYNAMIC","EACH","ELEMENT","EMPTY","ENCODING","END_FRAME","END_PARTITION","EQUALS","ESCAPE","ESCAPED","EVERY","EXCEPT","EXEC","EXECUTE","EXPLAIN","FIELDS","FILEFORMAT","FILES","FILTER","FINALIZE_FN","FIRST","FORMAT","FRAME_ROW","FREE","FUNCTIONS","FUSION","GET","GLOBAL","GROUPS","HASH","HOLD","IGNORE","ILIKE","INCREMENTAL","INDICATOR","INIT_FN","INITIAL","INOUT","INPATH","INSENSITIVE","INTERMEDIATE","INTERSECTION","INVALIDATE","IREGEXP","JSON_ARRAY","JSON_ARRAYAGG","JSON_EXISTS","JSON_OBJECT","JSON_OBJECTAGG","JSON_QUERY","JSON_TABLE","JSON_TABLE_PRIMITIVE","JSON_VALUE","KEY","KUDU","LARGE","LAST","LEADING","LIKE_REGEX","LINES","LISTAGG","LOAD","LOCALTIMESTAMP","LOCATION","MATCH","MATCH_NUMBER","MATCH_RECOGNIZE","MATCHES","MERGE","MERGE_FN","METADATA","METHOD","MODIFIES","MULTISET","NATIONAL","NATURAL","NCHAR","NCLOB","NO","NORMALIZE","NTH_VALUE","NULLS","OCCURRENCES_REGEX","OCTET_LENGTH","OFFSET","OMIT","ONE","OVERLAPS","OVERLAY","OVERWRITE","PARQUET","PARQUETFILE","PARTITIONED","PARTITIONS","PATTERN","PER","PERCENTILE_CONT","PERCENTILE_DISC","PORTION","POSITION","POSITION_REGEX","PRECEDES","PREPARE","PREPARE_FN","PRODUCED","PTF","PURGE","RCFILE","REAL","RECOVER","RECURSIVE","REF","REFERENCING","REFRESH","REGR_AVGX","REGR_AVGY","REGR_COUNT","REGR_INTERCEPT","REGR_R2","REGR_SLOPE","REGR_SXX","REGR_SXY","REGR_SYY","RELEASE","RENAME","REPEATABLE","REPLACE","REPLICATION","RESTRICT","RETURNS","ROLE","ROLES","RUNNING","SAVEPOINT","SCHEMAS","SCOPE","SCROLL","SEARCH","SEEK","SEMI","SENSITIVE","SEQUENCEFILE","SERDEPROPERTIES","SERIALIZE_FN","SHOW","SIMILAR","SKIP","SOME","SPECIFIC","SPECIFICTYPE","SQLEXCEPTION","SQLSTATE","SQLWARNING","STATIC","STATS","STORED","STRAIGHT_JOIN","STRING","STRUCT","SUBMULTISET","SUBSET","SUBSTRING_REGEX","SUCCEEDS","SYMBOL","SYMMETRIC","SYSTEM_TIME","SYSTEM_USER","TABLES","TBLPROPERTIES","TERMINATED","TEXTFILE","TIMEZONE_HOUR","TIMEZONE_MINUTE","TINYINT","TRAILING","TRANSLATE_REGEX","TRANSLATION","TREAT","TRIM_ARRAY","UESCAPE","UNCACHED","UNIQUE","UNKNOWN","UNNEST","UPDATE_FN","UPSERT","USE","VALUE_OF","VARBINARY","VARYING","VERSIONING","VIEW","WHENEVER","WIDTH_BUCKET","WITHIN","WITHOUT","identifierEquals","identifierChainToPath","identifierChain","map","autocompleteFilter","lowerCaseFilter","suggestion","foundIndex","filterValue","filterWeight","matchComment","matchIndex","matchLength","backTickIfNeeded","upperIdentifier","toUpperCase","locationEquals","first_line","first_column","last_line","last_column","sortSuggestions","suggestions","sortOverride","partitionColumnsFirst","aWeight","category","weight","weightAdjust","bWeight","localeCompare","resolveCatalogEntry","findInTree","currentEntry","fieldsToGo","nextField","foundEntry","tables","findTable","tablesToGo","nextTable","subQuery","_catalog_dataCatalog__WEBPACK_IMPORTED_MODULE_1__","_utils_huePubSub__WEBPACK_IMPORTED_MODULE_2__","_sqlUtils__WEBPACK_IMPORTED_MODULE_3__","registered","registerWorkers","IS_EMBEDDED","Worker","whenWorkerIsReady","worker","isReady","postMessage","pingTimeout","ping","aceSqlSyntaxWorker","HUE_BASE_URL","HUE_VERSION","onmessage","aceSqlLocationWorker","locations","resolvePathPromise","colRef","sqlUtils","attachEntryResolver","localforage__WEBPACK_IMPORTED_MODULE_0__","localforage__WEBPACK_IMPORTED_MODULE_0___default","clearCaches","clearInstance","all","log","topics","hOP","hasOwnProperty","topic","listener","remove","removeAll","subscribeOnce","ephemeral","info","item","getTopics","pauseAppSubscribers","topicName","resumeAppSubscribers","clearAppSubscribers","obj","bootstrapRatios","span3","windowWidth","width","span9","margin","changeURL","newURL","params","extraSearch","newSearchKeys","newKey","search","pathname","history","pushState","hashSplit","changeURLParameter","param","parts","RegExp","newSearch","getParameter","p","getSearchParameter","returnNull","results","exec","decodeURIComponent","dfs","node","s4","random","getFileBrowseButton","inputElement","selectFolder","valueAccessor","stripHdfsPrefix","allBindingsAccessor","isAddon","isNestedModal","linkMarkup","_btn","addClass","click","handleChoice","filePath","filechooserPrefixSeparator","val","filechooserOptions","deploymentDir","attr","substr","change","displayJustLastBit","_val","preventDefault","HUE_CONTAINER","_initialPath","trim","skipInitialPathIfEmpty","supportSelectFolder","jHueFileChooser","suppressErrors","onFolderChoose","modal","onFileChoose","createFolder","uploadFile","initialPath","errorRedirectPath","forceRefresh","showExtraHome","extraHomeProperties","filterExtensions","filechooserFilter","displayOnlyFolders","isIE11","oldFocus","Constructor","enforceFocus","on","removeClass","callFileChooser","filechooserDisabled","text2Url","selectors","len","arr","selector","innerHTML","word","matched","re","match","htmlEncode","html","html2text","goFullScreen","fullscreenElement","mozFullScreenElement","webkitFullscreenElement","msFullscreenElement","documentElement","requestFullscreen","msRequestFullscreen","mozRequestFullScreen","webkitRequestFullscreen","Element","ALLOW_KEYBOARD_INPUT","exitFullScreen","exitFullscreen","msExitFullscreen","mozCancelFullScreen","webkitExitFullscreen","replaceURL","replaceState","removeURLParameter","parseHivePseudoJson","pseudoJson","parsedParams","part","isOverflowing","element","scrollHeight","clientHeight","scrollWidth","clientWidth","waitForRendered","condition","$el","waitForRenderTimeout","waitForObservable","subscription","dispose","waitForVariable","variable","scrollbarWidth","$parent","appendTo","$children","innerWidth","height","stack","equalIgnoreCase","deXSS","str","getStyleFromCSSClass","cssClass","styleSheets","cssClasses","rules","cssRules","x","selectorText","style","highlight","searchTerm","startIndex","remText","highLightedText","deleteAllEmptyStringKey","escapeOutput","stripHtmlFromFunctions","template","_tmpl","_mustacheFunctions","each","cnt","fn","tmp","createElement","textContent","innerText","I18n","HUE_I18n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;4rCAyBA,IAGMA,EAAgB,qBAGhBC,EAAkB,qBAAuBC,mBAAmB,KAC5DC,EAAkB,qBAAuBD,mBAAmB,SAE5DE,EAAgB,qBAAuBF,mBAAmB,UAiB1DG,EACM,iCADNA,EAES,oCAFTA,EAGS,oCAHTA,EAIO,kCAJPA,EAKe,0CAGfC,EACM,mCADNA,EAES,sCAFTA,EAGS,sCAHTA,EAIO,oCAJPA,EAKQ,qCALRA,EAMW,wCAgBXC,EAAc,SAASC,GAC3B,IACMC,EADOC,KACgBC,yBAAyBH,GAChDI,EAAaC,IAAEC,aAAaL,IAAoB,GAChDM,EAAWP,EAAQQ,KAAOR,EAAQS,IAAMT,EAAQQ,KAAOR,EAAQS,IAErE,GACET,EAAQU,mBACuB,IAAxBN,EAAWG,IAPPL,KAQNS,WAAWP,EAAWG,GAAUK,UAAWZ,EAAQa,WAAa,WAKrE,YAH8B,IAAnBb,EAAQc,QAA6C,OAAnBd,EAAQc,QACnDd,EAAQc,OAAOC,cAEVf,EAAQgB,cAAc,SAAAC,GAC3Bb,EAAWG,GAAY,CACrBK,WAAW,IAAIM,MAAOC,UACtBF,KAAMA,GAER,IACEZ,IAAEC,aAAaL,EAAiBG,GAChC,MAAOgB,OAGPpB,EAAQqB,SACVrB,EAAQqB,QAAQC,QAAQlB,EAAWG,GAAUU,MAG/CjB,EAAQuB,gBAAgBnB,EAAWG,GAAUU,OAc3CO,EAA+B,SAASC,EAAWzB,EAASS,GAChE,IAAMiB,EAAWrB,IAAEsB,WAEbC,EAAW,GACjB5B,EAAQ6B,MAAMC,QAAQ,SAAAC,GACpBH,EAASG,EAAKC,KAAK,OAAQ,IAE7B,IAAMf,EAAO,CACXW,SAAUK,IAAGC,QAAQC,OAAOC,OAAOC,KAAKT,KAGpCU,EAAUb,EAAUc,WAAW9B,EAAKQ,EAAM,CAC9CuB,cAAexC,EAAQwC,cACvBjB,gBAAiB,SAASN,GACxBA,EAAKwB,aAAevB,KAAKwB,MACzBhB,EAASJ,QAAQL,IAEnB0B,cAAejB,EAASkB,SAG1B,OAAO,IAAIC,UAAmBnB,EAAUY,IAWpCQ,EACJ,SAAAA,EAAYC,EAAYC,EAASC,GAAUC,EAAAhD,KAAA4C,GAC5B5C,KACRiD,GAAKC,UAASC,OADNnD,KAERoD,KAAOL,EAASM,QAAUN,EAASM,OAAOD,KAAOL,EAASM,OAAOD,KAAOP,EAFhE7C,KAGR8C,QAAUA,EAHF9C,KAIRsD,OAASP,EAASO,QAAU,UAJpBtD,KAKRqD,OAASN,EAASM,QAAU,GALpBrD,KAMRqD,OAAOD,KAAO,SAw6EjB7B,EAAY,eAn6EhB,SAAAgC,IAAcP,EAAAhD,KAAAuD,GACZ,IAAMC,EAAOxD,KACbwD,EAAKC,aAAeC,UAEpBC,UAAUC,UAAU,0BAA2B,WAC7CzD,IAAEC,aAAaoD,EAAKvD,yBAAyB,CAAE4C,WAAY,SAAW,MAGxEc,UAAUC,UAAU,0BAA2B,WAC7CzD,IAAEC,aAAaoD,EAAKvD,yBAAyB,CAAE4C,WAAY,SAAW,MAGxEc,UAAUC,UAAU,yBAA0B,WAC5CzD,IAAEC,aAAaoD,EAAKvD,yBAAyB,CAAE4C,WAAY,QAAU,MAGvEc,UAAUC,UAAU,wBAAyB,WAC3CzD,IAAEC,aAAaoD,EAAKvD,yBAAyB,CAAE4C,WAAY,OAAS,MAGtEc,UAAUC,UAAU,iCAAkC,WACpDzD,IAAEC,aAAaoD,EAAKvD,yBAAyB,CAAE4C,WAAY,gBAAkB,MAG/Ec,UAAUC,UAAU,2BAA4B,WAC9CzD,IAAEC,aAAaoD,EAAKvD,yBAAyB,CAAE4C,WAAY,UAAY,MAGzEc,UAAUC,UAAU,8BAA+B,WACjDzD,IAAEC,aAAaoD,EAAKvD,yBAAyB,CAAE4C,WAAY,aAAe,MAG5E,IAAMgB,EAAiB,WACrBL,EAAKM,aAAa,CAChBjB,WAAY,OACZkB,UAAU,IAEZP,EAAKM,aAAa,CAChBjB,WAAY,SACZkB,UAAU,IAEZ5D,IAAEC,aAAaoD,EAAKvD,yBAAyB,CAAE4C,WAAY,SAAW,IACtE1C,IAAEC,aAAaoD,EAAKvD,yBAAyB,CAAE4C,WAAY,SAAW,IACtE1C,IAAEC,aAAaoD,EAAKvD,yBAAyB,CAAE4C,WAAY,QAAU,IACrE1C,IAAEC,aAAaoD,EAAKvD,yBAAyB,CAAE4C,WAAY,OAAS,IACpE1C,IAAEC,aAAaoD,EAAKvD,yBAAyB,CAAE4C,WAAY,gBAAkB,IAC7E1C,IAAEC,aAAaoD,EAAKvD,yBAAyB,CAAE4C,WAAY,UAAY,IACvE1C,IAAEC,aAAaoD,EAAKvD,yBAAyB,CAAE4C,WAAY,aAAe,KAG5Ec,UAAUC,UAAU,0BAA2BC,GAE3CG,OAAOC,aAAeD,OAAOC,YAAYC,YACA,IAAvCF,OAAOC,YAAYC,WAAWd,OAAuD,IAAzCe,SAASC,KAAKC,QAAQ,eAEpER,6DAKKnD,EAAWC,GACpB,YAAwB,IAAb2D,gBAA6D,IAA1BA,UAASC,cAC9C,IAAIvD,MAAOC,UAAYP,EAAY4D,UAASC,cAE9C,IAAIvD,MAAOC,UAAYP,EAAY8D,cAAc7D,qDAOhCkC,GACxB,OAAOA,EAAa,IAAMmB,OAAOS,gBAAkB,IAAMT,OAAOG,SAASO,0DASlD5E,GAEvB,MACE,eACCA,EAAQa,WAAa,WACtB,IAJWX,KAKN2E,0BAA0B7E,EAAQ+C,sDAUzB+B,EAAO3B,EAAI4B,GAE3B,IACE,IAAM3E,EACJC,IAAEC,aAAa,qBAHNJ,KAGkC2E,0BAA0BC,KAAW,GAC9E,MAAOC,GACT3E,EAAW+C,GAAM4B,EACjB1E,IAAEC,aAAa,qBANNJ,KAMkC2E,0BAA0BC,GAAQ1E,EAAY,CACvF4E,OAAQd,OAAOG,SAASY,SAASV,QAAQ,UAAY,KAE9CnE,EAAW+C,YACb/C,EAAW+C,GAClB9C,IAAEC,aAAa,qBAXNJ,KAWkC2E,0BAA0BC,GAAQ1E,EAAY,CACvF4E,OAAQd,OAAOG,SAASY,SAASV,QAAQ,UAAY,KAGzD,MAAOnD,iDAUS0D,EAAO3B,EAAI+B,GAC7B,IACM9E,EACJC,IAAEC,aAAa,qBAFJJ,KAEgC2E,0BAA0BC,KAAW,GAClF,YAAiC,IAAnB1E,EAAW+C,GAAsB/C,EAAW+C,GAAM+B,2CASjDJ,EAAO3B,EAAIgC,EAAYD,EAAcE,GACpD,IAAM1B,EAAOxD,KAEPmF,EAAc3B,EAAK4B,oBAAoBR,EAAO3B,EAAI+B,GAYxD,OAVKE,GAA0B,cAAhBC,GACbF,EAAWE,GAGbF,EAAWrB,UAAU,SAAAyB,GACL,WAAVT,GAA6B,yBAAP3B,GACxBU,UAAU2B,QAAQ,sBAEpB9B,EAAK+B,kBAAkBX,EAAO3B,EAAIoC,KAE7BJ,iDAQclC,GACrB,YACsB,IAAbA,SACwB,IAAvBA,EAASyC,gBACa,IAApBzC,EAASO,QAA8C,IAApBP,EAASO,QAClC,MAAlBP,EAAS0C,MACS,MAAlB1C,EAAS0C,kDAUK3F,GAClB,OAAO,SAAS4F,GACd,IAAIC,EAAe,yBACnB,GAAI,MAAOD,EAAyD,CAClE,QACsC,IAA7BA,EAAcE,YACQ,UAA7BF,EAAcE,WAEd,OACK,QAA0C,IAA/BF,EAAcG,aAC9B,IACE,IAAMC,EAAUC,KAAKC,MAAMN,EAAcG,cAEvCF,OAD6B,IAApBG,EAAQG,QACFH,EAAQG,QAERP,EAAcG,aAE/B,MAAOK,GACPP,EAAeD,EAAcG,uBAEW,IAA1BH,EAAcO,SAAqD,OAA1BP,EAAcO,QACvEN,EAAeD,EAAcO,aAEO,IAA7BP,EAAcE,YACQ,OAA7BF,EAAcE,WAEdD,EAAeD,EAAcE,WAEL,cAAxBF,EAAcS,OAC0C,oBAAxDjE,OAAOkE,UAAUC,SAASC,KAAKZ,EAAcS,OAE7CR,EAAeD,EAAcS,MAC8B,oBAAlDjE,OAAOkE,UAAUC,SAASC,KAAKZ,KACxCC,EAAeD,GAcnB,OAVK5F,GAAYA,EAAQwC,gBACvBY,UAASqD,SAASb,GACdC,IAAoE,IAApDA,EAAatB,QAAQ,2BACvClE,IAAEqG,UAAUC,QAAQ,QAASd,IAI7B7F,GAAWA,EAAQ2C,eACrB3C,EAAQ2C,cAAckD,GAEjBA,+CAISvD,GACd,MAAOA,KACUA,EAAQsE,cAAgBtE,EAAQsE,gBAAkBtE,EAAQuE,YAC5D,GACfvE,EAAQwE,4CAgBHrG,EAAKQ,EAAMjB,GACpB,IAAM0D,EAAOxD,KACPwB,EAAWrB,IAAEsB,WAEbW,EAAUjC,IAAE0G,KAAK,CACrBtG,IAAKA,EACLQ,KAAMA,EACN+F,SAAUhH,GAAWA,EAAQgH,WAE5BC,KAAK,SAAAhG,GACAyC,EAAKwD,uBAAuBjG,GAC9BS,EAASkB,OAAOc,EAAKyD,oBAAoBnH,EAAzB0D,CAAkCzC,KAGhDjB,GAAWA,EAAQuB,iBACrBvB,EAAQuB,gBAAgBN,GAE1BS,EAASJ,QAAQL,MAElBmG,KAAK1D,EAAKyD,oBAAoBnH,IAEjCsC,EAAQ8E,KAAK,SAAAnG,GACXS,EAASkB,OAAOc,EAAKyD,oBAAoBnH,EAAzB0D,CAAkCzC,MAGpD,IAAMI,EAAUK,EAASL,UAUzB,OARAA,EAAQuF,cAAgB,WACtB,OAAOtE,EAAQuE,YAGjBxF,EAAQyF,MAAQ,WACdxE,EAAQwE,SAGHzF,4CAQSJ,EAAMjB,GAEtBK,IAAE0G,KAzZe,oBA2Zf9F,EACA,SAAAsC,QACyC,IAA5BvD,EAAQuB,iBACjBvB,EAAQuB,gBAAgBgC,IAG5B,QACA6D,KAVWlH,KAUDiH,oBAAoBnH,sCAWxBS,EAAKQ,EAAMjB,GACnB,IAAM0D,EAAOxD,KAIb,OAHKF,IACHA,EAAU,IAELK,IAAEgH,IAAI5G,EAAKQ,EAAM,SAAAA,GAClByC,EAAKwD,uBAAuBjG,GAC9ByC,EAAKyD,oBAAoBnH,EAAzB0D,CAAkCzC,QACU,IAA5BjB,EAAQuB,iBACxBvB,EAAQuB,gBAAgBN,KAEzBmG,KAAK1D,EAAKyD,oBAAoBnH,gDAGfA,GAClBK,IAAEiH,KAAK,CACLC,OAAQ,MACR9G,IAAK,kCACLQ,KAAMjB,EAAQiB,MAAQ,GACtBuG,YAAa,qBAEZP,KAAK,SAAAhE,GACJjD,EAAQuB,gBAAgB0B,KAEzBmE,KAAK,SAAAnE,GACJjD,EAAQ2C,cAAcM,6CAIZjD,GACdK,IAAEiH,KAAK,CACLC,OAAQ,MACR9G,IAAK,qBACLQ,KAAM,CAAEwG,QAASzH,EAAQyH,SACzBD,YAAa,qBAEZP,KAAK,SAAAhE,GACJjD,EAAQuB,gBAAgB0B,KAEzBmE,KAAK,SAAAnE,GACJjD,EAAQ2C,cAAcM,uCAUlBjD,GACR,IAAMS,EAteO,iBAseUT,EAAQqE,SAC/B,OAAOnE,KAAKwH,UAAUjH,OAAKkH,EAAW3H,+CAYpBA,GAClB,IACIS,EADEiD,EAAOxD,KAGXO,EADmB,OAAjBT,EAAQsD,KACJ1D,EACoB,SAAjBI,EAAQsD,KACX3D,EAEAF,EAGR,IAAMmI,EAAa5H,EAAQ+B,KAAK8F,SAC5BD,EAAWE,QAA4B,MAAlBF,EAAW,IAClCA,EAAWG,QAEbtH,GAAOmH,EAAW5F,KAAK,KAAKgG,QAAQ,KAAM,OAAS,8BACnDvH,GAAO,YAAcT,EAAQiI,QAAU,GACvCxH,GAAO,YAAcT,EAAQ8H,QAAU,QAEvC,IAAMpG,EAAWrB,IAAEsB,WAcnB,OAbAtB,IAAEiH,KAAK,CACLN,SAAU,OACVvG,IAAKA,EACLyH,QAAS,SAASjH,GACZyC,EAAKwD,uBAAuBjG,GAC9BS,EAASkB,OAAOc,EAAKyD,oBAAoBnH,EAAzB0D,CAAkCzC,IAElDS,EAASJ,QAAQL,IAGrBmG,KAAM1F,EAASkB,SAGVlB,EAASL,gDAgBJrB,GACZ,IAAM0D,EAAOxD,KAEXF,EAAQmI,UAAUL,OAAS,IACD,MAAzB9H,EAAQmI,UAAU,IAAuC,KAAzBnI,EAAQmI,UAAU,KAEnDnI,EAAQmI,UAAUJ,QAEpB,IAAItH,EACFhB,EACA2I,UAAUpI,EAAQmI,UAAUnG,KAAK,MACjC,uDACChC,EAAQqI,UAAY,KACrB,aACCrI,EAAQsI,MAAQ,GACftI,EAAQuI,SACV9H,GAAO,WAAaT,EAAQuI,QAmC9B,OAAOxI,EAAYyI,KAAK9E,EAAjB3D,CACLM,IAAEoI,OAAO,GAAIzI,EAAS,CACpB+C,WAAY,OACZtC,IAAKA,EACLO,cArCkB,SAAS0H,GAC7B,GAAwB,IAApB1I,EAAQ2I,QAIZ,OAAOtI,IAAEiH,KAAK,CACZN,SAAU,OACVvG,IAAKA,EACLkI,QAAS3I,EAAQ2I,QACjBT,QAAS,SAASjH,GAEbA,EAAKoF,OACL3C,EAAKwD,uBAAuBjG,SACP,IAAfA,EAAK2H,OACG,OAAf3H,EAAK2H,MAOLlF,EAAKyD,oBAAoBnH,EAAzB0D,CAAkCzC,IAL9BA,EAAK2H,MAAMd,OAAS,IAAM9H,EAAQuI,QACpCG,EAAazH,GAEfjB,EAAQuB,gBAAgBN,OAM3BmG,KAAK1D,EAAKyD,oBAAoBnH,IAC9B6I,OAAO,gBACwB,IAAnB7I,EAAQc,QAA6C,OAAnBd,EAAQc,QACnDd,EAAQc,OAAOgI,gBA1BnBpF,EAAKyD,oBAAoBnH,EAAzB0D,CAAkC,CAAEF,QAAS,8CAqDrCxD,GACZ,IAAM0D,EAAOxD,KACbF,EAAQmI,UAAUJ,QAClB,IAAItH,EACFd,EACAyI,UAAUpI,EAAQmI,UAAUnG,KAAK,MACjC,uDACChC,EAAQqI,UAAY,KACrB,aACCrI,EAAQsI,MAAQ,GACftI,EAAQuI,SACV9H,GAAO,WAAaT,EAAQuI,QAmC9B,OAAOxI,EAAYyI,KAAK9E,EAAjB3D,CACLM,IAAEoI,OAAO,GAAIzI,EAAS,CACpB+C,WAAY,OACZtC,IAAKA,EACLO,cArCkB,SAAS0H,GAC7B,GAAwB,IAApB1I,EAAQ2I,QAIZ,OAAOtI,IAAEiH,KAAK,CACZN,SAAU,OACVvG,IAAKA,EACLkI,QAAS3I,EAAQ2I,QACjBT,QAAS,SAASjH,GAEbA,EAAKoF,OACL3C,EAAKwD,uBAAuBjG,SACP,IAAfA,EAAK2H,OACG,OAAf3H,EAAK2H,MAOLlF,EAAKyD,oBAAoBnH,EAAzB0D,CAAkCzC,IAL9BA,EAAK2H,MAAMd,OAAS,IAAM9H,EAAQuI,QACpCG,EAAazH,GAEfjB,EAAQuB,gBAAgBN,OAM3BmG,KAAK1D,EAAKyD,oBAAoBnH,IAC9B6I,OAAO,gBACwB,IAAnB7I,EAAQc,QAA6C,OAAnBd,EAAQc,QACnDd,EAAQc,OAAOgI,gBA1BnBpF,EAAKyD,oBAAoBnH,EAAzB0D,CAAkC,CAAEF,QAAS,iDAkDlCxD,GACf,IAAM0D,EAAOxD,KACPO,EACJsI,mCAEAX,UAAUpI,EAAQmI,UAAUnG,KAAK,MACjC,aACAhC,EAAQgJ,SAmCVjJ,EAAYyI,KAAK9E,EAAjB3D,CACEM,IAAEoI,OAAO,GAAIzI,EAAS,CACpB+C,WAAY,MACZtC,IAAKA,EACLO,cAtCkB,SAAS0H,GACL,IAApB1I,EAAQ2I,QAIZtI,IAAEiH,KAAK,CACLN,SAAU,OACVvG,IAAKA,EACLkI,QAAS3I,EAAQ2I,QACjBT,QAAS,SAASjH,GACXA,EAAKoF,OAAU3C,EAAKwD,uBAAuBjG,GAkB9CyC,EAAKyD,oBAAoBnH,EAAzB0D,CAAkCzC,GAhBd,QAAlBA,EAAK+H,eACiB,IAAf/H,EAAK2H,OACG,OAAf3H,EAAK2H,OAED3H,EAAK2H,MAAMd,OAAS,GACtBY,EAAazH,GAEfjB,EAAQuB,gBAAgBN,IAEN,SAAlBA,EAAK+H,eACmB,IAAjB/H,EAAKgI,SACK,OAAjBhI,EAAKgI,SAELjJ,EAAQuB,gBAAgBN,MAM7BmG,KAAK1D,EAAKyD,oBAAoBnH,IA7B/B0D,EAAKyD,oBAAoBnH,EAAzB0D,CAAkC,CAAEF,QAAS,4CAsDvCxD,GACV,IAAM0D,EAAOxD,KACbF,EAAQmI,UAAUJ,QAClB,IAAItH,EACFb,EACAwI,UAAUpI,EAAQmI,UAAUnG,KAAK,MACjC,uDACChC,EAAQqI,UAAY,KACrB,aACCrI,EAAQsI,MAAQ,GACftI,EAAQuI,SACV9H,GAAO,WAAaT,EAAQuI,QAoC9BxI,EAAYyI,KAAK9E,EAAjB3D,CACEM,IAAEoI,OAAO,GAAIzI,EAAS,CACpB+C,WAAY,KACZtC,IAAKA,EACLO,cAtCkB,SAAS0H,GACL,IAApB1I,EAAQ2I,QAKZtI,IAAEiH,KAAK,CACLN,SAAU,OACVvG,IAAKA,EACLkI,QAAS3I,EAAQ2I,QACjBT,QAAS,SAASjH,GAEbA,EAAKoF,OACL3C,EAAKwD,uBAAuBjG,SACP,IAAfA,EAAK2H,OACG,OAAf3H,EAAK2H,MAOLlF,EAAKyD,oBAAoBnH,EAAzB0D,CAAkCzC,IAL9BA,EAAK2H,MAAMd,OAAS,IAAM9H,EAAQuI,QACpCG,EAAazH,GAEfjB,EAAQuB,gBAAgBN,OAM3BmG,KAAK1D,EAAKyD,oBAAoBnH,IAC9B6I,OAAO,gBACwB,IAAnB7I,EAAQc,QAA6C,OAAnBd,EAAQc,QACnDd,EAAQc,OAAOgI,gBA3BnBpF,EAAKyD,oBAAoBnH,EAAzB0D,CAAkC,CAAEF,QAAS,oDAoD/BxD,GAClB,IAAM0D,EAAOxD,KACW,IAApBF,EAAQ2I,QAIZtI,IAAEiH,KAAK,CACLN,SAAU,OACVvG,IA5zBsB,uBA6zBtB6C,KAAM,OACNrC,KAAM,CACJiI,WAAYjH,IAAGC,QAAQC,OAAO,CAC5BgB,GAAI,GACJgG,KAAMnJ,EAAQoJ,eACdC,OAAQrJ,EAAQqJ,QAAU,SAE5BC,SAAUrH,IAAGC,QAAQC,OAAO,CAC1BgH,KAAMnJ,EAAQuJ,UACdC,MAAO,CACLC,OAAQzJ,EAAQyJ,QAAU,OAIhCd,QAAS3I,EAAQ2I,QACjBT,QAAS,SAASjH,GACXA,EAAKoF,OAAU3C,EAAKwD,uBAAuBjG,IAAyB,IAAhBA,EAAKuC,OAG5DE,EAAKyD,oBAAoBnH,EAAzB0D,CAAkCzC,GAFlCjB,EAAQuB,gBAAgBN,MAM3BmG,KAAK1D,EAAKyD,oBAAoBnH,IAC9B6I,OAAO7I,EAAQ0J,gBA9BhBhG,EAAKyD,oBAAoBnH,EAAzB0D,CAAkC,CAAEF,QAAS,gDA2C7BxD,GAClB,IAAM0D,EAAOxD,KACW,IAApBF,EAAQ2I,QAIZtI,IAAEiH,KAAK,CACLN,SAAU,OACVvG,IAz2BsB,uBA02BtB6C,KAAM,OACNrC,KAAM,CACJiI,WAAYjH,IAAGC,QAAQC,OAAO,CAC5BgB,GAAI,GACJgG,KAAMnJ,EAAQoJ,eACdC,OAAQrJ,EAAQqJ,QAAU,SAE5BC,SAAUrH,IAAGC,QAAQC,OAAO,CAC1BgH,KAAMnJ,EAAQuJ,UACdI,MAAO,CACLC,MAAO,MAGXC,MAAO5H,IAAGC,QAAQC,OAAO,CACvB2H,GAAI,CAAC,CAAEC,EAAG,KACVC,IAAK,MAGTrB,QAAS3I,EAAQ2I,QACjBT,QAAS,SAASjH,GACXA,EAAKoF,OAAU3C,EAAKwD,uBAAuBjG,IAAyB,IAAhBA,EAAKuC,OAEnC,IAAhBvC,EAAKuC,OACdxD,EAAQiK,qBAAqBhJ,GAE7ByC,EAAKyD,oBAAoBnH,EAAzB0D,CAAkCzC,GAJlCjB,EAAQuB,gBAAgBN,MAQ3BmG,KAAK1D,EAAKyD,oBAAoBnH,IAC9B6I,OAAO7I,EAAQ0J,gBApChBhG,EAAKyD,oBAAoBnH,EAAzB0D,CAAkC,CAAEF,QAAS,uCA+CtCxD,GACT,IAAM0D,EAAOxD,KACTgK,EAAS,cACe,KAAxBlK,EAAQmK,OAAOhB,OACjBe,EAAS,gBAAkBlK,EAAQmK,OAAOhB,MAE5C,IAAM1I,EAl5Be,cAk5BUyJ,EA2B/BnK,EAAYyI,KAAK9E,EAAjB3D,CACEM,IAAEoI,OAAO,GAAIzI,EAAS,CACpB+C,WAAY,QACZtC,IAAKA,EACLO,cA9BkB,SAAS0H,GACL,IAApB1I,EAAQ2I,QAIZtI,IAAEiH,KAAK,CACLN,SAAU,OACVvG,IAAKA,EACLkI,QAAS3I,EAAQ2I,QACjBT,QAAS,SAASjH,GACXA,EAAKoF,OAAU3C,EAAKwD,uBAAuBjG,GAI9CyC,EAAKyD,oBAAoBnH,EAAzB0D,CAAkCzC,IAHlCyH,EAAazH,GACbjB,EAAQuB,gBAAgBN,OAM3BmG,KAAK1D,EAAKyD,oBAAoBnH,IAC9B6I,OAAO,gBACwB,IAAnB7I,EAAQc,QAA6C,OAAnBd,EAAQc,QACnDd,EAAQc,OAAOgI,gBAnBnBpF,EAAKyD,oBAAoBnH,EAAzB0D,CAAkC,CAAEF,QAAS,mDAwChCxD,GACjB,IAAM0D,EAAOxD,KAEPkK,EAAc,SAASC,GAC3B,IAAM3H,EAAMxB,KAAKwB,MACjB,OAAOgB,EAAKnB,WAAW,iCAAkC,CACvDsH,MAAO5H,IAAGC,QAAQC,OAAOkI,GACzBC,MAAOC,KAAKC,OAAO9H,EAAM1C,EAAQyK,QAAU,KAC3CC,IAAKH,KAAKC,MAAM9H,EAAM,KACtBiI,KAAM3K,EAAQ4K,OAAS,OAIrBC,EAAmBxK,IAAEsB,WAiC3B,OAhCAtB,IAAEyK,KACAV,EAAY,kEACZA,EAAY,kEACZA,EAAY,kEACZA,EAAY,uCAAyCpK,EAAQ+K,YAAc,MAC3EX,EAAY,iCAAmCpK,EAAQ+K,YAAc,OAEpE9D,KAAK,WAEJ,IADA,IAAM+D,EAAiB,GACdC,EAAI,EAAGA,EAAIC,UAAUpD,OAAQmD,IAAK,CACzC,IAAMhI,EAAWiI,UAAUD,GAC3B,GAAIhI,EAAShC,KAAKsC,OAAO,GAEvB,IADA,IAAM4H,EAASlI,EAAShC,KAAKsC,OAAO,GAAG4H,OAC9BC,EAAI,EAAGA,EAAID,EAAOrD,OAAQsD,IAC5BJ,EAAeG,EAAOC,GAAG,MAC5BJ,EAAeG,EAAOC,GAAG,IAAM,CAAgB,IAAfD,EAAOC,GAAG,GAAW,EAAG,EAAG,EAAG,EAAG,IAEnEJ,EAAeG,EAAOC,GAAG,IAAIH,EAAI,GAAKI,WAAWF,EAAOC,GAAG,IAIjE,IAAM7H,EAAS,GACfnB,OAAOC,KAAK2I,GAAgBlJ,QAAQ,SAAAwJ,GAClC/H,EAAOgI,KAAKP,EAAeM,MAE7B/H,EAAOiI,KAAK,SAACC,EAAGC,GACd,OAAOD,EAAE,GAAKC,EAAE,KAElBb,EAAiBvJ,QAAQiC,KAE1B6D,KAAKyD,EAAiBjI,QAElBiI,EAAiBxJ,sDASNrB,GACLE,KACRwH,UAjgCe,8BAigCY,GAAI1H,mDAGdA,GACTE,KACRqC,WAtgCe,8BAwgClB,CACEoJ,cAAe1J,IAAGC,QAAQC,OAAOnC,EAAQ2L,gBAE3C3L,6CAgBcA,GACHE,KACRqC,WA9hCe,oCAgiClB,CACEqJ,IAAK5L,EAAQ4L,IACbC,WAAY5J,IAAGC,QAAQC,OAAOnC,EAAQ6L,YACtCC,WAAY9L,EAAQ+L,UACpBC,SAAUhM,EAAQiM,QAClBC,QAASlM,EAAQmM,QAEnBnM,0CAYWA,GACb,IAAM0D,EAAOxD,KAETiD,EAAK,GACLnD,EAAQoM,OACVjJ,GAAMnD,EAAQoM,MAEZpM,EAAQsD,MAAyB,QAAjBtD,EAAQsD,OAC1BH,GAAMnD,EAAQsD,MAGhB,IAAIjC,EAAUqC,EAAKC,aAAa0I,UAAU7M,EAAe2D,GACnDmJ,OAAkC,IAAZjL,EAQ5B,GAPIiL,IACFjL,EAAUhB,IAAEsB,WACZ+B,EAAKC,aAAa4I,WAAWlL,EAAS7B,EAAe2D,IAGvD9B,EAAQ4F,KAAKjH,EAAQuB,iBAAiB6F,KAAK1D,EAAKyD,oBAAoBnH,IAE/DsM,EAAL,CAIA,IAAMrL,EAAO,CACXmL,KAAMpM,EAAQoM,MAGZpM,EAAQsD,MAAyB,QAAjBtD,EAAQsD,OAC1BrC,EAAKqC,KAAO,CAAC,YAAatD,EAAQsD,OAGpCjD,IAAEiH,KAAK,CACL7G,IAAKjB,EACLyB,KAAMA,EACNuL,aAAa,EACbtE,QAAS,SAASjH,GACXyC,EAAKwD,uBAAuBjG,GAG/BI,EAAQuB,OAAO3B,GAFfI,EAAQC,QAAQL,MAKnBmG,KAAK/F,EAAQuB,iDAeF5C,GACd,IAAM0D,EAAOxD,KACb,OAAOG,IAAEiH,KAAK,CACZ7G,IAvnCuB,sBAwnCvBQ,KAAM,CACJmL,KAAMpM,EAAQoM,KACdK,KAAMzM,EAAQ6J,MACdvG,KAAMtD,EAAQsD,KACdgF,KAAMtI,EAAQsI,KACdoE,MAAO1M,EAAQ0M,MACfC,gBAAiB3M,EAAQ2M,iBAE3BzE,QAAS,SAASjH,GACXyC,EAAKwD,uBAAuBjG,GAG/ByC,EAAKyD,oBAAoBnH,EAAzB0D,CAAkCzC,GAFlCjB,EAAQuB,gBAAgBN,MAK3BmG,KAAK1D,EAAKyD,oBAAoBnH,0CAWrBA,GACZ,IAAM0D,EAAOxD,KACPwB,EAAWrB,IAAEsB,WACbW,EAAUjC,IAAEiH,KAAK,CACrB7G,IAAKjB,EACLyB,KAAM,CACJmL,KAAMpM,EAAQoM,KACdnL,OAAQjB,EAAQ4M,eAElB1E,QAAS,SAASjH,GACXyC,EAAKwD,uBAAuBjG,GAG/BS,EAASkB,OACPc,EAAKyD,oBAAoB,CACvB3E,cAAexC,EAAQwC,iBAJ3Bd,EAASJ,QAAQL,MASpBmG,KACD1D,EAAKyD,oBAAoB,CACvB3E,cAAexC,EAAQwC,cACvBG,cAAejB,EAASkB,UAG5B,OAAO,IAAIC,UAAmBnB,EAAUY,iDAYpBtC,GACPE,KACRqC,WACH/C,EAAgB,QAChB,CACEqN,YAAa5K,IAAGC,QAAQC,OAAOnC,EAAQ8M,YACvC3D,KAAMlH,IAAGC,QAAQC,OAAOnC,EAAQmJ,OAElCnJ,0CAaWA,GACAE,KACRqC,WACH/C,EAAgB,SAChB,CACE4M,KAAMnK,IAAGC,QAAQC,OAAOnC,EAAQoM,MAChCjD,KAAMnJ,EAAQmJ,MAEhBnJ,0CAaWA,GACb,IAAM0D,EAAOxD,KACbG,IAAEiH,KAAK,CACL7G,IAAKjB,EAAgB,SACrB8D,KAAM,OACN4E,QAAS,SAASjH,GACXyC,EAAKwD,uBAAuBjG,GAG/ByC,EAAKyD,oBAAoBnH,EAAzB0D,CAAkCzC,GAFlCjB,EAAQuB,gBAAgBN,IAK5B8L,IAAK,WACH,IAAMC,EAAQ3M,IAAE4M,aAAaF,MAI7B,OAHIC,EAAME,QAAUlN,EAAQmN,iBAC1BH,EAAME,OAAOE,iBAAiB,WAAYpN,EAAQmN,iBAAiB,GAE9DH,GAEThG,SAAU,OACV/F,KAAMjB,EAAQqN,SACdC,OAAO,EACP9F,aAAa,EACb+F,aAAa,IACZnG,KAAK1D,EAAKyD,oBAAoBnH,yCAYtBA,GACEE,KACRqC,WACH/C,EAAgB,OAChB,CACEgO,gBAAiBvL,IAAGC,QAAQC,OAAOnC,EAAQyN,UAC3CC,qBAAsBzL,IAAGC,QAAQC,OAAOnC,EAAQ2N,gBAElD3N,0CAaWA,GACAE,KACRqC,WACH/C,EAAgB,SAChB,CACE4M,KAAMnK,IAAGC,QAAQC,OAAOnC,EAAQoM,MAChCwB,WAAY3L,IAAGC,QAAQC,OAAOnC,EAAQ6N,YAAa,IAErD7N,wCAYSA,GACEE,KACRqC,WACH/C,EAAgB,OAChB,CACE4M,KAAMnK,IAAGC,QAAQC,OAAOnC,EAAQoM,OAElCpM,2CAYYA,GACDE,KACRqC,WACH/C,EAAgB,UAChB,CACEsO,MAAO7L,IAAGC,QAAQC,OAAOnC,EAAQ8N,QAEnC9N,wCAcSA,GACX,IACMC,EADOC,KACgBC,yBAAyBH,GACtD,GAAIA,EAAQiE,SACV5D,IAAEC,aAAaL,EAAiB,QAC3B,CACL,IAAIQ,EAj2CsB,8BAk2CtBT,EAAQ+N,eACVtN,GAAOT,EAAQ+N,cAEb/N,EAAQgO,YACVvN,GAAO,IAAMT,EAAQgO,WAEnBhO,EAAQiO,SACVxN,GAAOT,EAAQiO,OAAOnG,OAAS,EAAI,IAAM9H,EAAQiO,OAAOjM,KAAK,KAAO,IAEtE,IAAM5B,EAAaC,IAAEC,aAAaL,IAAoB,UAC/CG,EAAWK,GAClBJ,IAAEC,aAAaL,EAAiBG,qDAYXJ,GACvB,IACM0B,EAAWrB,IAAEsB,WAEnB,GACyB,WAAvB3B,EAAQ+C,aACgB,eAAvB/C,EAAQkO,YAAsD,uBAAvBlO,EAAQkO,YAChD,CACA,IAAMjN,EAAO,CACXkN,UAAkC,uBAAvBnO,EAAQkO,WACnBE,QAASnI,KAAKoI,UAAUrO,EAAQgD,UAG9BhD,EAAQ+B,MAAQ/B,EAAQ+B,KAAK+F,OAAS,IACxC7G,EAAKqN,SAAWtO,EAAQ+B,KAAK,IAE3B/B,EAAQ+B,MAAQ/B,EAAQ+B,KAAK+F,OAAS,IACxC7G,EAAKsN,MAAQvO,EAAQ+B,KAAK,IAG5B,IAAMO,EAnBKpC,KAoBRqC,WAp4CqB,yBAo4CatB,EAAMjB,GACxCiH,KAAKvF,EAASJ,SACd8F,KAAK1F,EAASkB,QAEjB,OAAO,IAAIC,UAAmBnB,EAAUY,GAG1C,OAAOZ,EAASJ,UAAUD,sDAcRrB,GAClB,IAAM0D,EAAOxD,KACPwB,EAAWrB,IAAEsB,WAEb6M,GAAoD,IAA1CxO,EAAQ+C,WAAWwB,QAAQ,UACrCxB,EAAayL,EAAUxO,EAAQ+C,WAAWiF,QAAQ,SAAU,IAAMhI,EAAQ+C,WAE1ET,EAAUjC,IAAEiH,KAAK,CACrBhE,KAAM,OACN7C,IA56C0B,+BA46CM+N,EAAUxO,EAAQ+B,KAAK0M,MAAM,GAAKzO,EAAQ+B,MAAMC,KAAK,KACrFf,KAAM,CACJyN,SAAU,GACVC,QAAS1M,IAAGC,QAAQC,OAAO,CACzBmB,KAAMP,EACN6L,OAAQJ,EAAU,QAAU,SAE9BJ,QAASnM,IAAGC,QAAQC,OAAOnC,EAAQgD,QAAUhD,EAAQgD,QAAU,OAEjE2F,QAAS3I,EAAQ2I,UAEhB1B,KAAK,SAAAhG,GACJA,EAAK4N,SACa,IAAhB5N,EAAKuC,QACS,MAAdvC,EAAK0E,MACL1E,EAAKoF,SACmC,IAAvCpF,EAAKoF,MAAM9B,QAAQ,iBAC2B,IAA7CtD,EAAKoF,MAAM9B,QAAQ,sBACvBtD,EAAKwB,aAAevB,KAAKwB,OAKpBzB,EAAK4N,UAAYnL,EAAKwD,uBAAuBjG,GAChDyC,EAAKyD,oBAAoB,CACvB3E,cAAexC,EAAQwC,cACvBG,cAAejB,EAASkB,QAF1Bc,CAGGzC,GAEHS,EAASJ,QAAQL,KAGpBmG,KACC1D,EAAKyD,oBAAoB,CACvB3E,cAAexC,EAAQwC,cACvBG,cAAejB,EAASkB,UAI9B,OAAO,IAAIC,UAAmBnB,EAAUY,gDAGrBtC,GACnB,IACIS,EACEQ,EAAO,CACX6N,YAAa9O,EAAQ+C,YAiCvB,OA/B4B,IAAxB/C,EAAQ+B,KAAK+F,QACfrH,EAAM,wBAA0BT,EAAQ+B,KAAK,GAAK,SAClDd,EAAK4K,WAAa5J,IAAGC,QAAQC,OAAOnC,EAAQ6L,aACX,IAAxB7L,EAAQ+B,KAAK+F,QACtBrH,EAAM,oBAAsBT,EAAQ+B,KAAK,GAAK,IAAM/B,EAAQ+B,KAAK,GAAK,SAClE/B,EAAQ6L,aACN7L,EAAQ6L,WAAWkD,UACrB9N,EAAK8N,QAAU/O,EAAQ6L,WAAWkD,SAEhC/O,EAAQ6L,WAAW1C,OACrBlI,EAAK+N,eAAiBhP,EAAQ6L,WAAW1C,QAGpCnJ,EAAQ+B,KAAO,IACxBtB,EAAM,oBAAsBT,EAAQ+B,KAAK,GAAK,IAAM/B,EAAQ+B,KAAK,GAAK,gBACtEd,EAAKgO,OAASjP,EAAQ+B,KAAK0M,MAAM,GAAGzM,KAAK,KACrChC,EAAQ6L,aACN7L,EAAQ6L,WAAWkD,UACrB9N,EAAK8N,QAAU/O,EAAQ6L,WAAWkD,SAEhC/O,EAAQ6L,WAAW1C,OACrBlI,EAAKiO,gBAAkBlP,EAAQ6L,WAAW1C,MAExCnJ,EAAQ6L,WAAWvI,OACrBrC,EAAKkO,gBAAkBnP,EAAQ6L,WAAW1C,MAExCnJ,EAAQ6L,WAAWuD,aACrBnO,EAAKoO,eAAiBpN,IAAGC,QAAQC,OAAOnC,EAAQ6L,WAAWuD,eAhCpDlP,KAoCDqC,WAAW9B,EAAKQ,EAAMjB,yCAetBA,GACZ,IACM0B,EAAWrB,IAAEsB,WAEflB,EAAM,0BAA4BT,EAAQ+B,KAAK,GAE/C/B,EAAQ+B,KAAK+F,OAAS,IACxBrH,GAAO,IAAMT,EAAQ+B,KAAK,GAAK,KAG7B/B,EAAQ+B,KAAK+F,OAAS,IACxBrH,GAAO,SAAWT,EAAQ+B,KAAK0M,MAAM,GAAGzM,KAAK,MAG/C,IAAMf,EAAO,CACXqO,OAAQ,OACRlB,QAASnI,KAAKoI,UAAUrO,EAAQgD,SAChC8L,YAAa9O,EAAQ+C,YAGjBT,EAnBOpC,KAmBO,WAAeO,EAAKQ,EAAM,CAC5CuB,cAAexC,EAAQwC,cACvBjB,gBAAiB,SAAS0B,GACI,IAAxBjD,EAAQ+B,KAAK+F,OACX7E,EAAShC,MACXgC,EAAShC,KAAKwB,aAAevB,KAAKwB,MAClChB,EAASJ,QAAQ2B,EAAShC,OAE1BS,EAASkB,SAGXlB,EAASJ,QAAQ2B,IAGrBN,cAAejB,EAASkB,SAG1B,OAAO,IAAIC,UAAmBnB,EAAUY,2CAc1BtC,GACd,IAAM0D,EAAOxD,KACPwB,EAAWrB,IAAEsB,WAGbW,EAAUjC,IAAE0G,KAAK,oBAAsB/G,EAAQ+B,KAAKC,KAAK,KAAO,cAAe,CACnFsN,OAAQ,OACRlB,QAASnI,KAAKoI,UAAUrO,EAAQgD,WAE/BiE,KAAK,SAAAhE,GACCS,EAAKwD,uBAAuBjE,GAO/BS,EAAKyD,oBAAoB,CACvB3E,cAAexC,EAAQwC,cACvBG,cAAejB,EAASkB,QAF1Bc,CAGGT,IATEA,IACHA,EAAW,IAEbA,EAASR,aAAevB,KAAKwB,MAC7BhB,EAASJ,QAAQ2B,MAQpBmE,KAAK,SAAAnE,GAGFA,GACAA,EAAS8C,eACgD,IAAzD9C,EAAS8C,aAAaxB,QAAQ,sBAE9B7C,EAASJ,QAAQ,CACfmB,aAAcvB,KAAKwB,MACnB6M,oBAAqB,GACrBC,sBAAuB,KAGzB9L,EAAKyD,oBAAoB,CACvB3E,cAAexC,EAAQwC,cACvBG,cAAejB,EAASkB,QAF1Bc,CAGGT,KAIT,OAAO,IAAIJ,UAAmBnB,EAAUY,2CAe1BtC,GACd,IAAM0D,EAAOxD,KAEb,GAA4B,IAAxBF,EAAQ+B,KAAK+F,OACf,OAAOpE,EAAK+L,cAAczP,GAE5B,IAAM0B,EAAWrB,IAAEsB,WAEb+N,EAAW,GA4BXjP,EACJ,KACwB,SAAvBT,EAAQ+C,WAAwB,UAAY/C,EAAQ+C,YACrD,gBACA/C,EAAQ+B,KAAKC,KAAK,KAClB,IAiBF,OAfA0N,EAASnE,KACP7H,EAAKnB,WAAW9B,OAAKkH,EAAW,CAC9BnF,cAAexC,EAAQwC,cACvBjB,gBAAiB,SAASN,GACxByO,EAASC,MACW,IAAhB1O,EAAKuC,QAAgBvC,EAAK2O,UAtCZ,SAAlBC,EAAmBpP,EAAKqP,GAC5B5L,OAAO6L,WAAW,WAChBL,EAASnE,KACP7H,EAAKnB,WAAW9B,OAAKkH,EAAW,CAC9BnF,cAAexC,EAAQwC,cACvBjB,gBAAiB,SAASN,GACxByO,EAASC,MACL1O,EAAK+O,UACPN,EAASnE,KACP7H,EACG+L,cAAczP,GACdiH,KAAKvF,EAASJ,SACd8F,KAAK1F,EAASkB,SAEV3B,EAAKgP,UACdvO,EAASkB,OAAO3B,GAEhB4O,EAAgBpP,EAAK,MAGzBkC,cAAejB,EAASkB,WAG3BkN,GAgBGD,CAAgB5O,EAAK2O,UAAW,KAEhClO,EAASkB,UAGbD,cAAejB,EAASkB,UAIrB,IAAIC,UAAmBnB,OAAUiG,EAAW+H,yCAcvC1P,GACZ,IAAM0D,EAAOxD,KACPwB,EAAWrB,IAAEsB,WACbuO,EAAsB,GAExBC,GAAe,EAEnBzO,EAAS0F,KAAK,WACZlD,OAAOkM,aAAaD,KAoCtB,OAjCyB,SAAnBE,IACJ,IAAM/N,EAAUoB,EACbnB,WACC,6BACA,CACEmM,SAAU1O,EAAQsQ,aAClB3B,QAAS3O,EAAQuQ,YACjBnC,QAASnM,IAAGC,QAAQC,OAAOnC,EAAQgD,QAAUhD,EAAQgD,QAAU,OAEjE,CACER,cAAexC,EAAQwC,gBAG1ByE,KAAK,SAAAhE,GACJ,GAAIA,GAAYA,EAASuN,cAAgBvN,EAASuN,aAAahN,OAAQ,CACrE,IAAMA,EAASP,EAASuN,aAAahN,OACtB,cAAXA,EACF9B,EAASJ,UACW,YAAXkC,GAAmC,aAAXA,GAAoC,YAAXA,EAC1D2M,EAAcjM,OAAO6L,WAAW,WAC9BM,KACC,KAEH3O,EAASkB,YAIdwE,KAAK1F,EAASkB,QAEjBsN,EAAoB3E,KAAK,IAAI1I,UAAmBP,EAASA,IAG3D+N,GACO,IAAIxN,UAAmBnB,OAAUiG,EAAWuI,4CAkEpClQ,GAAS,IAAAyQ,EAAAvQ,KAClBwQ,EAAa1Q,EAAQ0Q,WACrBjQ,EA7yDiB,yBA6yDUiQ,EAAW3N,WACtCrB,EAAWrB,IAAEsB,WAEnBzB,KAAKqC,WAAW9B,EAAKgD,EAAUkN,0BAA0BD,GAAa1Q,GACnEiH,KAAK,SAAAhE,GACAA,EAAS2N,OACXlP,EAASJ,QAAQ2B,EAAS2N,QAE1BlP,EAASkB,OAAO,mCAGnBwE,KAAK1F,EAASkB,QAEjB,IAAMvB,EAAUK,EAASL,UAezB,OAbAA,EAAQwP,OAAS,WACf,IAAMC,EAAiBzQ,IAAEsB,WASzB,OARAD,EACGuF,KAAK,SAAA2J,GACA5Q,EAAQ0Q,WAAWE,SAAWA,IAChC5Q,EAAQ0Q,WAAWE,OAASA,GAE9BH,EAAKM,gBAAgB/Q,GAAS6I,OAAOiI,EAAexP,WAErD8F,KAAK0J,EAAexP,SAChBwP,GAGFzP,+CAWYrB,GACnB,IAAM0B,EAAWrB,IAAEsB,WAEbW,EAAUpC,KAAKqC,WACnB,6BACAkB,EAAUkN,0BAA0B3Q,EAAQ0Q,YAC5C1Q,GAECiH,KAAK,SAAAhE,GACJvB,EAASJ,QAAQ2B,EAASuN,aAAahN,UAExC4D,KAAK1F,EAASkB,QAEjB,OAAO,IAAIC,UAAmBnB,EAAUY,2CAW1BtC,GACd,OAAOE,KAAKqC,WACV,iCACAkB,EAAUkN,0BAA0B3Q,EAAQ0Q,YAC5C1Q,qFA8BeA,sHACV,IAAIgR,QAAQ,SAAC1P,EAASsB,GAC3B,IAAM3B,EAAOwC,EAAUkN,0BAA0B3Q,EAAQ0Q,YACzDzP,EAAKgQ,KAAOjR,EAAQiR,KACpBhQ,EAAKiQ,YAAclR,EAAQkR,UAE3BC,EAAK5O,WACH,kCACAtB,EACA,CACEuB,cAAexC,EAAQwC,cACvBwE,SAAU,QAEZhH,GAECiH,KAAK,SAAAhE,GACJ,IAAMhC,EAAOgF,KAAKmL,aAAanO,GAC/B3B,EAAQL,EAAKsC,UAEd6D,KAAKxE,8LAYU5C,sHACb,IAAIgR,QAAQ,SAAC1P,EAASsB,GAC3ByO,EAAK9O,WACH,kCACAkB,EAAUkN,0BAA0B3Q,EAAQ0Q,YAC5C1Q,GAECiH,KAAK,SAAAhE,GACJ3B,EAAQ2B,EAASM,UAElB6D,KAAKxE,gJAYG5C,GACb,IAAM0Q,EAAa1Q,EAAQ0Q,WAE3B,OAAOxQ,KAAKqC,WACV,gCACAkB,EAAUkN,0BAA0B,CAClC5N,WAAY2N,EAAW3N,WACvB6N,OAAQF,EAAWE,SAErB5Q,uCAkBQA,GACV,IAAM0D,EAAOxD,KACPwB,EAAWrB,IAAEsB,WAEbuO,EAAsB,GAExBI,EAAe,KACfC,EAAc,KAyFlB,OAzEA7M,EACGnB,WAv/DmB,wBAw/DEvC,EAAQ+B,KAAKC,KAAK,KACtC,CACE0M,SAAU,GACVC,QAAS1I,KAAKoI,UAAU,CACtB/K,KAAMtD,EAAQ+C,WACdC,QAAShD,EAAQgD,UAEnBsO,OAAO,EACPC,UAAW,KAAOvR,EAAQuR,WAAa,WAAa,IACpDnD,QAASnM,IAAGC,QAAQC,OAAOnC,EAAQgD,QAAUhD,EAAQgD,QAAU,OAEjE,CACER,cAAexC,EAAQwC,gBAG1ByE,KAAK,SAAAuK,GACJ,IAAMC,EAAc,IAAI3O,EAAY9C,EAAQ+C,WAAY/C,EAAQgD,QAASwO,GAKzE,GAHAlB,EAAerK,KAAKoI,UAAU,CAAE/K,KAAMtD,EAAQ+C,aAC9CwN,EAActK,KAAKoI,UAAUoD,GAEzBD,GAAkBA,EAAeP,KAAM,CAEzC,IAAMhQ,EAAO,CAAEA,KAAMuQ,EAAeP,KAAMS,KAAMF,EAAeG,cAC/D1Q,EAAKwB,aAAevB,KAAKwB,MACzBhB,EAASJ,QAAQL,QAEjBiP,EAAoB3E,KAClB7H,EACGkO,cAAc,CACbtB,aAAcA,EACdC,YAAaA,EACbvN,QAAShD,EAAQgD,QACjBR,cAAexC,EAAQwC,gBAExByE,KAAK,WACJ,IAAM4K,EAAgBnO,EACnBnB,WACC,kCACA,CACEmM,SAAU4B,EACV3B,QAAS4B,EACTU,KAAMjR,EAAQ8R,aAAe,IAC7BZ,UAAW,SAEb,CACE1O,cAAexC,EAAQwC,gBAG1ByE,KAAK,SAAAuK,GACJ,IAAMvQ,EAAQuQ,GAAkBA,EAAejO,QAAW,CACxDtC,KAAM,GACNyQ,KAAM,IAERzQ,EAAKwB,aAAevB,KAAKwB,MACzBhB,EAASJ,QAAQL,KAElBmG,KAAK1F,EAASkB,QAEjBsN,EAAoB3E,KAAKsG,EAAeA,KAEzCzK,KAAK1F,EAASkB,WAItBwE,KAAK1F,EAASkB,QAEjBsN,EAAoB3E,KAAK,CACvBsF,OApFkB,WACdP,GACF5M,EAAKnB,WACH,iCACA,CACEmM,SAAU4B,EACV3B,QAAS4B,EACTnC,QAASnM,IAAGC,QAAQC,OAAOnC,EAAQgD,QAAUhD,EAAQgD,QAAU,OAEjE,CAAER,cAAexC,EAAQwC,mBA8ExB,IAAIK,UAAmBnB,OAAUiG,EAAWuI,kDAc9BlQ,GACrB,IACM0B,EAAWrB,IAAEsB,WACflB,EAAMZ,EAEV,GAA4B,IAAxBG,EAAQ+B,KAAK+F,OACfrH,GAAO,uBAAyBT,EAAQ+B,KAAK,QACxC,GAA4B,IAAxB/B,EAAQ+B,KAAK+F,OACtBrH,IACGT,EAAQ+R,OAAS,aAAe,eACjC,aACA/R,EAAQ+B,KAAK,GACb,SACA/B,EAAQ+B,KAAK,OACV,IAA4B,IAAxB/B,EAAQ+B,KAAK+F,OAStB,OAAO,IAAIjF,UAAmBxC,IAAEsB,WAAWiB,UAR3CnC,GACE,wBACAT,EAAQ+B,KAAK,GACb,UACA/B,EAAQ+B,KAAK,GACb,SACA/B,EAAQ+B,KAAK,GAKjB,IAAMO,EAzBOpC,KAyBQqC,WACnB9B,EACA,CACEiO,SAAU,GACVC,QAAS1M,IAAGC,QAAQC,OAAO,CACzBmB,KAAM,SAGV,CACEd,cAAexC,EAAQwC,cACvBjB,gBAAiB,SAASN,IACxBA,EAAOA,EAAK+Q,QAAU/Q,GACjBwB,aAAevB,KAAKwB,MACzBhB,EAASJ,QAAQL,IAEnB0B,cAAejB,EAASkB,SAI5B,OAAO,IAAIC,UAAmBnB,EAAUY,qDAehBtC,GACxB,IACMiB,EAAO,CAAEkC,GAAIlB,IAAGC,QAAQC,OAAOnC,EAAQiS,WAW7C,OATIjS,EAAQ6L,aACV5K,EAAK4K,WAAa5J,IAAGC,QAAQC,OAAOnC,EAAQ6L,aAE1C7L,EAAQkS,yBACVjR,EAAKiR,uBAAyBjQ,IAAGC,QAAQC,OAAOnC,EAAQkS,yBAEtDlS,EAAQmS,4BACVlR,EAAKkR,0BAA4BlQ,IAAGC,QAAQC,OAAOnC,EAAQmS,4BAVhDjS,KAYDqC,WAAW1C,EAA4BoB,EAAMjB,iDAWrCA,GACpB,IAEM0B,EAAWrB,IAAEsB,WAEbW,EAJOpC,KAIQqC,WAAW1C,OAAoB8H,EAAW,CAC7DnF,cAAexC,EAAQwC,cACvBjB,gBAAiB,SAASN,GACpBA,GAAQA,EAAKmR,KACf1Q,EAASJ,QAAQL,EAAKmR,MAEtB1Q,EAASJ,QAAQ,KAGrBqB,cAAejB,EAASkB,SAG1B,OAAO,IAAIC,UAAmBnB,EAAUY,sCAG/B+P,EAAUD,GAEnB,OADalS,KACDqC,WAAW1C,EAAmB,CACxCsD,GAAIlB,IAAGC,QAAQC,OAAOkQ,GACtBD,KAAMnQ,IAAGC,QAAQC,OAAOiQ,2CAIdC,EAAUD,GAEtB,OADalS,KACDqC,WAAW1C,EAAsB,CAC3CsD,GAAIlB,IAAGC,QAAQC,OAAOkQ,GACtBD,KAAMnQ,IAAGC,QAAQC,OAAOiQ,mDAYNpS,GACpB,IAEIS,EAAKQ,EADHS,EAAWrB,IAAEsB,WAGnB,GAA6B,IAAzB3B,EAAQ6B,MAAMiG,QAA4C,IAA5B9H,EAAQ6B,MAAM,GAAGiG,OACjDrH,EAAMX,EACNmB,EAAO,CACLqN,SAAUtO,EAAQ6B,MAAM,GAAG,QAExB,CACLpB,EAAMX,EACN,IAAM8B,EAAW,GACjB5B,EAAQ6B,MAAMC,QAAQ,SAAAC,GACpBH,EAAS2J,KAAKxJ,EAAKC,KAAK,QAE1Bf,EAAO,CACLW,SAAUK,IAAGC,QAAQC,OAAOP,IAIhC,IAAMU,EApBOpC,KAoBQqC,WAAW9B,EAAKQ,EAAM,CACzCuB,cAAexC,EAAQwC,cACvBjB,gBAAiB,SAASN,GACxBA,EAAKwB,aAAevB,KAAKwB,MACzBhB,EAASJ,QAAQL,IAEnB0B,cAAejB,EAASkB,SAG1B,OAAO,IAAIC,UAAmBnB,EAAUY,8CAWvBtC,GACjB,OAAOwB,EAA6BtB,KAAMF,EAASF,iDAW/BE,GACpB,OAAOwB,EAA6BtB,KAAMF,EAASF,iDAW/BE,GACpB,OAAOwB,EAA6BtB,KAAMF,EAASF,+CAWjCE,GAClB,OAAOwB,EAA6BtB,KAAMF,EAASF,2CAYrCE,GACd,IACM0B,EAAWrB,IAAEsB,WAEbW,EAHOpC,KAGQqC,WACnBzC,EACA,CACEiO,aAAc/N,EAAQ+B,KAAK,GAC3BiM,UAAWhO,EAAQ+B,KAAK,IAE1B,CACES,cAAexC,EAAQwC,cACvBjB,gBAAiB,SAAS0B,GACA,IAApBA,EAASO,QAAgBP,EAASqP,SACpCrP,EAASqP,QAAQ7P,aAAevB,KAAKwB,MACrChB,EAASJ,QAAQ2B,EAASqP,UAE1B5Q,EAASkB,UAGbD,cAAejB,EAASkB,SAI5B,OAAO,IAAIC,UAAmBnB,EAAUY,uDAUdtC,GAC1B,IAAM0D,EAAOxD,KAGPwB,EAAWrB,IAAEsB,WAEf4Q,EAAQ,EAENrC,EAAsB,GAEtB7O,EAAU,IAAIwB,UAAmBnB,OAAUiG,EAAWuI,GAsC5D,OApCwB,SAAlBL,IACU,KAAV0C,GAIJA,IACArC,EAAoBP,MACpBO,EAAoB3E,KAClB7J,EACAgC,EACGnB,WAnBK,4BAqBJ,CACE6L,QAASnI,KAAKoI,UAAUrO,EAAQgD,SAChCwP,SAAU,IAAMxS,EAAQyS,QAAU,KAEpCzS,GAEDiH,KAAK,SAAAhE,GACJ,GAAIA,GAAYA,EAAShC,KACvBS,EAASJ,QAAQ2B,EAAShC,UACrB,CACL,IAAM0H,EAAUzE,OAAO6L,WAAW,WAChCF,KACC,IAAe,IAAR0C,GACVlR,EAAQqR,SAAS,WACfxO,OAAOkM,aAAazH,QAIzBvB,KAAK1F,EAASkB,UA5BjBlB,EAASkB,SAgCbiN,GAEOxO,oDAGiBrB,GACxB,IAEM0B,EAAWrB,IAAEsB,WAEbW,EAJOpC,KAIQqC,WAHT,gCAKV,CACE6L,QAASnI,KAAKoI,UAAUrO,EAAQgD,SAChC2P,IAAK1M,KAAKoI,UAAUrO,EAAQ2S,KAC5BC,WAAY5S,EAAQ4S,YAEtB,CACEpQ,cAAexC,EAAQwC,cACvBjB,gBAAiB,SAAS0B,GACA,IAApBA,EAASO,OACX9B,EAASJ,QAAQ2B,EAASqP,SAE1B5Q,EAASkB,UAGbD,cAAejB,EAASkB,SAI5B,OAAO,IAAIC,UAAmBnB,EAAUY,yDAGZtC,GAC5B,IAEM0B,EAAWrB,IAAEsB,WAEbW,EAJOpC,KAIQqC,WAHT,oCAKV,CACE6L,QAASnI,KAAKoI,UAAUrO,EAAQoO,SAChCoE,SAAU,IAAMxS,EAAQyS,QAAU,KAEpC,CACEjQ,cAAexC,EAAQwC,cACvBjB,gBAAiB,SAAS0B,GACA,IAApBA,EAASO,OACX9B,EAASJ,QAAQ2B,EAAShC,MAE1BS,EAASkB,UAGbD,cAAejB,EAASkB,SAI5B,OAAO,IAAIC,UAAmBnB,EAAUY,kDASnBtC,GACrB,IACMS,EAAM,oCAAsCT,EAAQ+C,WAC1D,OAFa7C,KAEDwH,UAAUjH,OAAKkH,EAAW3H,gDASnBA,GACnB,IACMS,EAAM,kCAAoCT,EAAQ+C,WACxD,OAFa7C,KAEDwH,UAAUjH,OAAKkH,EAAW3H,gDASnBA,GACnB,IACMS,EAAM,kCAAoCT,EAAQ+C,WACxD,OAFa7C,KAEDwH,UAAUjH,OAAKkH,EAAW3H,4CAGvBiB,GACf,OAAOZ,IAAE0G,KAp9EQ,4BAo9EW9F,mDAGN4I,GACtB,IAAMnI,EAAWrB,IAAEsB,WACbW,EAAUjC,IAAE0G,KAz8ES,2CAy8EoB,CAC7C8L,QAAS5Q,IAAGC,QAAQC,OAAO0H,GAC3B6C,MAAO,GACPoG,QAAS,kBAER7L,KAAK,SAAAhG,GACgB,IAAhBA,EAAKuC,OACP9B,EAASJ,QAAQL,GAEjBS,EAASkB,OAAO3B,KAGnBmG,KAAK1F,EAASkB,QACjB,OAAO,IAAIC,UAAmBnB,EAAUY,uDAGdtC,GAC1B,IAAM0B,EAAWrB,IAAEsB,WACbW,EAAUjC,IAAE0G,KA39ES,2CA29EoB,CAC7C8L,QAAS5Q,IAAGC,QAAQC,OAAOnC,EAAQ6J,OACnCkJ,aAAc9Q,IAAGC,QAAQC,OAAOnC,EAAQgT,QAAU,IAClDtG,MAAO,GACPoG,QAAS,0BAER7L,KAAK,SAAAhG,GACgB,IAAhBA,EAAKuC,OACP9B,EAASJ,QAAQL,GAEjBS,EAASkB,OAAO3B,KAGnBmG,KAAK1F,EAASkB,QACjB,OAAO,IAAIC,UAAmBnB,EAAUY,0CAG3BtC,GACb,IACM0B,EAAWrB,IAAEsB,WAEbW,EAHOpC,KAGQqC,WAj/EN,+BAm/Eb,CACEsQ,QAAS5Q,IAAGC,QAAQC,OAAOnC,EAAQ6J,OACnC6C,MAAO1M,EAAQ0M,OAAS,IACxBuG,YAAajT,EAAQkT,SACrBJ,QAAS9S,EAAQ8S,QAAU7Q,IAAGC,QAAQC,OAAOnC,EAAQ8S,SAAW,WAElE,CACEtQ,cAAexC,EAAQwC,cACvBjB,gBAAiBG,EAASJ,QAC1BqB,cAAejB,EAASkB,SAI5B,OAAO,IAAIC,UAAmBnB,EAAUY,qCAShCtC,GACR,IACM0B,EAAWrB,IAAEsB,WAEbW,EAHOpC,KAGQqC,WAhhFF,uBAkhFjB,CACE4Q,WAAYnT,EAAQmT,YAEtB,CACE3Q,cAAexC,EAAQwC,cACvBjB,gBAAiBG,EAASJ,QAC1BqB,cAAejB,EAASkB,SAI5B,OAAO,IAAIC,UAAmBnB,EAAUY,yDAzzBToO,GAC/B,IAAM0C,EAAY1C,EAAW2C,eACvB1E,EAAU,CACdrL,KAAMoN,EAAW3N,WACjBQ,OAAQ,CACNqN,OAAQF,EAAWE,QAErBpN,OAAQkN,EAAWlN,OACnBL,GAAIuN,EAAW4C,WAAalQ,UAASC,OACrCkQ,cAAeH,EACfA,UAAWA,EACXI,UAAW,GACXxQ,QAAS0N,EAAW1N,QACpBsL,SAAUoC,EAAWpC,SACrBzC,WAAY,CAAE4H,SAAU,KAGpB/E,EAAW,CACfpL,KAAMoN,EAAW3N,WACjB2Q,SAAU,CAAC/E,GACXxL,GAAIuN,EAAWiD,WACfxK,KAAM,GACNyK,SAAS,EACTC,SAAUnD,EAAWmD,UAAY,IAGnC,MAAO,CACLlF,QAAS1I,KAAKoI,UAAUM,GACxBD,SAAUzI,KAAKoI,UAAUK,2CAmyBhBjN;;;;8OCxiFTmC,EAAkB,eAnBtB,SAAAkQ,iGAAc5Q,CAAAhD,KAAA4T,GACC5T,KACR6T,UAAY,4DAGTtT,EAAKD,GAEb,OADaN,KACD6T,UAAUtT,GAAOD,GAAQ,wCAG5Ba,EAASZ,EAAKD,GACvB,IAAMkD,EAAOxD,KACbwD,EAAKqQ,UAAUtT,GAAOD,GAAQ,KAAOa,EACrCA,EAAQwH,OAAO,kBACNnF,EAAKqQ,UAAUtT,GAAOD,GAAQ,6CAO5BoD;;;;4XCnBTf,aACJ,SAAAA,EAAYnB,EAAUY,EAAS0R,gGAAmB9Q,CAAAhD,KAAA2C,GACnC3C,KACR+T,gBAAkB,GADV/T,KAERwB,SAAWA,EAFHxB,KAGRoC,QAAUA,EAHFpC,KAIR8T,kBAAoBA,EAJZ9T,KAKRgU,WAAY,EALJhU,KAMRiU,iBAAkB,iEAevB,OAFajU,KACRiU,iBAAkB,EADVjU,sCAOb,GADaA,KACJiU,iBADIjU,KACoBgU,WAA8B,YADlDhU,KACsCkU,QACjD,OAAO/T,IAAEsB,WACNL,UACAD,UAJQnB,KAORgU,WAAY,EAPJhU,KAQJoC,SACPb,UAAU4S,oBATCnU,KASwBoC,SATxBpC,KAYJkU,OAA0B,YAZtBlU,KAYUkU,SAZVlU,KAYwCwB,SAASkB,QAZjD1C,KAaNwB,SAASkB,SAGhB,IAAM0R,EAAiB,GASvB,IAzBapU,KAiBJ8T,mBAjBI9T,KAkBN8T,kBAAkBlS,QAAQ,SAAAyS,GACzBA,EAAY1D,QACdyD,EAAe/I,KAAKgJ,EAAY1D,YApBzB3Q,KAyBD+T,gBAAgBnM,QAzBf5H,KA0BN+T,gBAAgBtE,KAArBjM,GAEF,OAAOrD,IAAEyK,KAAKwJ,oCAGPE,GAOP,OANatU,KACJgU,UACPM,IAFWtU,KAIN+T,gBAAgB1I,KAAKiJ,GAJftU,oCAYb,OAFaA,KACRwB,SAAS+S,KAAKC,MADNxU,KACiBwB,SAAUwJ,WAD3BhL,kCAKVsU,GAGH,OAFatU,KACRwB,SAASuF,KAAKyN,MADNxU,KACiBwB,SAAUwJ,WAD3BhL,kCAKVsU,GAGH,OAFatU,KACRwB,SAAS0F,KAAKsN,MADNxU,KACiBwB,SAAUwJ,WAD3BhL,oCAKRsU,GAGL,OAFatU,KACRwB,SAASmH,OAAO6L,MADRxU,KACmBwB,SAAUwJ,WAD7BhL,kCAKVsU,GAGH,OAFatU,KACRwB,SAASiT,KAAKD,MADNxU,KACiBwB,SAAUwJ,WAD3BhL,sCAKNsU,GAGP,OAFatU,KACRwB,SAASkT,SAASF,MADVxU,KACqBwB,SAAUwJ,WAD/BhL,qCAOb,OADaA,KACDwB,SAAS0S,OADRlU,KACsBwB,SAAS0S,6CAIjCvR;;;;6DCjIfgS,EAAAC,EAAAC,GAAA,IAAAC,EAAAH,yBAAA,kDAwEeE,EAAA,SACbE,iBARuB,SAAC5T,EAASrB,GAIjC,OAHIqB,IAAWA,EAAQ6T,eAAmBlV,GAAYA,EAAQuU,aAC5DlT,EAAQ6T,gBAEH7T,GAKP8T,aA/CmB,SAACC,EAAmBC,EAAeC,EAAOC,GAA1C,OACnB9T,UAAU2T,GAAmB,CAC3BrS,WAAYuS,EAAME,YAAYzS,WAC9BC,QAASsS,EAAMtS,QACfjB,KAAMuT,EAAMvT,KACZF,MAAOyT,EAAMzT,MACbW,cAAe+S,GAAcA,EAAW/S,cACxCuP,OAAQuD,EAAMvD,QAAUuD,EAAMvD,WAC7B9K,KAAK,SAAAhG,GACNqU,EAAMD,GAAiBpU,EACvBqU,EAAMG,eAsCRC,kBA7BwB,SAAA1V,GAOxB,OANKA,IACHA,EAAU,SAEyB,IAA1BA,EAAQwC,gBACjBxC,EAAQwC,eAAgB,GAEnBxC;;;;+4BC3BT,IAAM2V,EAAkBzR,OAAOS,gBAG3BiR,GAAe,EAYbC,EAAuB,SAAS7V,GACpC,IAAImD,EAAKnD,EAAQ8V,UAAU3S,GAC3B,GAAInD,EAAQ+B,KACkB,iBAAjB/B,EAAQ+B,KACjBoB,GAAM,IAAMnD,EAAQ+B,KACX/B,EAAQ+B,KAAK+F,SACtB3E,GAAM,IAAMnD,EAAQ+B,KAAKC,KAAK,WAE3B,GAAIhC,EAAQ6B,OAAS7B,EAAQ6B,MAAMiG,OAAQ,CAChD,IAAMiO,EAAU,GAChB/V,EAAQ6B,MAAMC,QAAQ,SAAAC,GACpBgU,EAAQhU,EAAKC,KAAK,OAAQ,IAE5B,IAAMgU,EAAc5T,OAAOC,KAAK0T,GAChCC,EAAYxK,OACZrI,GAAM,IAAM6S,EAAYhU,KAAK,KAE/B,OAAOmB,GAiEH8S,aAMJ,SAAAA,EAAYlT,gGAAYG,CAAAhD,KAAA+V,GACT/V,KACR6C,WAAaA,EADL7C,KAERgW,QAAU,GAFFhW,KAGRiW,iBAAmB,GAHXjW,KAIRkW,kBAAoB,GAJZlW,KAKRmW,MAAQC,IAAYC,eAAe,CACtCpN,KAAM,kBANKjJ,KAMoB6C,WAAa,IAAM4S,IANvCzV,KAQRsW,gBAAkBF,IAAYC,eAAe,CAChDpN,KAAM,kBATKjJ,KASoB6C,WAAa,eAAiB4S,iEAQ/DC,GAAe,wCAOfA,GAAe,uDAUf,OAAOa,gBAAsC,SADhCvW,KACiB6C,YAA6C,WAD9D7C,KAC+C6C,wDAU1C+S,EAAW9S,EAAS0T,GACtC,IAAMhT,EAAOxD,KACPwB,EAAWrB,IAAEsB,WACnB,IAAKmU,IAAc9S,EACjB,OAAwB,IAApB0T,EAAS5O,QACXpE,EAAKwS,QAAU,GACfxS,EAAK2S,MACFM,QACAlC,KAAK/S,EAASJ,SACdsV,MAAMlV,EAASkB,QACXlB,EAASL,WAEXK,EAASkB,SAASvB,UAG3B,IAAMwV,EAAYhB,EAAqB,CAAEC,UAAWA,EAAW/T,KAAM2U,IACrEtU,OAAOC,KAAKqB,EAAKwS,SAASpU,QAAQ,SAAAwJ,GACD,IAA3BA,EAAI/G,QAAQsS,WACPnT,EAAKwS,QAAQ5K,KAIxB,IAAMwL,EAAiB,GACjBC,EAAe1W,IAAEsB,WAmBvB,OAlBAmV,EAAevL,KAAKwL,EAAa1V,WACjCqC,EAAK2S,MACFhU,OACAoS,KAAK,SAAApS,GACJA,EAAKP,QAAQ,SAAAwJ,GACX,GAA+B,IAA3BA,EAAI/G,QAAQsS,GAAkB,CAChC,IAAMG,EAAiB3W,IAAEsB,WACzBmV,EAAevL,KAAKyL,EAAe3V,WACnCqC,EAAK2S,MACFY,WAAW3L,GACXmJ,KAAKuC,EAAe1V,SACpBsV,MAAMI,EAAepU,WAG5BmU,EAAazV,YAEdsV,MAAMG,EAAanU,QAEfvC,IAAEyK,KAAK4J,MAAMrU,IAAGyW,+CASLI,GAElB,IAAKtB,GAAgBlR,cAAcyS,SAAW,EAC5C,OAAO9W,IAAEsB,WACNL,UACAD,UAEL,IAAMK,EAAWrB,IAAEsB,WAEbyV,EAAavB,EAAqBqB,GAiBxC,OAzBahX,KAURmW,MACFgB,QAAQD,EAAY,CACnBE,QAnNqB,EAoNrBC,WAAYL,EAAiBK,WAC7BC,WAAYN,EAAiBM,WAC7BlO,SAAU4N,EAAiB5N,SAC3B8F,WAAY8H,EAAiB9H,WAC7BqI,OAAQP,EAAiBO,OACzBC,cAAeR,EAAiBQ,cAChCC,WAAYT,EAAiBS,WAC7BC,iBAAkBV,EAAiBU,mBAEpCnD,KAAK/S,EAASJ,SACdsV,MAAMlV,EAASkB,QAEXlB,EAASL,gEAeYrB,GAC5B,IAAM0D,EAAOxD,KACPwB,EAAWrB,IAAEsB,WACbuO,EAAsB,GACxB2H,EAAiB,GACfC,EAAc,GAEpB9X,EAAU+X,UAAarC,kBAAkB1V,GAEzC,IAAMgY,EAAmB,GAmHzB,OAlHAhY,EAAQ6B,MAAMC,QAAQ,SAAAC,GACpB,IAAMkW,EAAmB5X,IAAEsB,WAC3B+B,EACGwU,SAAS,CAAEpC,UAAW9V,EAAQ8V,UAAW9S,QAAShD,EAAQgD,QAASjB,KAAMA,IACzEkF,KAAK,SAAAkR,GACAA,EAAWC,mCACbD,EAAWC,mCACRnR,KAAK,SAAAoR,GACJR,EAAiBA,EAAehQ,OAAOwQ,GACvCJ,EAAiB3W,YAElB8F,KAAK6Q,EAAiBrV,QAChBuV,EAAWZ,YAAcY,EAAWZ,WAAWe,aACxDpI,EAAoB3E,KAClB4M,EACGI,YAAYvY,GACZiH,KAAK,SAAAuR,GACJA,EAAa1W,QAAQ,SAAA2W,GACfA,EAAWb,kBACbC,EAAetM,KAAKkN,KAGxBR,EAAiB3W,YAElB8F,KAAK6Q,EAAiBrV,UAG3BkV,EAAYvM,KAAKxJ,GACjBkW,EAAiB3W,aAGpB8F,KAAK6Q,EAAiBrV,QACzBoV,EAAiBzM,KAAK0M,EAAiB5W,aAGzChB,IAAEyK,KAAK4J,MAAMrU,IAAG2X,GAAkBnP,OAAO,WACvC,IAAM6P,EAAerY,IAAEsB,WACnBmW,EAAYhQ,OACdoI,EAAoB3E,KAClB9J,UACGkX,sBAAsB,CACrBnW,cAAexC,EAAQwC,cACvBX,MAAOiW,IAER7Q,KAAK,SAAAhG,GACJ,IAAM2X,EAAW,GAEXC,EAA4B,SAASC,GACrC7X,EAAKkK,OAAO2N,IACd7X,EAAKkK,OAAO2N,GAAUhX,QAAQ,SAAAmN,GAC5B,IAAI8J,EAAYH,EAAS3J,EAAO+J,OAAS,IAAM/J,EAAOjB,WACjD+K,IACHA,EAAY,CAAE5N,OAAQ,IACtByN,EAAS3J,EAAO+J,OAAS,IAAM/J,EAAOjB,WAAa+K,GAEhDA,EAAU5N,OAAO2N,KACpBC,EAAU5N,OAAO2N,GAAY,IAE/BC,EAAU5N,OAAO2N,GAAUvN,KAAK0D,MAKlChO,EAAKkK,SACP0N,EAA0B,iBAC1BA,EAA0B,kBAC1BA,EAA0B,eAC1BA,EAA0B,kBAC1BA,EAA0B,kBAG5B,IAAMI,EAAgB,GAEtB7W,OAAOC,KAAKuW,GAAU9W,QAAQ,SAAAC,GAC5B,IAAMmX,EAAgB7Y,IAAEsB,WACxB+B,EACGwU,SAAS,CAAEpC,UAAW9V,EAAQ8V,UAAW9S,QAAShD,EAAQgD,QAASjB,KAAMA,IACzEkF,KAAK,SAAAqO,GACJpF,EAAoB3E,KAClB+J,EAAM6D,eACJ,qCACA7D,EACG8D,8BAA8BR,EAAS7W,GAAO/B,GAC9CiH,KAAK,SAAAiP,GACJ2B,EAAiBA,EAAehQ,OAAOqO,GACvCgD,EAAc5X,YAEf8F,KAAK8R,EAAc5X,aAI3B8F,KAAK8R,EAActW,QACtBqW,EAAc1N,KAAK2N,EAAc7X,aAGnChB,IAAEyK,KAAK4J,MAAMrU,IAAG4Y,GAAepQ,OAAO,WACpC6P,EAAapX,cAGhB8F,KAAKsR,EAAa9V,SAGvB8V,EAAapX,UAEfoX,EAAa7P,OAAO,WAClBxI,IAAEyK,KACC4J,MAAMrU,IAAG6P,GACTjJ,KAAK,WACJvF,EAASJ,QAAQuW,KAElBzQ,KAAK1F,EAASkB,YAIdmV,UAAa9C,iBAClB,IAAIpS,UAAmBnB,EAAUwO,GACjClQ,yCAWUA,GAEZ,OADaE,KACDgW,QAAQL,EAAqB7V,8CAqBzBA,GAChB,IAAM0D,EAAOxD,KACPgZ,EAAgB7Y,IAAEsB,WAClBI,EAAO,CAAC,UAAW/B,EAAQmJ,MAE3BkQ,EAAqB,GAErBC,EAAe,SAAShE,EAAOkC,GACnClC,EAAMkC,WAAaA,GAAclC,EAAMiC,WACvCjC,EAAMiE,kBAAoBlZ,IAAEsB,WACzBL,QAAQgU,EAAMkC,YACdnW,UACHiU,EAAMoC,cAAgB,CAAE3I,QAAS,IACjCuG,EAAMkE,qBAAuBnZ,IAAEsB,WAC5BL,QAAQgU,EAAMoC,eACdrW,UACHiU,EAAMhM,SAAW,CAAEmQ,SAAS,GAC5BnE,EAAMoE,gBAAkBrZ,IAAEsB,WACvBL,QAAQgU,EAAMhM,UACdjI,WAGDsY,EAAc,aAEZC,EAAmB/D,EAAqB,CAC5CC,UAAW9V,EAAQ8V,UACnB/T,KAAM,KAGR,IAAK2B,EAAKyS,iBAAiByD,GAAmB,CAC5C,IAAMC,EAAiBxZ,IAAEsB,WACzB+B,EAAKyS,iBAAiByD,GAAoBC,EAAexY,UACzD,IAAMyY,EAAc,IAAIC,UAAiB,CACvCC,aAAa,EACbxE,YAAa9R,EACboS,UAAW9V,EAAQ8V,UACnB9S,QAAShD,EAAQgD,QACjBjB,KAAM,GACNwV,WAAY,CACV0C,MAAO,EACP3B,cAAc,EACdhV,KAAM,YAGVgW,EAAaQ,GACbT,EAAmB9N,KAAKqO,GACxBE,EAAYI,gBAAkB7Z,IAAEsB,WAC7BL,QAAQ,IACRD,UACHwY,EAAevY,QAAQwY,GAqJzB,OAlJApW,EAAKyS,iBAAiByD,GAAkB3S,KAAK,SAAA6S,GAC3CA,EAAYvB,cAActR,KAAK,SAAAkT,GAC7B,IAAMC,EAAqBvE,EAAqB,CAC9CC,UAAW9V,EAAQ8V,UACnB/T,KAAM,CAAC,aAGT,IAAK2B,EAAKyS,iBAAiBiE,GAAqB,CAC9C,IAAMC,EAAmBha,IAAEsB,WAC3B+B,EAAKyS,iBAAiBiE,GAAsBC,EAAiBhZ,UAC7D,IAAMiZ,EAAgB,IAAIP,UAAiB,CACzCC,aAAa,EACbxE,YAAa9R,EACboS,UAAW9V,EAAQ8V,UACnB9S,QAAShD,EAAQgD,QACjBjB,KAAM,CAAC,WACPwV,WAAY,CACV0C,MAAO,EACP3B,cAAc,EACdhV,KAAM,cAGVgW,EAAagB,GACbjB,EAAmB9N,KAAK6O,GACxBE,EAAcJ,gBAAkB7Z,IAAEsB,WAC/BL,QAAQ,IACRD,UACHgZ,EAAiB/Y,QAAQgZ,GACzBH,EAA2B5O,KAAK+O,GAGlC5W,EAAKyS,iBAAiBiE,GAAoBnT,KAAK,SAAAqT,GAC7CA,EAAc/B,cAActR,KAAK,SAAAsT,GAC/B,IAAMC,EAAkB3E,EAAqB,CAC3CC,UAAW9V,EAAQ8V,UACnB/T,KAAMA,IAER2B,EAAKyS,iBAAiBqE,GAAmBtB,EAAc7X,UACvDgY,EAAmB9N,KAAKiP,GAExB,IAAMrC,EAAa,IAAI4B,UAAiB,CACtCC,aAAa,EACbxE,YAAa9R,EACboS,UAAW9V,EAAQ8V,UACnB9S,QAAShD,EAAQgD,QACjBjB,KAAMA,EACNwV,WAAY,CACVxI,QAAS,GACTkL,MAAO,EACP9Q,KAAMnJ,EAAQmJ,KACdmP,cAAc,EACdhV,KAAM,WAGViX,EAAwBhP,KAAK4M,GAC7B,IAAMsC,EAAgBF,EAAwBzS,OAAS,EACvD6R,EAAc,WACZY,EAAwBG,OAAOD,EAAe,IAGhD,IAAME,EAAmBta,IAAEsB,WAG3B,GAFAwW,EAAW+B,gBAAkBS,EAAiBtZ,UAE1CrB,EAAQ4a,QAAS,CACnB,IAAMpC,EAAe,GAErBc,EAAanB,EAAY,CACvByC,QAAS,GACTC,iBAAkB,GAClB9L,QAAS,GACTF,UAAU,EACV4K,SAAS,IAGXtB,EAAWV,OAAS,CAClBxW,KAAMjB,EAAQyX,QAAU,GACxB/F,KAAMyG,EAAWX,WAAWqD,kBAE9B1C,EAAW2C,cAAgBza,IAAEsB,WAC1BL,QAAQ6W,EAAWV,QACnBpW,UAEH,IAAI4Y,EAAQ,EACZja,EAAQ4a,QAAQ9Y,QAAQ,SAAAmN,GACtB,IAAM8L,EAAahZ,EAAK8F,OAAOoH,EAAO9F,MAChC6R,EAAmBnF,EAAqB,CAC5CC,UAAW9V,EAAQ8V,UACnB/T,KAAMgZ,IAGFE,EAAiB5a,IAAEsB,WACzB+B,EAAKyS,iBAAiB6E,GAAoBC,EAAe5Z,UACzDgY,EAAmB9N,KAAKyP,GAExB,IAAME,EAAc,IAAInB,UAAiB,CACvCC,aAAa,EACbxE,YAAa9R,EACboS,UAAW9V,EAAQ8V,UACnB9S,QAAShD,EAAQgD,QACjBjB,KAAMgZ,EACNxD,WAAY,CACVxI,QAAS,GACTkL,MAAOA,IACP9Q,KAAM8F,EAAO9F,KACbgS,cAAc,EACd7X,KAAM2L,EAAO3L,QAIjB4X,EAAYzD,OAAS,CACnBxW,KAAM,GACNyQ,KAAMzC,GAEJjP,EAAQyX,QACVzX,EAAQyX,OAAO3V,QAAQ,SAAAsZ,GACrBF,EAAYzD,OAAOxW,KAAKsK,KAAK,CAAC6P,EAAUnB,EAAQ,OAGpDiB,EAAYJ,cAAgBza,IAAEsB,WAC3BL,QAAQ4Z,EAAYzD,QACpBpW,UAEH8W,EAAWX,WAAWoD,QAAQrP,KAAK0D,EAAO9F,MAC1CgP,EAAWX,WAAWqD,iBAAiBtP,KAAK2P,EAAY3D,YACxD0D,EAAe3Z,QAAQ4Z,GACvB5B,EAAa4B,EAAa,CACxBnM,QAAS,GACT5F,KAAM8F,EAAO9F,KACbkS,UAAU,EACV5D,OAAQ,GACRnU,KAAM2L,EAAO3L,OAGfkV,EAAajN,KAAK2P,KAEpBP,EAAiBrZ,QAAQkX,QAEzBmC,EAAiBrZ,QAAQ,IAG3B4X,EAAc5X,QAAQ6W,WAMvB,CACLmD,OAAQ,WAEN,IADA3B,IACON,EAAmBvR,eACjBpE,EAAKwS,QAAQmD,EAAmB1J,0CAiBtC3P,GACP,IAAM0D,EAAOxD,KACPkX,EAAavB,EAAqB7V,GACxC,GAAIA,EAAQub,cACV,OACE7X,EAAKyS,iBAAiBiB,IACtB/W,IAAEsB,WACCiB,SACAvB,UAGP,GAAIqC,EAAKwS,QAAQkB,GACf,OAAO1T,EAAKwS,QAAQkB,GAGtB,IAAM1V,EAAWrB,IAAEsB,WAkDnB,OAjDA+B,EAAKwS,QAAQkB,GAAc1V,EAASL,UAE/BuU,EAaHlS,EAAK2S,MACFmF,QAAQpE,GACR3C,KAAK,SAAAgH,GACJ,IAAMlE,EAAakE,EAAaA,EAAWlE,WAAavX,EAAQuX,WAC1DjC,EAAQ,IAAIyE,UAAiB,CACjCvE,YAAa9R,EACboS,UAAW9V,EAAQ8V,UACnB9S,QAAShD,EAAQgD,QACjBjB,KAAM/B,EAAQ+B,KACdwV,WAAYA,IAEVkE,EA5mBK,SAASvE,EAAkBuE,GAC5C,IAAMC,EAAiB,SAASrG,EAAesG,EAAKC,GAzCzB,IA2CvBH,EAAWnE,SACXmE,EAAWpG,MACToG,EAAWpG,GAAe5S,cAC1BvB,KAAKwB,MAAQ+Y,EAAWpG,GAAe5S,aAAekZ,KAExDzE,EAAiB7B,GAAiBoG,EAAWpG,GACzCuG,IACF1E,EAAiB0E,GAAevb,IAAEsB,WAC/BL,QAAQ4V,EAAiB7B,IACzBhU,aAKTqa,EAAe,aAAchX,cAAcyS,SAC3CuE,EAAe,aAAchX,cAAcyS,QAAS,qBACpDuE,EAAe,WAAYhX,cAAcyS,QAAS,mBAClDuE,EAAe,aAAchX,cAAcyS,QAAS,qBACpDuE,EAAe,SAAUhX,cAAcyS,QAAS,iBAChDuE,EAAe,gBAAiBhX,cAAcyS,QAAS,wBACvDuE,EAAe,aAAchX,cAAcmX,UAAW,qBACtDH,EAAe,mBAAoBhX,cAAcmX,WAqlBvCC,CAAWxG,EAAOmG,IACRzb,EAAQ+b,YAAc/b,EAAQuX,YACxCjC,EAAMG,YAER/T,EAASJ,QAAQgU,KAElBsB,MAAM,SAAAvQ,GACL2V,QAAQC,KAAK5V,GACb,IAAMiP,EAAQ,IAAIyE,UAAiB,CACjCvE,YAAa9R,EACboS,UAAW9V,EAAQ8V,UACnB9S,QAAShD,EAAQgD,QACjBjB,KAAM/B,EAAQ+B,KACdwV,WAAYvX,EAAQuX,cAEjBvX,EAAQ+b,YAAc/b,EAAQuX,YACjCjC,EAAMG,YAER/T,EAASJ,QAAQgU,KA1CrB5T,EACGJ,QACC,IAAIyY,UAAiB,CACnBvE,YAAa9R,EACboS,UAAW9V,EAAQ8V,UACnB9S,QAAShD,EAAQgD,QACjBjB,KAAM/B,EAAQ+B,KACdwV,WAAYvX,EAAQuX,cAGvBlW,UAoCEqC,EAAKwS,QAAQkB,8CAYHpX,GACjB,IAAM0D,EAAOxD,KACPkX,EAAavB,EAAqB7V,GACxC,GAAI0D,EAAK0S,kBAAkBgB,GACzB,OAAO1T,EAAK0S,kBAAkBgB,GAGhC,IAAM1V,EAAWrB,IAAEsB,WA+BnB,OA9BA+B,EAAK0S,kBAAkBgB,GAAc1V,EAASL,UAEzCuU,EAOHlS,EAAK8S,gBACFgF,QAAQpE,GACR3C,KAAK,SAAAgH,GACJ,IAAMnG,EAAQ,IAAI4G,UAAgB,CAChC9E,WAAYA,EACZ5B,YAAa9R,EACb7B,MAAO7B,EAAQ6B,QAEb4Z,GAvoBe,SAASU,EAAwBV,GAC5D,IAAMC,EAAiB,SAASrG,EAAesG,EAAKC,GA1EzB,IA4EvBH,EAAWnE,SACXmE,EAAWpG,MACToG,EAAWpG,GAAe5S,cAC1BvB,KAAKwB,MAAQ+Y,EAAWpG,GAAe5S,aAAekZ,KAExDQ,EAAuB9G,GAAiBoG,EAAWpG,GAC/CuG,IACFO,EAAuBP,GAAevb,IAAEsB,WACrCL,QAAQ6a,EAAuB9G,IAC/BhU,aAKTqa,EAAe,UAAWhX,cAAcmX,UAAW,kBACnDH,EAAe,aAAchX,cAAcmX,UAAW,qBACtDH,EAAe,aAAchX,cAAcmX,UAAW,qBACtDH,EAAe,WAAYhX,cAAcmX,UAAW,mBAonB1CO,CAAqB9G,EAAOmG,GAE9B/Z,EAASJ,QAAQgU,KAElBsB,MAAM,SAAAvQ,GACL2V,QAAQC,KAAK5V,GACb3E,EAASJ,QACP,IAAI4a,UAAgB,CAAE9E,WAAYA,EAAY5B,YAAa9R,EAAM7B,MAAO7B,EAAQ6B,WAtBtFH,EACGJ,QACC,IAAI4a,UAAgB,CAAE9E,WAAYA,EAAY5B,YAAa9R,EAAM7B,MAAO7B,EAAQ6B,SAEjFR,UAuBEqC,EAAK0S,kBAAkBgB,kDASTiF,GAErB,IAAKzG,GAAgBlR,cAAcyS,SAAW,GAAKzS,cAAcmX,WAAa,EAC5E,OAAOxb,IAAEsB,WACNL,UACAD,UAEL,IAAMK,EAAWrB,IAAEsB,WAWnB,OAjBazB,KAORsW,gBACFa,QAAQgF,EAAgBjF,WAAY,CACnCE,QAhvBqB,EAivBrBgF,QAASD,EAAgBC,QACzBC,WAAYF,EAAgBE,WAC5BC,WAAYH,EAAgBG,WAC5BC,SAAUJ,EAAgBI,WAE3BhI,KAAK/S,EAASJ,SACdsV,MAAMlV,EAASkB,QACXlB,EAASL,+CAIdqb,EAAqB,IAAIC,UACzBC,EAAsB,GAQtBC,EAAa,SAAS9Z,GAC1B,IAAKA,EACH,MAAM,IAAI+Z,MAAM,wCAElB,OACEF,EAAoB7Z,KACnB6Z,EAAoB7Z,GAAc,IAAIkT,EAAYlT,KAIxCgS,EAAA,SAoBbgI,kBAAmB,SAAS/c,GAC1B,OAAO6c,EAAW7c,EAAQ+C,YAAYga,kBAAkB/c,IAc1DkY,SAAU,SAASlY,GACjB,OAAO6c,EAAW7c,EAAQ+C,YAAYmV,SAASlY,IAYjDgd,mBAAoB,SAAShd,GAC3B,OAAO6c,EAAW7c,EAAQ+C,YAAYia,mBAAmBhd,IAoB3DuY,YAAa,SAASvY,GACpB,IAAM0B,EAAWrB,IAAEsB,WACbuO,EAAsB,GAY5B,OAXA2M,EAAW7c,EAAQ+C,YAChBmV,SAASlY,GACTiH,KAAK,SAAAqO,GACJpF,EAAoB3E,KAClB+J,EACGiD,YAAYvY,GACZiH,KAAKvF,EAASJ,SACd8F,KAAK1F,EAASkB,WAGpBwE,KAAK1F,EAASkB,QACV,IAAIC,UAAmBnB,OAAUiG,EAAWuI,IAQrD2M,WAAYA,EASZI,oBAAqBP,EAAmBO,oBAAoBzU,KAAKkU,GAMjEQ,uBAAwBR,EAAmBQ,uBAAuB1U,KAAKkU,GAEvES,YAAa,WACXvH,GAAe,GAGjBwH,aAAc,WACZxH,GAAe,GAGjBX,iBAAkB8C,UAAa9C;;;;27BC73BjC,IAAMoI,EAAmB,SAASnG,EAAkBlX,GAClD,GAAIkX,EAAiB1B,YAAY8H,kBAAmB,CAClD,IAAM5b,EAAWrB,IAAEsB,WACbuO,EAAsB,GAS5B,OARAgH,EAAiB1B,YAAY8H,kBAAkBzU,OAAO,WACpDqH,EAAoB3E,KAClBwM,UACG5C,aAAa,sBAAuB,aAAc+B,EAAkBlX,GACpEiH,KAAKvF,EAASJ,SACd8F,KAAK1F,EAASkB,WAGdsU,EAAiBiC,eACtB,oBACA,IAAItW,UAAmBnB,OAAUiG,EAAWuI,IAIhD,OAAOgH,EAAiBiC,eACtB,oBACApB,UAAa5C,aAAa,sBAAuB,aAAc+B,EAAkBlX,KAa/Eud,EAAsB,SAASrG,EAAkB3B,GACrD,OAAI2B,EAAiBsG,2BACZtG,EACJiC,eACC,uBACApB,UAAa5C,aACX,yBACA,gBACA+B,EACA3B,IAGHtO,KAAK,SAAAyQ,GACAA,GAAiBR,EAAiBuG,mBACpCvG,EAAiBuG,kBAAkBvG,EAAiBwG,yBAI5DxG,EAAiBsC,qBAAuBnZ,IAAEsB,WAAWiB,SAC9CsU,EAAiBsC,uBAapBmE,EAAiB,SAASzG,EAAkB3B,GAChD,OAAO2B,EAAiBiC,eACtB,kBACApB,UAAa5C,aACXI,GAAcA,EAAWqI,gBAAkB,kBAAoB,gBAC/D,WACA1G,EACA3B,KAcAsI,EAAmB,SAAS3G,EAAkB3B,GAClD,OAAO2B,EAAiBiC,eACtB,oBACApB,UAAa5C,aAAa,kBAAmB,aAAc+B,EAAkB3B,KAa3EuI,EAAe,SAAS5G,EAAkB3B,GAC9C,OAAO2B,EAAiBiC,eACtB,gBACApB,UAAa5C,aAAa,cAAe,SAAU+B,EAAkB3B,KAanEwI,EAAmB,SAAS7G,EAAkB3B,GAClD,OAAI2B,EAAiB1B,YAAYwI,wBACxB9G,EAAiBiC,eACtB,oBACApB,UAAa5C,aAAa,kBAAmB,aAAc+B,EAAkB3B,KAGjF2B,EAAiB+G,kBAAoB5d,IAAEsB,SAASiB,SAASvB,UAClD6V,EAAiB+G,oBAepBC,EAA2B,SAASC,EAAcne,EAASoe,GAC/D,IAAM1c,EAAWrB,IAAEsB,WACnB,IAAKwc,EAAaE,gBAChB,OAAO3c,EAASkB,SAElB,IAAMsN,EAAsB,GAe5B,OAdAiO,EAAa3I,YACVwH,mBAAmB,CAClBlH,UAAWqI,EAAarI,UACxB9S,QAASmb,EAAanb,QACtBnB,MAAO,CAACsc,EAAapc,QAEtBkF,KAAK,SAAAoV,GACJnM,EAAoB3E,KAClB8Q,EAAgB+B,GAAcpe,GAC3BiH,KAAKvF,EAASJ,SACd8F,KAAK1F,EAASkB,WAGpBwE,KAAK1F,EAASkB,QACV,IAAIC,UAAmBnB,OAAUiG,EAAWuI,IAa/C6J,aACJ,SAAAA,EAAY/Z,gGAASkD,CAAAhD,KAAA6Z,GACN7Z,KAER4V,UAAY9V,EAAQ8V,UAFZ5V,KAGR8C,QAAUhD,EAAQgD,QAHV9C,KAIRsV,YAAcxV,EAAQwV,YAJdtV,KAKR6B,KACqB,iBAAjB/B,EAAQ+B,MAAqB/B,EAAQ+B,KACxC/B,EAAQ+B,KAAKuc,MAAM,KACnBte,EAAQ+B,MAAQ,GART7B,KASRiJ,KATQjJ,KASI6B,KAAK+F,OATT5H,KASuB6B,KATvB7B,KASiC6B,KAAK+F,OAAS,GAAK9H,EAAQwV,YAAYzS,WATxE7C,KAUR8Z,YAAcha,EAAQga,YAVd9Z,KAYRqX,WAAavX,EAAQuX,WAZbrX,KAcHqX,aACiB,IAfdrX,KAeF6B,KAAK+F,OAfH5H,KAgBJqX,WAAa,CAAEjU,KAAM,UACI,IAjBrBpD,KAiBK6B,KAAK+F,OAjBV5H,KAkBJqX,WAAa,CAAEjU,KAAM,YACI,IAnBrBpD,KAmBK6B,KAAK+F,SAnBV5H,KAoBJqX,WAAa,CAAEjU,KAAM,WApBjBpD,KAwBRqe,+DAiCL,GA1Bare,KACRse,aAAe,EADPte,KAERqZ,uBAAoB5R,EAFZzH,KAGRsX,gBAAa7P,EAHLzH,KAKRwX,mBAAgB/P,EALRzH,KAMRsZ,0BAAuB7R,EANfzH,KAQRoJ,cAAW3B,EARHzH,KASRwZ,qBAAkB/R,EATVzH,KAWRkP,gBAAazH,EAXLzH,KAYRue,uBAAoB9W,EAZZzH,KAcRuX,YAAS9P,EAdDzH,KAeR4a,mBAAgBnT,EAfRzH,KAiBR0X,sBAAmBjQ,EAjBXzH,KAkBRyX,gBAAahQ,EAlBLzH,KAmBR+d,uBAAoBtW,EAnBZzH,KAqBRwe,qCAAkC/W,EArB1BzH,KAsBRkY,wCAAqCzQ,EAtB7BzH,KAwBRga,qBAAkBvS,EAxBVzH,KA0BJ6B,KAAK+F,OAAQ,CACpB,IAAMqC,EA3BKjK,KA2BSsV,YAAYmJ,cAAc,CAC5C7I,UA5BS5V,KA4BO4V,UAChB9S,QA7BS9C,KA6BK8C,QACdjB,KA9BS7B,KA8BE6B,KAAK0M,MAAM,EA9BbvO,KA8BqB6B,KAAK+F,OAAS,KAE1CqC,IACFA,EAAOuU,qCAAkC/W,EACzCwC,EAAOiO,wCAAqCzQ,2CAWnCiU,EAAagD,GAC1B,IAAMlb,EAAOxD,KAEb,OADAwD,EAAKkY,GAAegD,EACbA,EAAmBxX,KAAK,WACzBwX,EAAmB1K,kBACdxQ,EAAKkY,wCAcP5b,GACT,IAMIsd,EANE5Z,EAAOxD,KAERF,IACHA,EAAU,IAIZ,IAAIkO,EAAalO,EAAQkO,YAAc,QAEpB,UAAfA,GAAmD,WAAzBxK,EAAKmb,iBAC7B3a,OAAO4a,cACT5Q,EAAa,sBAEXxK,EAAK8R,YAAY8H,kBACnBA,EAAoB5Z,EAAK8R,YAAY8H,mBAErCA,EAAoB7b,UAAUsd,yBAAyB,CACrDhc,WAAYW,EAAKmb,gBACjB7b,QAASU,EAAKV,QACdkL,WAAYA,EACZnM,KAAM2B,EAAK3B,KACXS,cAAexC,EAAQwC,gBAEzBkB,EAAK8R,YAAY8H,kBAAoBA,EACrCA,EAAkBzU,OAAO,kBAChBnF,EAAK8R,YAAY8H,sBAI5BA,EAAoBjd,IAAEsB,WACnBL,UACAD,UAGDqC,EAAK6T,YAAc7T,EAAK6T,WAAWe,qBAC9B5U,EAAK6T,WAAWe,aAGzB5U,EAAK6a,QACL,IAAMS,EAAehf,EAAQif,QACzBvb,EAAK8R,YAAY0J,oBAAoBxb,EAAKoS,UAAWpS,EAAKV,QAASU,EAAK3B,MACxE2B,EAAKyb,OAEHC,EAAe/e,IAAEyK,KAAKwS,EAAmB0B,GAS/C,OAPAI,EAAavW,OAAO,WAClBhF,UAAU2B,QAAQ,+BAAgC,CAChD8P,MAAO5R,EACPub,UAAWjf,EAAQif,YAIhB,IAAIpc,UAAmBuc,OAAczX,EAAW,CAAC2V,mCAWxD,OADApZ,OAAOkM,aADMlQ,KACYse,aADZte,KAEDsV,YAAY6J,oBAFXnf,0CASb,IAAMwD,EAAOxD,KACTwE,cAAcyS,QAAU,IAC1BjT,OAAOkM,aAAa1M,EAAK8a,aACzB9a,EAAK8a,YAActa,OAAO6L,WAAW,WACnCrM,EAAKyb,QACJ,0CAeKnf,GACV,IAAM0D,EAAOxD,KACb,GAAIwD,EAAKwW,mBAAqBla,IAAYA,EAAQU,cAChD,OAAOqX,UAAa9C,iBAAiBvR,EAAKwW,gBAAiBla,GAE7D,IAAM0B,EAAWrB,IAAEsB,WAEnB,GAAI3B,GAAWA,EAAQ+b,aAAerY,EAAK8T,aAAe9T,EAAK6V,kBAC7D,OAAO7X,EAASkB,QAAO,GAAOvB,UAGhC,IAAMkY,EAAoB7V,EACvB4b,cAActf,GACdiH,KAAK,SAAAuQ,GACJ,GAAKA,IAAcA,EAAW3I,SAA9B,CAIA,IAAMa,EAAW,GACbuK,EAAQ,EACNsF,EAAgB,GAClB/H,EAAWgI,gBACbhI,EAAWgI,eAAe1d,QAAQ,SAAAqZ,GAChCoE,EAAcpE,EAAahS,OAAQ,IAIvC,IAAMsW,EACJjI,EAAWkI,WACXlI,EAAWmI,aACXnI,EAAWqD,kBACXrD,EAAWvJ,QACXuJ,EAAWoD,QAET6E,GACFA,EAAS3d,QAAQ,SAAAkQ,GACVwF,EAAWkI,WAAyC,sBAA3B1N,EAAO7I,MAAQ6I,IAC3CtC,EAASnE,KACP7H,EAAK8R,YACF0C,SAAS,CACRpC,UAAWpS,EAAKoS,UAChB9S,QAASU,EAAKV,QACdjB,KAAM2B,EAAK3B,KAAK8F,OAAOmK,EAAO7I,MAAQ6I,KAEvC/K,KAAK,SAAAkX,GACJ,IACGA,EAAa5G,iBAC2B,IAAlC4G,EAAa5G,WAAW0C,MAC/B,CACA,IAAM1C,EAA+B,WAAlBqI,EAAO5N,GAAsBA,EAAS,GACnC,WAAlB4N,EAAO5N,KACgB,IAArBtO,EAAK3B,KAAK+F,OACZyP,EAAWjU,KAAO,WACY,IAArBI,EAAK3B,KAAK+F,OACnByP,EAAWjU,KAAO,QACY,IAArBI,EAAK3B,KAAK+F,SACnByP,EAAWjU,KAAO,WAGlBkU,EAAWgI,iBACbjI,EAAW4D,eAAiBoE,EAAcvN,EAAO7I,OAEnDoO,EAAW0C,MAAQA,IACnBkE,EAAa5G,WAAaA,EAC1B4G,EAAa1I,kBAQC,WAAzB/R,EAAKmb,iBAAyD,SAAzBnb,EAAKmb,kBAC3Cnb,EAAKmc,cAEgB,QAApBrI,EAAWlU,KAAiB,CAAC,MAAO,SAAW,CAAC,SAASxB,QAAQ,SAAAC,GAC5DyV,EAAWzV,IACb2N,EAASnE,KACP7H,EAAK8R,YACF0C,SAAS,CACRpC,UAAWpS,EAAKoS,UAChB9S,QAASU,EAAKV,QACdjB,KAAM2B,EAAK3B,KAAK8F,OAAO9F,KAExBkF,KAAK,SAAAkX,GACJ,IACGA,EAAa5G,iBAC2B,IAAlC4G,EAAa5G,WAAW0C,MAC/B,CACA,IAAM1C,EAAaC,EAAWzV,GAC9BwV,EAAW0C,MAAQA,IACnB1C,EAAWuI,WAAsB,UAAT/d,EACxBoc,EAAa5G,WAAaA,EAC1B4G,EAAa1I,kBAO3BpV,IAAEyK,KAAK4J,MAAMrU,IAAGqP,GAAUzI,KAAK,WAC7BvF,EAASJ,QAAQye,MAAMzZ,UAAUmI,MAAMjI,KAAK0E,mBAtF5CxJ,EAASkB,WAyFZwE,KAAK1F,EAASkB,QAEjB,OAAOmV,UAAa9C,iBAClBvR,EAAKyV,eACH,kBACA,IAAItW,UAAmBnB,OAAUiG,EAAW,CAAC4R,KAE/CvZ,wDAcyBA,GAC3B,IAAM0D,EAAOxD,KAIb,GAFAF,EAAU+X,UAAarC,kBAAkB1V,IAEpC0D,EAAK8Z,4BAA8B9Z,EAAKsc,UAC3C,OAAO3f,IAAEsB,WACNiB,SACAvB,UAGL,GAAIqC,EAAKgb,mCAAqC1e,IAAYA,EAAQU,cAChE,OAAOqX,UAAa9C,iBAAiBvR,EAAKgb,gCAAiC1e,GAG7E,IAAM0B,EAAWrB,IAAEsB,WAEbuO,EAAsB,GA8E5B,OA5EAA,EAAoB3E,KAClB7H,EACG6U,YAAYvY,GACZiH,KAAK,SAAAgZ,GAIJ,IAHwBA,EAASC,KAAK,SAAAzH,GACpC,OAAOA,EAAWf,iBAEK1X,GAAYA,EAAQU,aAA7C,CAKA,IAAImJ,EAGFA,EADEnG,EAAK3B,KAAK+F,OACJ,gBAAkBpE,EAAK3B,KAAKC,KAAK,KAAO,gCAExC,gBAGV,IAAMme,EAAgB,WACpBF,EAASne,QAAQ,SAAA2W,GACVA,EAAWf,gBACde,EAAWf,cAAgB,GAC3Be,EAAWe,qBAAuBnZ,IAAEsB,WACjCiB,SACAvB,cAKT6O,EAAoB3E,KAClB9J,UACG2e,eAAe,CACdvW,MAAOA,EACPqJ,UAAU,EACVxG,MAAOuT,EAASnY,OAChBtF,cAAexC,GAAWA,EAAQwC,gBAEnCyE,KAAK,SAAA1D,GACJ,GAAIA,GAAUA,EAAOkc,SAAU,CAC7B,IAAMY,EAAkB,GACxBJ,EAASne,QAAQ,SAAA2W,GACf4H,EAAgB5H,EAAWtP,KAAKmX,eAAiB7H,IAGnDlV,EAAOkc,SAAS3d,QAAQ,SAAAkQ,GACtB,IAAMuO,EACJF,GAAiBrO,EAAOwO,eAAiBxO,EAAOyO,cAAcH,eAC5DC,IACFA,EAAmB7I,cAAgB1F,EACnCA,EAAOvP,aAAevB,KAAKwB,MAC3B6d,EAAmB/G,qBAAuBnZ,IAAEsB,WACzCL,QAAQif,EAAmB7I,eAC3BrW,UACC2Q,GAAUuO,EAAmB9C,mBAC/B8C,EAAmB9C,kBACjB8C,EAAmB7C,sBAGvB6C,EAAmB9K,eAIzB0K,IACAze,EAASJ,QAAQ2e,KAElB7Y,KAAK,WACJ+Y,IACAze,EAASkB,iBA7DblB,EAASJ,QAAQ2e,KAiEpB7Y,KAAK1F,EAASkB,SAGZmV,UAAa9C,iBAClBvR,EAAKyV,eACH,kCACA,IAAItW,UAAmBnB,EAAU,KAAMwO,IAEzClQ,yDAa0BiD,EAAUjD,GACtC,IAAM0D,EAAOxD,KACPwB,EAAWrB,IAAEsB,WACd+B,EAAK6T,aACR7T,EAAK6T,WAAa,IAEpB7T,EAAK6T,WAAWe,cAAe,EAC/B5U,EAAK+R,YAEL,IAAMiL,EAAehd,EAClB6U,YAAYvY,GACZiH,KAAK,SAAAuR,GACJ,IAAMmI,EAAgB,GACtBnI,EAAa1W,QAAQ,SAAA2W,GACnBkI,EAAclI,EAAWtP,KAAKmX,eAAiB7H,IAEjD,IAAMmI,EAAe,GAErB,GAAIld,EAAKmd,cAAgB5d,EAAS6d,WAChC7d,EAAS6d,WAAWhf,QAAQ,SAAAif,GAC1B,IAAMC,EAAgBL,EAAcI,EAAS5X,KAAKmX,eAC9CU,IACFA,EAAcpJ,iBAAmBmJ,EACjCC,EAAcvL,YACdmL,EAAaI,EAAcC,oBAAsBD,UAGhD,GAAItd,EAAK2a,iBAAmBpb,EAASkI,OAAQ,CAClD,IAAM+V,EAAsB,SAAStG,EAAStX,GACxCsX,GACFA,EAAQ9Y,QAAQ,SAAAmN,GACd,IAAM+R,EAAgBL,EAAc1R,EAAOkS,WAAWb,eAClDU,IACGA,EAAcpJ,mBACjBoJ,EAAcpJ,iBAAmB,IAEnCoJ,EAAcpJ,iBAAiBtU,GAAQ2L,EACvC+R,EAAcvL,YACdmL,EAAaI,EAAcC,oBAAsBD,MAMzDE,EAAoBje,EAASkI,OAAOiW,cAAe,gBACnDF,EAAoBje,EAASkI,OAAOkW,eAAgB,iBACpDH,EAAoBje,EAASkI,OAAOmW,YAAa,cACjDJ,EAAoBje,EAASkI,OAAOoW,eAAgB,iBACpDL,EAAoBje,EAASkI,OAAOqW,cAAe,gBAErD,IAAM3J,EAAiB,GACvBzV,OAAOC,KAAKue,GAAc9e,QAAQ,SAAAC,GAChC8V,EAAetM,KAAKqV,EAAa7e,MAEnCL,EAASJ,QAAQuW,KAElBzQ,KAAK1F,EAASkB,QAEjB,OAAO,IAAIC,UAAmBnB,OAAUiG,EAAW,CAAC+Y,4DAatB1gB,GAC9B,IAAM0D,EAAOxD,KAIb,GAFAF,EAAU+X,UAAarC,kBAAkB1V,IAEpC0D,EAAK8R,YAAYwI,wBACpB,OAAO3d,IAAEsB,WACNiB,SACAvB,UAEL,GAAIqC,EAAK0U,sCAAwCpY,IAAYA,EAAQU,cACnE,OAAOqX,UAAa9C,iBAAiBvR,EAAK0U,mCAAoCpY,GAEhF,IAAM0B,EAAWrB,IAAEsB,WACbuO,EAAsB,GAoC5B,OAnCIxM,EAAK6T,aAAc7T,EAAK6T,WAAWe,cAAkBtY,GAAYA,EAAQU,aAalEgD,EAAKmd,cAAgBnd,EAAK2a,gBACnCnO,EAAoB3E,KAClB9J,UACGkX,sBAAsB,CACrBnW,cAAexC,GAAWA,EAAQwC,cAClC9B,aAAcV,GAAWA,EAAQU,aACjCmB,MAAO,CAAC6B,EAAK3B,QAEdkF,KAAK,SAAAhG,GACJiP,EAAoB3E,KAClB7H,EACG0V,8BAA8BnY,EAAMjB,GACpCiH,KAAKvF,EAASJ,SACd8F,KAAK1F,EAASkB,WAGpBwE,KAAK1F,EAASkB,SAGnBlB,EAASJ,QAAQ,IA/BjB4O,EAAoB3E,KAClB7H,EACG6U,YAAYvY,GACZiH,KAAK,SAAAuR,GACJ9W,EAASJ,QACPkX,EAAajQ,OAAO,SAAA+M,GAClB,OAAOA,EAAMsC,sBAIlBxQ,KAAK1F,EAASkB,SAwBdmV,UAAa9C,iBAClBvR,EAAKyV,eACH,qCACA,IAAItW,UAAmBnB,OAAUiG,EAAWuI,IAE9ClQ,sDAWF,OACEkE,OAAOud,cACmB,SAHfvhB,KAGL2e,iBAAuD,WAHlD3e,KAG8B2e,mBAH9B3e,KAIL2gB,cAJK3gB,KAIgBme,iBAJhBne,KAIwCwhB,yDAWrD,OADaxhB,KAENwX,eACqB,SAHfxX,KAGL2e,iBAAuD,WAHlD3e,KAG8B2e,gBAH9B3e,KAOAsX,YAPAtX,KAOmBsX,WAAWzI,SAAY,GAP1C7O,KAKCwX,cAAciK,aALfzhB,KAKmCwX,cAAckK,qBAAuB,kDAgBrF,OAJa1hB,KACHud,oBADGvd,KAENud,kBAAoBxb,IAAGkD,WAFjBjF,KAEiCwd,uBAFjCxd,KAIDud,+DAUZ,OADavd,KACJsd,gCAC8B,IAF1Btd,KAEQwX,mBAEa,IAJrBxX,KAIMsX,8CAcVxX,GACT,IAAM0D,EAAOxD,KACPwB,EAAWrB,IAAEsB,WACbuO,EAAsB,GAEtB2R,EAAwB,WACxBne,EAAK8T,WACP9V,EAASJ,QAAQoC,EAAK8T,WAAWzI,SAAW,IACnCrL,EAAK6T,iBAAiD,IAA5B7T,EAAK6T,WAAWxI,QACnDrN,EAASJ,QAAQoC,EAAK6T,WAAWxI,SAEjCmB,EAAoB3E,KAClB7H,EACG4b,cAActf,GACdiH,KAAK,SAAAuQ,GACJ9V,EAASJ,QAASkW,GAAcA,EAAWzI,SAAY,MAExD3H,KAAK1F,EAASkB,UAsCvB,OAjCIc,EAAK8Z,2BACH9Z,EAAK8V,qBACP9V,EAAK8V,qBACFvS,KAAK,WACJvF,EAASJ,QACPoC,EAAKgU,cAAciK,aAAeje,EAAKgU,cAAckK,qBAAuB,MAG/Exa,KAAKya,GACCne,EAAKgU,cACdhW,EAASJ,QACPoC,EAAKgU,cAAciK,aAAeje,EAAKgU,cAAckK,qBAAuB,IAG9E1R,EAAoB3E,KAClB7H,EACGoe,iBAAiB9hB,GACjBiH,KAAK,SAAAyQ,GACAA,EACFhW,EAASJ,QACPoW,EAAciK,aAAejK,EAAckK,qBAAuB,IAGpEC,MAGHza,KAAKya,IAIZA,IAGK9J,UAAa9C,iBAClB,IAAIpS,UAAmBnB,OAAUiG,EAAWuI,GAC5ClQ,yDAc0BkS,EAAwBC,EAA2BoD,GAC/E,IAAM7R,EAAOxD,KACPwB,EAAWrB,IAAEsB,WA0CnB,OAxCI+B,EAAK8Z,6BAEL9Z,EAAKgU,gBAAkB,IACtBhU,EAAKgU,oBAAwD,IAAhChU,EAAKgU,cAAczF,YAE5CsD,IACHA,EAAa,IAEfA,EAAW7U,cAAe,GAE5BgD,EACGoe,iBAAiBvM,GACjBtO,KAAK,SAAAyQ,GACAA,GACFjW,UACGsgB,0BAA0B,CACzB9P,SAAUyF,EAAczF,SACxBC,uBAAwBA,EACxBC,0BAA2BA,IAE5BlL,KAAK,SAAA+K,GACAA,GACFtO,EAAKgU,cAAgB1F,EACrBtO,EAAK8V,qBAAuBnZ,IAAEsB,WAC3BL,QAAQoC,EAAKgU,eACbrW,UACHqC,EAAK+R,YACL/T,EAASJ,QAAQoC,EAAKgU,gBAEtBhW,EAASkB,WAGZwE,KAAK1F,EAASkB,UAGpBwE,KAAK1F,EAASkB,SAEjBlB,EAASkB,SAGJlB,EAASL,6CAaP0N,EAASwG,GAClB,IAAM7R,EAAOxD,KACPwB,EAAWrB,IAAEsB,WA8DnB,OA5DI+B,EAAK8Z,6BAEL9Z,EAAKgU,gBAAkB,IACtBhU,EAAKgU,oBAAwD,IAAhChU,EAAKgU,cAAczF,YAE5CsD,IACHA,EAAa,IAEfA,EAAW7U,cAAe,GAE5BgD,EACGoe,iBAAiBvM,GACjBtO,KAAK,SAAAyQ,GACAA,GACFjW,UACGsgB,0BAA0B,CACzB9P,SAAUyF,EAAczF,SACxBpG,WAAY,CACV8V,YAAa5S,KAGhB9H,KAAK,SAAA+K,GACAA,IACFtO,EAAKgU,cAAgB1F,EACrBtO,EAAK8V,qBAAuBnZ,IAAEsB,WAC3BL,QAAQoC,EAAKgU,eACbrW,UACHqC,EAAK+R,aAEP/R,EAAKse,WAAWzM,GAAYtO,KAAK,SAAA8H,GAC3BrL,EAAK+Z,mBAAqB/Z,EAAK+Z,sBAAwB1O,GACzDrL,EAAK+Z,kBAAkB1O,GAEzBrN,EAASJ,QAAQyN,OAGpB3H,KAAK1F,EAASkB,UAGpBwE,KAAK1F,EAASkB,SAEjBnB,UACGwgB,qBAAqB,CACpBlf,WAAYW,EAAKmb,gBACjB9c,KAAM2B,EAAK3B,KACX8J,WAAY,CACVkD,QAASA,KAGZ9H,KAAK,WACJoW,EAAiB3Z,EAAM,CACrBlB,cAAe+S,GAAcA,EAAW/S,cACxC9B,cAAc,IACbuG,KAAK,WACNvD,EAAKse,WAAWzM,GAAYtO,KAAKvF,EAASJ,aAG7C8F,KAAK1F,EAASkB,QAGZlB,EAASL,mDAUD+Q,GACf,IAAM1O,EAAOxD,KACPwB,EAAWrB,IAAEsB,WA6BnB,OA5BI+B,EAAK8Z,2BACP9Z,EACGoe,mBACA7a,KAAK,SAAAib,GACAA,QAAuC,IAArBA,EAAQjQ,SAC5BxQ,UACG0gB,WAAWD,EAAQjQ,SAAUG,GAC7BnL,KAAK,SAAA+K,GACAA,GACFtO,EAAKgU,cAAgB1F,EACrBtO,EAAK8V,qBAAuBnZ,IAAEsB,WAC3BL,QAAQoC,EAAKgU,eACbrW,UACHqC,EAAK+R,aAEL/T,EAASkB,SAEXlB,EAASJ,QAAQoC,EAAKgU,iBAEvBtQ,KAAK1F,EAASkB,QAEjBlB,EAASkB,WAGZwE,KAAK1F,EAASkB,QAEjBlB,EAASkB,SAEJlB,EAASL,sDAUE+Q,GAClB,IAAM1O,EAAOxD,KACPwB,EAAWrB,IAAEsB,WA6BnB,OA5BI+B,EAAK8Z,2BACP9Z,EACGoe,mBACA7a,KAAK,SAAAib,GACAA,QAAuC,IAArBA,EAAQjQ,SAC5BxQ,UACG2gB,cAAcF,EAAQjQ,SAAUG,GAChCnL,KAAK,SAAA+K,GACAA,GACFtO,EAAKgU,cAAgB1F,EACrBtO,EAAK8V,qBAAuBnZ,IAAEsB,WAC3BL,QAAQoC,EAAKgU,eACbrW,UACHqC,EAAK+R,aAEL/T,EAASkB,SAEXlB,EAASJ,QAAQoC,EAAKgU,iBAEvBtQ,KAAK1F,EAASkB,QAEjBlB,EAASkB,WAGZwE,KAAK1F,EAASkB,QAEjBlB,EAASkB,SAEJlB,EAASL,wDAUhB,OADanB,KAEN6B,KAAK+F,OAAS,IAFR5H,KAGJqX,aAHIrX,KAGgBsX,YAHhBtX,KAILsX,YAAc,yBAAyB6K,KAJlCniB,KAI4CsX,WAAWlU,OAJvDpD,KAKLqX,YAAc,yBAAyB8K,KALlCniB,KAK4CqX,WAAWjU,yCAWpE,OADapD,KACDqX,YADCrX,KACkBqX,WAAW0C,MAD7B/Z,KAC0CqX,WAAW0C,MAAQ,0CAU1E,OADa/Z,KACDsV,YAAYzS,8CAUxB,OAA4B,IADf7C,KACD6B,KAAK+F,4CAUjB,OAA4B,IADf5H,KACD6B,KAAK+F,+CAUjB,OAA4B,IADf5H,KACD6B,KAAK+F,wCAUVwa,GACP,IACIC,EADSriB,KACI+gB,mBACjB,GAFa/gB,KAEJ8f,UAAW,CAClB,IAAM1c,EAHKpD,KAGOsiB,UACdlf,IACFif,GAAS,KAAOjf,EAAO,KAM3B,OAHIgf,GARSpiB,KAQcuiB,sBARdviB,KAQ2Cwd,uBACtD6E,GAAS,MATEriB,KASWwd,sBAEjB6E,6CAUP,OADariB,KACD6B,KAAKC,KAAK,4CAST0gB,GACb,IACIC,EAAcD,EADLxiB,KACsB+gB,mBADtB/gB,KACgDiJ,KAC7D,GAFajJ,KAEJ8f,UAAW,CAClB,IAAM1c,EAHKpD,KAGOsiB,UACdlf,IACFqf,GAAe,KAAOrf,EAAO,KAGjC,OAAOqf,yCAWP,OADaziB,KACDwhB,YADCxhB,KACkBqX,YAAc,QAAQ8K,KADxCniB,KACkDqX,WAAWqL,sDAW1E,OADa1iB,KACDqX,cADCrX,KACoBqX,WAAW4D,+CAU5C,OAAyB,IADZjb,KACJ6B,KAAK+F,WADD5H,KAGJoJ,UAHIpJ,KAIJoJ,SAASgJ,SAJLpS,KAKJoJ,SAASgJ,QAAQzG,YAC0B,iBANvC3L,KAMJoJ,SAASgJ,QAAQzG,WAAWgX,cANxB3iB,KAUFsX,YAVEtX,KAWIsX,WAAWiC,SAXfvZ,KAaFqX,aAbErX,KAaiBqX,WAAWjU,MACS,UAdrCpD,KAcGqX,WAAWjU,KAAKgd,iDAchC,OACuB,IAFVpgB,KAEN6B,KAAK+F,SAFC5H,KAGJsX,YAHItX,KAGesX,WAAWiC,SAH1BvZ,KAIHqX,YAJGrX,KAKFqX,WAAWjU,MACuB,SANhCpD,KAMFqX,WAAWjU,KAAKgd,eANdpgB,KAOHoJ,UAPGpJ,KAQFoJ,SAASgJ,SARPpS,KASFoJ,SAASgJ,QAAQzG,YAC0B,iBAVzC3L,KAUFoJ,SAASgJ,QAAQzG,WAAWgX,+CAWvC,OAA4B,IADf3iB,KACD6B,KAAK+F,2CAWjB,OADa5H,KAEN6B,KAAK+F,OAAS,IAFR5H,KAGJsX,YAAc,yBAAyB6K,KAHnCniB,KAG6CsX,WAAWlU,OAHxDpD,KAIHqX,YAAc,yBAAyB8K,KAJpCniB,KAI8CqX,WAAWjU,yCAWtE,OADapD,KACD6B,KAAK+F,OAAS,oCAW1B,OADa5H,KAELsX,YAAc,UAAU6K,KAFnBniB,KAE6BsX,WAAWlU,OAFxCpD,KAGLqX,YAAc,UAAU8K,KAHnBniB,KAG6BqX,WAAWjU,sCAYrD,OADapD,KAELsX,YAAc,QAAQ6K,KAFjBniB,KAE2BsX,WAAWlU,OAFtCpD,KAGLqX,YAAc,QAAQ8K,KAHjBniB,KAG2BqX,WAAWjU,2CAYnD,OADapD,KACDqX,YADCrX,KACkBqX,WAAWuI,6CAa1C,IACIxc,EADSpD,KACG4iB,aAIhB,OAH2B,IAAvBxf,EAAKiB,QAAQ,OACfjB,EAAOA,EAAKyf,UAAU,EAAGzf,EAAKiB,QAAQ,OAEjCjB,EAAKgd,mDAaZ,OADapgB,KACAsX,YADAtX,KACmBsX,WAAWlU,MAD9BpD,KAC4CqX,WAAWjU,MAAQ,yCAchEtD,GAEZ,OAAIA,GAAWA,EAAQ+b,WAEnBhE,UAAa9C,iBAHJ/U,KAG0BqZ,kBAAmBvZ,IACtDK,IAAEsB,WACCiB,QAAO,GACPvB,UAGHrB,GAAWA,EAAQU,aACdqX,UAAa9C,iBAAiBoI,EAV1Bnd,KAUiDF,IAEvD+X,UAAa9C,iBAZP/U,KAaNqZ,mBAAqB8D,EAbfnd,KAasCF,GACjDA,uCAgBQA,GAEV,OAAIA,GAAWA,EAAQ+b,WAEnBhE,UAAa9C,iBAHJ/U,KAG0BwZ,gBAAiB1Z,IACpDK,IAAEsB,WACCiB,QAAO,GACPvB,UAGHrB,IAAYA,EAAQU,cAAgBV,EAAQ4d,iBACvC7F,UAAa9C,iBAAiB0I,EAV1Bzd,KAU+CF,GAAUA,GAE/D+X,UAAa9C,iBAZP/U,KAaNwZ,iBAAmBiE,EAbbzd,KAakCF,GAC7CA,yCAeUA,GAEZ,OADaE,KACHme,gBAKNre,GAAWA,EAAQ+b,WAEnBhE,UAAa9C,iBARJ/U,KAQ0Bue,kBAAmBze,IACtDK,IAAEsB,WACCiB,QAAO,GACPvB,UAGHrB,GAAWA,EAAQU,aACdqX,UAAa9C,iBAAiB4I,EAf1B3d,KAeiDF,GAAUA,GAEjE+X,UAAa9C,iBAjBP/U,KAkBNue,mBAAqBZ,EAlBf3d,KAkBsCF,GACjDA,GAjBOK,IAAEsB,WACNiB,QAAO,GACPvB,mDA8BUrB,GAKf,OAFAA,EAAU+X,UAAarC,kBAAkB1V,GAF5BE,KAIHsd,2BAKNxd,GAAWA,EAAQ+b,WAEnBhE,UAAa9C,iBAXJ/U,KAW0BsZ,qBAAsBxZ,IACzDK,IAAEsB,WACCiB,QAAO,GACPvB,UAGHrB,GAAWA,EAAQU,aACdqX,UAAa9C,iBAAiBsI,EAlB1Brd,KAkBoDF,GAAUA,GAEpE+X,UAAa9C,iBApBP/U,KAqBNsZ,sBAAwB+D,EArBlBrd,KAqB4CF,GACvDA,GAjBOK,IAAEsB,WACNiB,SACAvB,gDA8BOrB,GAKZ,OAFAA,EAAU+X,UAAarC,kBAAkB1V,GAF5BE,KAIHsV,YAAYwI,yBAJT9d,KAI0Cme,gBAKnDre,GAAWA,EAAQ+b,WAEnBhE,UAAa9C,iBAXJ/U,KAW0B+d,kBAAmBje,IACtDK,IAAEsB,WACCiB,QAAO,GACPvB,UAGHrB,GAAWA,EAAQU,aACdqX,UAAa9C,iBAAiB8I,EAlB1B7d,KAkBiDF,GAAUA,GAEjE+X,UAAa9C,iBApBP/U,KAqBN+d,mBAAqBF,EArBf7d,KAqBsCF,GACjDA,GAjBOK,IAAEsB,WACNiB,SACAvB,4CAgCGrB,GACR,IAAM0D,EAAOxD,KAGb,GAAIF,GAAWA,EAAQuR,WAAmC,YAAtBvR,EAAQuR,UAC1C,OAAOwG,UAAa9C,iBAClBxT,UAAUuhB,YAAY,CACpBjgB,WAAYW,EAAK8R,YAAYzS,WAC7BC,QAASU,EAAKV,QACdjB,KAAM2B,EAAK3B,KACXS,cAAexC,GAAWA,EAAQwC,cAClC+O,UAAWvR,EAAQuR,YAErBvR,GAKJ,IAAK0D,EAAKoX,eAAiBpX,EAAKge,WAAY,CAC1C,IAAMhgB,EAAWrB,IAAEsB,WACbuO,EAAsB,GAEtB+S,EAAmB,WACnBjjB,GAAWA,EAAQ+b,WACrBra,EAASkB,SAETsN,EAAoB3E,KAClBwM,UACG9C,iBAAiB6I,EAAapa,EAAM1D,GAAUA,GAC9CiH,KAAKvF,EAASJ,SACd8F,KAAK1F,EAASkB,UAoDvB,OA/CAc,EAAK8R,YACF0C,SAAS,CACRpC,UAAWpS,EAAKoS,UAChB9S,QAASU,EAAKV,QACdjB,KAAM2B,EAAK3B,KAAK0M,MAAM,EAAG,GACzB8I,WAAY,CAAEjU,KAAM,WAErB2D,KAAK,SAAAkR,GACAA,GAAcA,EAAW2C,eAC3B5K,EAAoB3E,KAClBwM,UAAa9C,iBAAiBkD,EAAW2C,cAAe9a,IAG1DmY,EAAW2C,cACR7T,KAAK,SAAAic,GACJ,IAAMC,EAAY,CAChB1gB,aAAcygB,EAAazgB,aAC3B2gB,SAAUF,EAAaE,SACvB9f,KAAM4f,EAAa5f,KACnBrC,KAAM,GACNyQ,KAAM,IAER,GAAIwR,EAAaxR,KACf,IADqB,IAAA2R,EAAA,SACZjY,GACP,GAAI8X,EAAaxR,KAAKtG,GAAGjC,KAAKmX,gBAAkB5c,EAAKyF,KAAKmX,cAKxD,OAJA6C,EAAUzR,KAAK,GAAKwR,EAAaxR,KAAKtG,GACtC8X,EAAajiB,KAAKa,QAAQ,SAAAwhB,GACxBH,EAAUliB,KAAKsK,KAAK,CAAC+X,EAAUlY,OAEjC,SANKA,EAAI,EAAGA,EAAI8X,EAAaxR,KAAK5J,OAAQsD,IAAK,cAAAiY,EAA1CjY,GAML,MAIF+X,EAAUzR,KAAK5J,QACjBpE,EAAK+T,OAAS0L,EACdzhB,EAASJ,QAAQoC,EAAK+T,SAEtBwL,MAGH7b,KAAK6b,IAERA,MAGH7b,KAAK6b,GAEDlL,UAAa9C,iBAClBvR,EAAKyV,eACH,gBACA,IAAItW,UAAmBnB,OAAUiG,EAAWuI,IAE9ClQ,GAIJ,OAAIA,GAAWA,EAAQ+b,WAEnBhE,UAAa9C,iBAAiBvR,EAAKoX,cAAe9a,IAClDK,IAAEsB,WACCiB,QAAO,GACPvB,UAGHrB,GAAWA,EAAQU,aACdqX,UAAa9C,iBAAiB6I,EAAapa,EAAM1D,GAAUA,GAE7D+X,UAAa9C,iBAClBvR,EAAKoX,eAAiBgD,EAAapa,EAAM1D,GACzCA,sCAeOA,GAET,OAAOke,EADMhe,KACyBF,EAAS,oDAcnCA,GAEZ,OAAOke,EADMhe,KACyBF,EAAS,qDAcrCA,GAEV,OAAOke,EADMhe,KACyBF,EAAS,oDAIpC+Z;;;;8cCtrDf,IAAMpE,EAAkBzR,OAAOS,gBAGzBgY,aACJ,SAAAA,iGAAczZ,CAAAhD,KAAAyc,GACCzc,KACRmW,MAAQC,IAAYC,eAAe,CACtCpN,KAAM,kBAAoBwM,IAFfzV,KAKRqjB,6BAA0B5b,qEAUb3H,GAClB,IAAM0D,EAAOxD,KACb,GAAIwD,EAAK6f,2BAA6BvjB,IAAYA,EAAQU,cACxD,OAAOgD,EAAK6f,wBAGd,IAAM7hB,EAAWrB,IAAEsB,WAEnB,IAAKuC,OAAOud,YACV,OAAO/f,EAASkB,SAASvB,UAG3BqC,EAAK6f,wBAA0B7hB,EAASL,UAExC,IAAMmiB,EAAgB,WACpB/hB,UACGgiB,sBAAsB,CACrBjhB,cAAexC,GAAWA,EAAQwC,gBAEnCyE,KAAKvF,EAASJ,SACd8F,KAAK1F,EAASkB,QAEbsB,OAAOQ,cAAcyS,QAAU,GACjCzV,EAASuF,KAAK,SAAAyc,GACZhgB,EAAK2S,MAAMgB,QAAQ,6BAA8B,CAC/CqM,QAASA,EACTjhB,aAAcvB,KAAKwB,MACnB4U,QA9CiB,OAwEzB,QApBIpT,OAAOQ,cAAcyS,QAAU,IAAOnX,GAAYA,EAAQU,aAiB5D8iB,IAhBA9f,EAAK2S,MACFmF,QAAQ,8BACR/G,KAAK,SAAAgH,GAEFA,GAzDiB,IA0DjBA,EAAWnE,WACTmE,EAAWhZ,cACXvB,KAAKwB,MAAQ+Y,EAAWhZ,aAAeiC,cAAcyS,SAEvDzV,EAASJ,QAAQma,EAAWiI,SAE5BF,MAGH5M,MAAM4M,GAKJ9f,EAAK6f,uEAOSI,EAAWC,GAChC,IAAMlgB,EAAOxD,KACTwD,EAAK6f,yBACP7f,EAAK6f,wBAAwBtc,KAAK,SAAAyc,GAChCC,EAAU7hB,QAAQ,SAAA+hB,GACXH,EAAQG,KACXH,EAAQG,GAAU,GAEpBH,EAAQG,OAEVD,EAAa9hB,QAAQ,SAAAgiB,GACdJ,EAAQI,KACXJ,EAAQI,KACoB,IAAxBJ,EAAQI,WACHJ,EAAQI,MAIrBpgB,EAAK2S,MAAMgB,QAAQ,6BAA8B,CAC/CqM,QAASA,EACTjhB,aAAcvB,KAAKwB,MACnB4U,QApGmB,2CA2GdqF;;;;kYClGf,IAAMoH,EAAsB,SAC1B1H,EACArc,EACAgkB,EACAC,EACA7O,GAEA,OAAIiH,EAAgB7G,YAAYwI,wBACvB3B,EAAgBlD,eACrB6K,EACAjM,UAAa5C,aAAaC,EAAmB6O,EAAe5H,EAAiBrc,KAGjFqc,EAAgB2H,GAAoB3jB,IAAEsB,WAAWiB,SAC1CyZ,EAAgB2H,KAiBnBE,EAAmB,SACvB7H,EACArc,EACAgkB,EACAC,EACA7O,GAEA,OAAIpV,GAAWA,EAAQ+b,WAEnBhE,UAAa9C,iBAAiBoH,EAAgB2H,GAAmBhkB,IACjEK,IAAEsB,WACCiB,QAAO,GACPvB,UAGHrB,GAAWA,EAAQU,aACdqX,UAAa9C,iBAClB8O,EACE1H,EACArc,EACAgkB,EACAC,EACA7O,GAEFpV,GAGG+X,UAAa9C,iBAClBoH,EAAgB2H,IACdD,EACE1H,EACArc,EACAgkB,EACAC,EACA7O,GAEJpV,IAIEkc,aASJ,SAAAA,EAAYlc,gGAASkD,CAAAhD,KAAAgc,GACNhc,KACRkX,WAAapX,EAAQoX,WADblX,KAERsV,YAAcxV,EAAQwV,YAFdtV,KAGR2B,MAAQ7B,EAAQ6B,MAHR3B,KAKRoc,aAAU3U,EALFzH,KAMRikB,oBAAiBxc,EANTzH,KAQRqc,gBAAa5U,EARLzH,KASRkkB,uBAAoBzc,EATZzH,KAWRsc,gBAAa7U,EAXLzH,KAYRmkB,uBAAoB1c,EAZZzH,KAcRuc,cAAW9U,EAdHzH,KAeRokB,qBAAkB3c,wDAWvB,OADAzD,OAAOkM,aADMlQ,KACYse,aADZte,KAEDsV,YAAY+O,uBAFXrkB,0CASb,IAAMwD,EAAOxD,KACTwE,cAAcyS,QAAU,IAC1BjT,OAAOkM,aAAa1M,EAAK8a,aACzB9a,EAAK8a,YAActa,OAAO6L,WAAW,WACnCrM,EAAKyb,QACJ,6CASQvD,EAAagD,GAC1B,IAAMlb,EAAOxD,KAEb,OADAwD,EAAKkY,GAAegD,EACbA,EAAmBxX,KAAK,WACzBwX,EAAmB1K,kBACdxQ,EAAKkY,wCAgBP5b,GAET,OAAOkkB,EADMhkB,KACiBF,EAAS,iBAAkB,UAAW,4DAcxDA,GAEZ,OAAOkkB,EADMhkB,KAGXF,EACA,oBACA,aACA,+DAeUA,GAEZ,OAAOkkB,EADMhkB,KAGXF,EACA,oBACA,aACA,6DAeQA,GAEV,OAAOkkB,EADMhkB,KACiBF,EAAS,kBAAmB,WAAY,4DAI3Dkc;;;;6DCtPfrH,EAAAC,EAAAC,GAAA,IAAAyP,EAAA3P,eAAA,wCAAA4P,EAAA5P,EAAA6P,EAAAF,GAAAG,EAAA9P,kCAAA,2DAAA+P,EAAA/P,+BAAA,wDAqBMgQ,EAAuB,CAC3BC,KAAK,EACLC,OAAO,EACPC,KAAK,EACLC,OAAO,EACPC,IAAI,EACJC,eAAe,EACfC,SAAS,EACTC,QAAQ,EACRC,QAAQ,EACRC,SAAS,EACTC,MAAM,EACNC,IAAI,EACJC,OAAO,EACPC,MAAM,EACNC,MAAM,EACNC,MAAM,EACNC,QAAQ,EACRC,QAAQ,EACRC,MAAM,EACNC,YAAY,EACZC,QAAQ,EACRC,OAAO,EACPC,MAAM,EACNC,SAAS,EACTC,cAAc,EACdC,mBAAmB,EACnBC,QAAQ,EACRC,UAAU,EACVC,MAAM,EACNC,WAAW,EACXC,SAAS,EACTC,QAAQ,EACRC,UAAU,EACVC,UAAU,EACVC,KAAK,EACLC,QAAQ,EACRC,MAAM,EACNC,MAAM,EACNC,KAAK,EACLC,UAAU,EACVC,QAAQ,EACRC,UAAU,EACVC,UAAU,EACVC,SAAS,EACTC,OAAO,EACPC,OAAO,EACPC,OAAO,EACPC,OAAO,EACPC,WAAW,EACXC,KAAK,EACLC,SAAS,EACTC,MAAM,EACNC,MAAM,EACNC,UAAU,EACVC,OAAO,EACPC,OAAO,EACPC,UAAU,EACVC,QAAQ,EACRC,IAAI,EACJC,QAAQ,EACRC,IAAI,EACJC,OAAO,EACPC,QAAQ,EACRC,KAAK,EACLC,SAAS,EACTC,WAAW,EACXC,UAAU,EACVC,MAAM,EACNC,IAAI,EACJC,MAAM,EACNC,SAAS,EACTC,MAAM,EACNC,MAAM,EACNC,MAAM,EACNC,OAAO,EACPC,OAAO,EACPC,KAAK,EACLC,MAAM,EACNC,MAAM,EACNC,KAAK,EACLC,MAAM,EACNC,SAAS,EACTC,IAAI,EACJC,IAAI,EACJC,MAAM,EACNC,IAAI,EACJC,OAAO,EACPC,KAAK,EACLC,OAAO,EACPC,MAAM,EACNC,aAAa,EACbC,WAAW,EACXC,SAAS,EACTC,WAAW,EACXC,WAAW,EACXC,UAAU,EACVC,SAAS,EACTC,WAAW,EACXC,OAAO,EACPC,OAAO,EACPC,QAAQ,EACRC,YAAY,EACZC,QAAQ,EACRC,QAAQ,EACRC,OAAO,EACPC,OAAO,EACPC,UAAU,EACVC,QAAQ,EACRC,KAAK,EACLC,MAAM,EACNC,QAAQ,EACRC,KAAK,EACLC,UAAU,EACVC,OAAO,EACPC,MAAM,EACNC,OAAO,EACPC,aAAa,EACbC,MAAM,EACNC,MAAM,EACNC,WAAW,EACXC,IAAI,EACJC,WAAW,EACXC,SAAS,EACTC,MAAM,EACNC,UAAU,EACVC,WAAW,EACXC,OAAO,EACPC,YAAY,EACZC,QAAQ,EACRC,MAAM,EACNC,OAAO,EACPC,eAAe,EACfC,QAAQ,EACRC,SAAS,EACTC,OAAO,EACPC,MAAM,EACNC,OAAO,EACPC,QAAQ,EACRC,MAAM,GAGFC,EAA4B,CAChCC,KAAK,EACLC,SAAS,EACTC,MAAM,EACNC,YAAY,EACZC,WAAW,EACX3F,UAAU,EACV4F,OAAO,EACPC,SAAS,EACTC,OAAO,EACPC,MAAM,EACNC,QAAQ,EACRC,MAAM,GAGFC,EAAyB,CAC7BC,KAAK,EACLC,WAAW,EACXzJ,KAAK,EACL0J,UAAU,EACVzJ,OAAO,EACP0J,UAAU,EACVzJ,KAAK,EACL0J,MAAM,EACNC,KAAK,EACLC,aAAa,EACbC,KAAK,EACL5J,OAAO,EACP6J,WAAW,EACXC,uBAAuB,EACvB7J,IAAI,EACJwI,KAAK,EACLsB,YAAY,EACZC,YAAY,EACZC,IAAI,EACJC,QAAQ,EACRhK,eAAe,EACfiK,MAAM,EACNC,aAAa,EACbC,iBAAiB,EACjBlK,SAAS,EACTC,QAAQ,EACRC,QAAQ,EACRiK,MAAM,EACNC,YAAY,EACZjK,SAAS,EACTC,MAAM,EACNC,IAAI,EACJgK,QAAQ,EACRC,QAAQ,EACRC,aAAa,EACbC,SAAS,EACTC,UAAU,EACVlK,MAAM,EACNC,MAAM,EACNkK,QAAQ,EACRjK,MAAM,EACNkK,WAAW,EACXC,OAAO,EACPC,MAAM,EACNC,UAAU,EACVC,SAAS,EACTC,SAAS,EACTtK,QAAQ,EACRuK,SAAS,EACTC,SAAS,EACTvK,QAAQ,EACRwK,aAAa,EACbC,SAAS,EACTC,WAAW,EACXC,SAAS,EACTzK,YAAY,EACZ0K,UAAU,EACVC,SAAS,EACTC,MAAM,EACNC,MAAM,EACNC,eAAe,EACfC,WAAW,EACXC,YAAY,EACZ/K,QAAQ,EACRC,OAAO,EACPC,MAAM,EACNC,SAAS,EACTC,cAAc,EACd4K,iCAAiC,EACjCC,cAAc,EACdC,cAAc,EACdC,aAAa,EACbC,gBAAgB,EAChBC,cAAc,EACdC,kCAAkC,EAClChL,QAAQ,EACRiL,OAAO,EACPC,MAAM,EACNjL,UAAU,EACVkL,WAAW,EACXjL,MAAM,EACNkL,UAAU,EACVC,YAAY,EACZC,KAAK,EACLC,UAAU,EACVnL,SAAS,EACToL,SAAS,EACTC,QAAQ,EACRpL,QAAQ,EACRqL,WAAW,EACXC,OAAO,EACPvE,MAAM,EACN9G,UAAU,EACVsL,eAAe,EACfC,YAAY,EACZtL,UAAU,EACVC,KAAK,EACLC,QAAQ,EACRC,MAAM,EACNoL,SAAS,EACTC,MAAM,EACNC,SAAS,EACTrL,MAAM,EACNsL,OAAO,EACPC,UAAU,EACVtL,KAAK,EACLuL,WAAW,EACXC,eAAe,EACfC,QAAQ,EACRC,QAAQ,EACRC,SAAS,EACTC,OAAO,EACPC,QAAQ,EACRC,MAAM,EACNC,SAAS,EACT7L,QAAQ,EACR8L,SAAS,EACT7L,UAAU,EACVC,UAAU,EACVE,OAAO,EACPC,OAAO,EACP0L,QAAQ,EACRC,YAAY,EACZC,OAAO,EACPC,QAAQ,EACRC,aAAa,EACbC,OAAO,EACP9L,OAAO,EACPE,WAAW,EACXC,KAAK,EACLC,SAAS,EACT2L,QAAQ,EACR7F,WAAW,EACX8F,WAAW,EACXC,MAAM,EACN5L,MAAM,EACNC,MAAM,EACNC,UAAU,EACV2L,WAAW,EACXC,QAAQ,EACRC,KAAK,EACLC,QAAQ,EACR7L,OAAO,EACPC,OAAO,EACPC,UAAU,EACV4L,QAAQ,EACRC,MAAM,EACN5L,QAAQ,EACR6L,MAAM,EACN5L,IAAI,EACJ6L,QAAQ,EACRC,OAAO,EACP5L,IAAI,EACJ6L,aAAa,EACbC,WAAW,EACXC,SAAS,EACTC,SAAS,EACT/L,OAAO,EACPgM,OAAO,EACPC,QAAQ,EACRC,aAAa,EACbjM,QAAQ,EACRC,KAAK,EACLC,SAAS,EACTgM,cAAc,EACd/L,WAAW,EACXgM,cAAc,EACd/L,UAAU,EACVC,MAAM,EACN+L,YAAY,EACZC,SAAS,EACT/L,IAAI,EACJC,MAAM,EACN+L,YAAY,EACZC,eAAe,EACfC,aAAa,EACbC,aAAa,EACbC,gBAAgB,EAChBC,YAAY,EACZC,YAAY,EACZC,sBAAsB,EACtBC,YAAY,EACZC,KAAK,EACLC,MAAM,EACNC,OAAO,EACPC,MAAM,EACN1M,SAAS,EACT2M,SAAS,EACT1M,MAAM,EACNE,MAAM,EACNyM,YAAY,EACZ/H,OAAO,EACPgI,OAAO,EACPC,SAAS,EACTC,MAAM,EACN3M,OAAO,EACP4M,gBAAgB,EAChBC,UAAU,EACV3M,KAAK,EACL4M,OAAO,EACPC,cAAc,EACdC,iBAAiB,EACjBC,SAAS,EACTC,OAAO,EACPC,UAAU,EACVC,UAAU,EACVC,QAAQ,EACRC,UAAU,EACVC,UAAU,EACVC,UAAU,EACVC,SAAS,EACTC,OAAO,EACPC,OAAO,EACPC,IAAI,EACJxN,MAAM,EACNyN,WAAW,EACXxN,KAAK,EACLyN,WAAW,EACXxN,MAAM,EACNyN,OAAO,EACPxN,SAAS,EACTyN,mBAAmB,EACnBC,cAAc,EACdzN,IAAI,EACJ0N,QAAQ,EACRC,MAAM,EACN1N,IAAI,EACJ2N,KAAK,EACL1N,MAAM,EACNC,IAAI,EACJC,OAAO,EACPC,KAAK,EACLC,OAAO,EACPC,MAAM,EACNsN,UAAU,EACVC,SAAS,EACTC,WAAW,EACXC,SAAS,EACTC,aAAa,EACbxN,WAAW,EACXyN,aAAa,EACbC,YAAY,EACZC,SAAS,EACTC,KAAK,EACL3N,SAAS,EACT4N,iBAAiB,EACjBC,iBAAiB,EACjBC,SAAS,EACTC,UAAU,EACVC,gBAAgB,EAChBC,UAAU,EACVhO,WAAW,EACXiO,SAAS,EACTC,YAAY,EACZ/N,SAAS,EACTC,WAAW,EACX+N,UAAU,EACVC,KAAK,EACLC,OAAO,EACPhO,OAAO,EACPiO,QAAQ,EACRhO,OAAO,EACPiO,MAAM,EACNC,SAAS,EACTC,WAAW,EACXC,KAAK,EACLlO,YAAY,EACZmO,aAAa,EACbC,SAAS,EACTnO,QAAQ,EACRoO,WAAW,EACXC,WAAW,EACXC,YAAY,EACZC,gBAAgB,EAChBC,SAAS,EACTC,YAAY,EACZC,UAAU,EACVC,UAAU,EACVC,UAAU,EACVC,SAAS,EACTC,QAAQ,EACRC,YAAY,EACZC,SAAS,EACTC,aAAa,EACbC,UAAU,EACVC,SAAS,EACTlP,QAAQ,EACRC,OAAO,EACPC,OAAO,EACPiP,MAAM,EACNC,OAAO,EACPjP,UAAU,EACVC,QAAQ,EACRC,KAAK,EACLC,MAAM,EACN+O,SAAS,EACTC,WAAW,EACXxM,QAAQ,EACRyM,SAAS,EACTC,OAAO,EACPC,QAAQ,EACRC,QAAQ,EACRC,MAAM,EACNpP,QAAQ,EACRqP,MAAM,EACNC,WAAW,EACXC,cAAc,EACdC,iBAAiB,EACjBC,cAAc,EACdxP,KAAK,EACLyP,MAAM,EACNC,SAAS,EACTC,MAAM,EACN1P,UAAU,EACV2P,MAAM,EACNrN,MAAM,EACNsN,UAAU,EACVC,cAAc,EACdC,cAAc,EACdC,UAAU,EACVC,YAAY,EACZC,QAAQ,EACRC,OAAO,EACPC,QAAQ,EACRC,eAAe,EACfC,QAAQ,EACRC,QAAQ,EACRC,aAAa,EACbC,QAAQ,EACRC,iBAAiB,EACjBC,UAAU,EACVC,QAAQ,EACRC,WAAW,EACXC,aAAa,EACbC,aAAa,EACb3Q,OAAO,EACP4Q,QAAQ,EACR3Q,aAAa,EACb4Q,eAAe,EACfC,YAAY,EACZC,UAAU,EACV7Q,MAAM,EACNE,WAAW,EACX4Q,eAAe,EACfC,iBAAiB,EACjBC,SAAS,EACT7Q,IAAI,EACJ8Q,UAAU,EACVC,iBAAiB,EACjBC,aAAa,EACbC,OAAO,EACP/Q,SAAS,EACTgR,YAAY,EACZ/Q,MAAM,EACNC,UAAU,EACV+Q,SAAS,EACT9Q,WAAW,EACX+Q,UAAU,EACV9Q,OAAO,EACP+Q,QAAQ,EACRC,SAAS,EACTC,QAAQ,EACR/Q,QAAQ,EACRgR,WAAW,EACXC,QAAQ,EACRC,KAAK,EACLjR,MAAM,EACNC,OAAO,EACPiR,UAAU,EACV/Q,QAAQ,EACRgR,WAAW,EACX/Q,SAAS,EACTgR,SAAS,EACTC,YAAY,EACZC,MAAM,EACNhR,MAAM,EACNiR,UAAU,EACVhR,OAAO,EACPiR,cAAc,EACdhR,QAAQ,EACRC,MAAM,EACNgR,QAAQ,EACRC,SAAS,GAGLC,EAAmB,SAACjzB,EAAGC,GAAJ,OACvBD,GACAC,GACAD,EACGzD,QAAQ,QAAS,IACjBA,QAAQ,QAAS,IACjBsY,gBACD5U,EACG1D,QAAQ,QAAS,IACjBA,QAAQ,QAAS,IACjBsY,eA6EDqe,EAAwB,SAAAC,GAAe,OAAIA,EAAgBC,IAAI,SAAAznB,GAAU,OAAIA,EAAWjO,QAwI/E4L,EAAA,SACb+pB,mBApNyB,SAACv2B,EAAQ2N,GAClC,IAAM6oB,EAAkBx2B,EAAO+X,cAC/B,OAAOpK,EAAQ3N,OAAO,SAAAy2B,GAEpB,IAAIC,EAAaD,EAAWj6B,MAAMub,cAAc/b,QAAQw6B,GAsBxD,OArBoB,IAAhBE,EAEe,IAAfA,GACCD,EAAWE,aACwD,IAAlEF,EAAWE,YAAY5e,cAAc/b,QAAQw6B,GAE/CC,EAAWG,aAAe,EAE1BH,EAAWG,aAAe,EAG5BH,EAAW1sB,SACX0sB,EAAW1sB,QAAQvD,UACe,IAAlCgwB,EAAgBx6B,QAAQ,OAGJ,KADpB06B,EAAaD,EAAW1sB,QAAQvD,QAAQuR,cAAc/b,QAAQw6B,MAE5DC,EAAWG,aAAe,EAC1BH,EAAWI,cAAe,IAGV,IAAhBH,IACFD,EAAWK,WAAaJ,EACxBD,EAAWM,YAAc/2B,EAAOT,QACzB,MAwLXy3B,iBAAkB,SAACx8B,EAAYqU,GAC7B,GAAgC,IAA5BA,EAAW7S,QAAQ,KACrB,OAAO6S,EAET,IAAMooB,EAAkBpoB,EAAWqoB,cACnC,MACiB,SAAf18B,IACC8hB,EAAqB2a,IAAoB/R,EAA0B+R,IAE7D,IAAMpoB,EAAa,IAET,WAAfrU,GAA2BsrB,EAAuBmR,GAC7C,IAAMpoB,EAAa,IAGX,WAAfrU,GACe,SAAfA,IACCsrB,EAAuBmR,IACtB3a,EAAqB2a,IACrB/R,EAA0B+R,IAErB,IAAMpoB,EAAa,IAEvB,0BAA0BiL,KAAKjL,GAG7BA,EAFE,IAAMA,EAAa,KAI9BsoB,eAAgB,SAACj0B,EAAGC,GAAJ,OACdD,GACAC,GACAD,EAAEk0B,aAAej0B,EAAEi0B,YACnBl0B,EAAEm0B,eAAiBl0B,EAAEk0B,cACrBn0B,EAAEo0B,YAAcn0B,EAAEm0B,WAClBp0B,EAAEq0B,cAAgBp0B,EAAEo0B,aACtBpB,iBAAkBA,EAClBqB,gBAtNsB,SAACC,EAAaz3B,EAAQ03B,GAC5CD,EAAYx0B,KAAK,SAACC,EAAGC,GACnB,GAAInD,EAAQ,CACV,QAC4B,IAAnBkD,EAAE0zB,mBACiB,IAAnBzzB,EAAEyzB,cACTzzB,EAAEyzB,eAAiB1zB,EAAE0zB,aAErB,OAAOzzB,EAAEyzB,aAAe1zB,EAAE0zB,aAE5B,QAA8B,IAAnB1zB,EAAE0zB,mBAA0D,IAAnBzzB,EAAEyzB,aACpD,OAAQ,EAEV,QAA8B,IAAnB1zB,EAAE0zB,mBAA0D,IAAnBzzB,EAAEyzB,aACpD,OAAO,EAGX,GAAIc,GAAgBA,EAAaC,sBAAuB,CACtD,GAAIz0B,EAAE0P,eAAiBzP,EAAEyP,aACvB,OAAQ,EAEV,GAAIzP,EAAEyP,eAAiB1P,EAAE0P,aACvB,OAAO,EAGX,IAAMglB,EAAU10B,EAAE20B,SAASC,QAAU50B,EAAE60B,cAAgB,GACjDC,EAAU70B,EAAE00B,SAASC,QAAU30B,EAAE40B,cAAgB,GACvD,YAAuB,IAAZH,QAA8C,IAAZI,GAA2BA,IAAYJ,EAC3EI,EAAUJ,OAEI,IAAZA,QAA8C,IAAZI,GACnC,OAEa,IAAZJ,QAA8C,IAAZI,EACpC,EAEF90B,EAAE1G,MAAMy7B,cAAc90B,EAAE3G,UAmLjC07B,oBA/J0B,SAAAzgC,GAC1B,IAAMkQ,EAAsB,GACtBxO,EAAWrB,IAAEsB,WACbN,EAAU,IAAIwB,UAAmBnB,OAAUiG,EAAWuI,GAG5D,GAFAsF,UAAYP,iBAAiB5T,EAASrB,IAEjCA,EAAQ4+B,gBAEX,OADAl9B,EAASkB,SACFvB,EAGT,IAAMq/B,EAAa,SAAbA,EAAcC,EAAcC,GAMhC,IAAIC,EALsB,IAAtBD,EAAW94B,QAOb+4B,EAD6B,QAA3BF,EAAane,UACH,QACwB,UAA3Bme,EAAane,UACV,OAEAoe,EAAW74B,QAGzBmI,EAAoB3E,KAClBo1B,EACGpoB,YAAY,CACXhE,YAAavU,EAAQuU,YACrBwH,WAAY/b,EAAQ+b,WACpBvZ,eAAe,IAEhByE,KAAK,SAAAuR,GACJ,IAAIsoB,OAAan5B,EACjB6Q,EAAa0H,KAAK,SAAAzH,GAChB,GAAIimB,EAAiBjmB,EAAWtP,KAAM03B,GAEpC,OADAC,EAAaroB,GACN,IAGPqoB,GAAcF,EAAW94B,OAC3B44B,EAAWI,EAAYF,GACdE,EACTp/B,EAASJ,QAAQw/B,GAEjBp/B,EAASkB,WAGZwE,KAAK1F,EAASkB,UApCjBlB,EAASkB,UAwGb,OAnBI5C,EAAQ+gC,OA7CM,SAAZC,EAAYC,GAChB,GAA0B,IAAtBA,EAAWn5B,OAAf,CAKA,IAAMo5B,EAAYD,EAAWtxB,WACK,IAAvBuxB,EAAUC,SAKrBjxB,EAAoB3E,KAClBiK,UACG+C,YAAY,CACXxV,WAAY/C,EAAQ+C,WACpB+S,UAAW9V,EAAQ8V,UACnB9S,QAAShD,EAAQgD,QACjBjB,KAAM48B,EAAsBuC,EAAUtC,iBACtC7iB,WAAY/b,GAAWA,EAAQ+b,WAC/BxH,YAAavU,GAAWA,EAAQuU,YAChCgH,cAAevb,GAAWA,EAAQub,cAClC/Y,eAAe,IAEhByE,KAAK,SAAAuR,GACJ,IAAIsoB,OAAan5B,EACjB6Q,EAAa0H,KAAK,SAAAzH,GAChB,GAAIimB,EAAiBjmB,EAAWtP,KAAMnJ,EAAQ4+B,gBAAgB,GAAGz1B,MAE/D,OADA23B,EAAaroB,GACN,IAIPqoB,GAAc9gC,EAAQ4+B,gBAAgB92B,OAAS,EACjD44B,EAAWI,EAAYnC,EAAsB3+B,EAAQ4+B,gBAAgBnwB,MAAM,KAClEqyB,EACTp/B,EAASJ,QAAQw/B,GAEjBE,EAAUC,KAGb75B,KAAK1F,EAASkB,SAjCjBo+B,EAAUC,QANVv/B,EAASkB,SA4CXo+B,CAAUhhC,EAAQ+gC,OAAOl5B,UAEzB2N,UACG0C,SAAS,CACRnV,WAAY/C,EAAQ+C,WACpB+S,UAAW9V,EAAQ8V,UACnB9S,QAAShD,EAAQgD,QACjBjB,KAAM,GACNga,WAAY/b,GAAWA,EAAQ+b,WAC/BxH,YAAavU,GAAWA,EAAQuU,YAChCgH,cAAevb,GAAWA,EAAQub,cAClC/Y,eAAe,IAEhByE,KAAK,SAAAqO,GACJorB,EAAWprB,EAAOqpB,EAAsB3+B,EAAQ4+B,oBAI/Cv9B,GA2CPs9B,sBAAuBA;;;;6DC3zBzB9pB,EAAAC,EAAAC,GAAA,IAAAyP,EAAA3P,eAAA,wCAAA4P,EAAA5P,EAAA6P,EAAAF,GAAA4c,EAAAvsB,+BAAA,wDAAAwsB,EAAAxsB,2BAAA,oDAAAysB,EAAAzsB,mBAAA,iDA2DI0sB,GAAa,EAEFxsB,EAAA,SACbysB,gBAAiB,WACf,IAAKt9B,OAAOu9B,cAAgBF,GAAcr9B,OAAOw9B,OAAQ,CAEvD,IAAMC,EAAoB,SAApBA,EAA6BC,EAAQz7B,GACpCy7B,EAAOC,QAOVD,EAAOE,YAAY37B,IANnBjC,OAAOkM,aAAawxB,EAAOG,aAC3BH,EAAOE,YAAY,CAAEE,MAAM,IAC3BJ,EAAOG,YAAc79B,OAAO6L,WAAW,WACrC4xB,EAAkBC,EAAQz7B,IACzB,OAOD87B,EAAqB,IAAIP,OAC7Bx9B,OAAOg+B,aAAe,4CAA8Ch+B,OAAOi+B,aAE7EF,EAAmBG,UAAY,SAAShhC,GAClCA,EAAEH,KAAK+gC,KACTC,EAAmBJ,SAAU,EAE7Bh+B,UAAU2B,QAAQ,gCAAiCpE,IAIvDyC,UAAUC,UAAU,6BAA8B,SAAAqC,GAChDw7B,EAAkBM,EAAoB97B,KAIxC,IAAMk8B,EAAuB,IAAIX,OAC7Bx9B,OAAOg+B,aAAe,8CAAgDh+B,OAAOi+B,aAEjFE,EAAqBD,UAAY,SAAShhC,GACpCA,EAAEH,KAAK+gC,KACTK,EAAqBR,SAAU,GAE3BzgC,EAAEH,KAAKqhC,WACTlhC,EAAEH,KAAKqhC,UAAUxgC,QAAQ,SAAAuC,IAhFT,SAASA,EAAUtB,EAAY+S,EAAW9S,GACpEqB,EAASo8B,oBAAsB,SAASzgC,GAItC,GAHKA,IACHA,EAAU,IAERqE,EAASk+B,qBAAuBl+B,EAASk+B,mBAAmBruB,UAE9D,OADAsB,UAAYP,iBAAiB5Q,EAASk+B,mBAAoBviC,GACnDqE,EAASk+B,mBAGlB,IAAKl+B,EAASu6B,kBAAoBv6B,EAASm+B,SAAWn+B,EAASm+B,OAAO5D,gBAMpE,OALKv6B,EAASk+B,qBACZl+B,EAASk+B,mBAAqBliC,IAAEsB,WAC7BiB,SACAvB,WAEEgD,EAASk+B,mBAGlB,IAAMlhC,EAAUohC,UAAShC,oBAAoB,CAC3C19B,WAAYA,EACZ+S,UAAWA,EACX9S,QAASA,EACTuY,cAAevb,EAAQub,cACvBhH,YAAavU,EAAQuU,YACrBwH,WAAY/b,EAAQ+b,WACpB6iB,gBAAiBv6B,EAASu6B,iBAAmBv6B,EAASm+B,OAAO5D,gBAC7DmC,OAAQ18B,EAAS08B,QAAW18B,EAASm+B,QAAUn+B,EAASm+B,OAAOzB,SAMjE,OAHK/gC,EAAQ+b,aACX1X,EAASk+B,mBAAqBlhC,GAEzBA,GAgDGqhC,CAAoBr+B,EAAUjD,EAAEH,KAAK8B,WAAY3B,EAAEH,KAAK6U,UAAW1U,EAAEH,KAAK+B,WAG9Ea,UAAU2B,QAAQ,kCAAmCpE,KAIzDyC,UAAUC,UAAU,+BAAgC,SAAAqC,GAClDw7B,EAAkBU,EAAsBl8B,KAG1Co7B,GAAa;;;;6DClHnB1sB,EAAAC,EAAAC,GAAA,IAAA4tB,EAAA9tB,oBAAA,kDAAA+tB,EAAA/tB,EAAA6P,EAAAie,GAkBMn+B,EAAW,CACfq+B,YAAa,WACX,IAAMnzB,EAAW,GACXozB,EAAgB,SAASr5B,GAC7BiG,EAASnE,KAAK+K,IAAYC,eAAe,CAAEpN,KAAMM,EAASvF,OAAOS,kBAAmBgS,UAEtFmsB,EAAc,sBACdA,EAAc,mBACdA,EAAc,wBACdA,EAAc,mCACdA,EAAc,0BACdA,EAAc,qCACd9xB,QAAQ+xB,IAAIrzB,GAAU+E,KAAK,WACzBuH,QAAQgnB,IAAI,kCAKHx+B;;;;6DCpCfqQ,EAAAC,EAAAC,GAkBA,IAAMkuB,EAAS,GACTC,EAAMD,EAAOE,eAEbt/B,EAAY,CAChBC,UAAW,SAASs/B,EAAOC,EAAUz3B,GAC9Bs3B,EAAI18B,KAAKy8B,EAAQG,KACpBH,EAAOG,GAAS,IAGlB,IAAMnpB,EACJgpB,EAAOG,GAAO73B,KAAK,CACjB83B,SAAUA,EACVz3B,IAAKA,EACLpI,OAAQ,YACL,EAEP,MAAO,CACL8/B,OAAQ,kBACCL,EAAOG,GAAOnpB,MAI3BspB,UAAW,SAASH,GAClBH,EAAOG,GAAS,IAElBI,cAAe,SAASJ,EAAOC,EAAUz3B,GACvC,IAAM63B,EAAYvjC,KAAK4D,UACrBs/B,EACA,WACEC,EAAS3uB,MAAM2uB,EAAUn4B,WACzBu4B,EAAUH,UAEZ13B,IAGJpG,QAAS,SAAS49B,EAAOM,GAClBR,EAAI18B,KAAKy8B,EAAQG,IAItBH,EAAOG,GAAOthC,QAAQ,SAAA6hC,GACA,YAAhBA,EAAKngC,QACPmgC,EAAKN,SAASK,MAIpBE,UAAW,WACT,OAAOX,GAETY,oBAAqB,SAASj4B,GACxBA,GACFxJ,OAAOC,KAAK4gC,GAAQnhC,QAAQ,SAAAgiC,GAC1Bb,EAAOa,GAAWhiC,QAAQ,SAAAshC,QAED,IAAdA,EAAMx3B,KACC,OAAdw3B,EAAMx3B,KACLw3B,EAAMx3B,MAAQA,GAAOw3B,EAAMx3B,IAAI0S,MAAM,KAAK,KAAO1S,IAElDw3B,EAAM5/B,OAAS,eAMzBugC,qBAAsB,SAASn4B,GACzBA,GACFxJ,OAAOC,KAAK4gC,GAAQnhC,QAAQ,SAAAgiC,GAC1Bb,EAAOa,GAAWhiC,QAAQ,SAAAshC,QAED,IAAdA,EAAMx3B,KACC,OAAdw3B,EAAMx3B,KACLw3B,EAAMx3B,MAAQA,GAAOw3B,EAAMx3B,IAAI0S,MAAM,KAAK,KAAO1S,IAElDw3B,EAAM5/B,OAAS,gBAMzBwgC,oBAAqB,SAASp4B,GACxBA,GACFxJ,OAAOC,KAAK4gC,GAAQnhC,QAAQ,SAAAgiC,GAC1Bb,EAAOa,GAAab,EAAOa,GAAWv7B,OAAO,SAAA07B,GAC3C,OAAOA,EAAIr4B,MAAQA,QAOd/H;;;;+WC1Ff,IAAMqgC,EAAkB,CACtBC,MADsB,WAEpB,IAAMC,EAAc/jC,IAAE6D,QAAQmgC,QAC9B,OAAID,GAAe,KACV,YACEA,GAAe,KAAOA,GAAe,IACvC,WAEA,aAGXE,MAXsB,WAYpB,IAAMF,EAAc/jC,IAAE6D,QAAQmgC,QAC9B,OAAID,GAAe,KACV,YACEA,GAAe,KAAOA,GAAe,IACvC,YAEA,YAGXG,OArBsB,WAsBpB,OAAO,aAgGLC,EAAY,SAACC,EAAQC,GACzB,IAAIC,EAAc,GAClB,GAAID,EAAQ,CACV,IAAME,EAAgBxiC,OAAOC,KAAKqiC,GAClC,GAAIE,EAAc98B,OAChB,KAAO88B,EAAc98B,QAAQ,CAC3B,IAAM+8B,EAASD,EAAcj1B,MAC7Bg1B,GAAeE,EAAS,IAAMH,EAAOG,GACjCD,EAAc98B,SAChB68B,GAAe,MAMvB,GAA2B,oBAAhBlD,aAA+BA,YAAa,CACrD,IAAIqD,EAAS5gC,OAAOG,SAASygC,OAM7B,OALIH,IACFG,IAAWA,EAAS,IAAM,KAAOH,GAEnCF,EAASvgC,OAAOG,SAAS0gC,SAAWD,EAAS,KAAOL,EAAOz8B,QAAQ,OAAQ,SAC3E9D,OAAO8gC,QAAQC,UAAU,KAAM,KAAMR,GAIvC,IAAMS,EAAYT,EAAOnmB,MAAM,KAE3B7d,GADOykC,EAAU,GAAGp9B,QAAwD,IAA9Co9B,EAAU,GAAG3gC,QAAQL,OAAOg+B,cAAsBh+B,OAAOg+B,aAAe,IACzFgD,EAAU,GACvBP,IACFlkC,KAA8B,IAAtBA,EAAI8D,QAAQ,KAAc,IAAM,KAAOogC,GAE7CO,EAAUp9B,OAAS,EACrBrH,GAAO,IAAMykC,EAAU,GACdhhC,OAAOG,SAAS7D,OACzBC,GAAOyD,OAAOG,SAAS7D,MAEzB0D,OAAO8gC,QAAQC,UAAU,KAAM,KAAMxkC,IAOjC0kC,EAAqB,SAACC,EAAOrgC,GACjC,GAA2B,oBAAhB08B,aAA+BA,YAAa,CACrD,IACM4D,EADanhC,OAAOG,SAAS7D,KAAKwH,QAAQ,KAAM,IAC7BsW,MAAM,KACzBvc,EAAOsjC,EAAM,GACfP,EAASO,EAAMv9B,OAAS,EAAIu9B,EAAM,GAAK,GAC3C,IAAKP,EAAOvgC,QAAQ6gC,EAAQ,IAAMrgC,GAChC,OAEF,IAAK+/B,EAAOvgC,QAAQ6gC,EAAQ,KAIxBN,EAHG//B,EAGM+/B,EAAO98B,QAAQ,IAAIs9B,OAAOF,EAAQ,UAAWA,EAAQ,IAAMrgC,GAF3D+/B,EAAO98B,QAAQ,IAAIs9B,OAAOF,EAAQ,YAAa,QAIrD,KAAIrgC,EAMT,OALI+/B,IACFA,GAAU,KAEZA,GAAUM,EAAQ,IAAMrgC,EAK1By/B,EAAUM,EAAS/iC,EAAO,IAAM+iC,EAAS/iC,OACpC,CACL,IAAIwjC,EAAY,GACkC,OAA9CrhC,OAAOG,SAASmhC,aAAaJ,GAAO,IACtCG,GAAa,IACbrhC,OAAOG,SAASygC,OACb98B,QAAQ,OAAQ,IAChBsW,MAAM,KACNxc,QAAQ,SAAA2jC,GACHA,EAAEnnB,MAAM,KAAK,KAAO8mB,IACtBG,GAAaE,KAGf1gC,IACFwgC,IAA4B,MAAdA,EAAoB,IAAM,IAAMH,EAAQ,IAAMrgC,IAG9DwgC,EACErhC,OAAOG,SAASygC,QACf//B,GAASb,OAAOG,SAASygC,OAAOvgC,QAAQ,MAAQ,EAAI,IAAM,KAAO6gC,EAAQ,IAAMrgC,EAAQ,IAG1E,MAAdwgC,IACFA,EAAY,IAGdf,EAAUtgC,OAAOG,SAAS0gC,SAAWQ,KA4EnCG,EAAqB,SAACZ,EAAQ37B,EAAMw8B,GACxCx8B,EAAOA,EAAKnB,QAAQ,OAAQ,OAAOA,QAAQ,OAAQ,OACnD,IACE49B,EADY,IAAIN,OAAO,SAAWn8B,EAAO,aACzB08B,KAAKf,GACvB,OAAIa,GAA0B,OAAZC,EACT,KAEU,OAAZA,EAAmB,GAAKE,mBAAmBF,EAAQ,GAAG59B,QAAQ,MAAO,OAGzE9D,OAAOG,SAASmhC,eACnBthC,OAAOG,SAASmhC,aAAe,SAASr8B,EAAMw8B,GAC5C,OAAOD,EAAmBxhC,OAAOG,SAASygC,OAAQ37B,EAAMw8B,KAI5D,IAyDMI,EAAM,SAANA,EAAOC,EAAMxxB,GACZwxB,GAAwB,WAAhBpmB,EAAOomB,IAGpB5jC,OAAOC,KAAK2jC,GAAMlkC,QAAQ,SAAAwJ,GACxBkJ,EAASwxB,EAAM16B,GACfy6B,EAAIC,EAAK16B,GAAMkJ,MAcbyxB,EAAK,kBACT17B,KAAKC,MAA4B,OAArB,EAAID,KAAK27B,WAClB3/B,SAAS,IACTwc,UAAU,IAqNAhO,EAAA,SACbmvB,gBAAiBA,EACjBiC,oBA7M0B,SAC1BC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,GAEA,IAAIC,EAuKJ,OArKEA,EADEH,EACKpmC,IAAE,UACNwmC,SAAS,8CACTp6B,KAAK,MACCk6B,EACFtmC,IAAE,OACNwmC,SAAS,OACTA,SAAS,wCACTp6B,KAAK,MAEDpM,IAAE,YACNwmC,SAAS,OACTA,SAAS,wCACTp6B,KAAK,OAELq6B,MAAM,SAAA1lC,GAuGT,SAAS2lC,EAAaC,EAAUT,GA0B9B,GAzBIC,GAAuBA,IAAsBS,6BAC/CD,EACEZ,EAAac,MAAM5oB,MAAMkoB,IAAsBS,4BAA4B,GAC3E,IACAD,GAGFR,GACAA,IAAsBW,oBACtBX,IAAsBW,mBAAmBC,gBAEzChB,EAAanlC,KAAK,WAAY+lC,GAC9BZ,EAAaiB,KAAK,sBAAuBL,GACwC,IAA7EA,EAASziC,QAAQiiC,IAAsBW,mBAAmBC,iBAC5DJ,EAAWA,EAASM,OAClBd,IAAsBW,mBAAmBC,cAAct/B,OAAS,KAIlEy+B,EACFH,EAAac,IAAIF,GAEjBZ,EAAac,IAAI,UAAYF,GAE/BZ,EAAamB,SACTjB,EACF,GAA8B,mBAAnBA,KAAiE,mBAAzBA,IAAgBvhC,MACjE,GAAIuhC,IAAgBvhC,OAElB,GADAuhC,IAAgBvhC,MAAMqhC,EAAac,OAC/BZ,IAAgBkB,mBAAoB,CACtCpB,EAAanlC,KAAK,WAAYmlC,EAAac,OAC3Cd,EAAaiB,KAAK,sBAAuBjB,EAAac,OACtD,IAAMO,EAAOrB,EAAac,MAC1Bd,EAAac,IAAIO,EAAKnpB,MAAM,KAAKmpB,EAAKnpB,MAAM,KAAKxW,OAAS,UAG5Dw+B,IAAgBF,EAAac,YAG/BZ,EAAcF,EAAac,OA9IjC9lC,EAAEsmC,iBACGhB,GACHrmC,IAAE6D,OAAOyjC,eAAed,SAAS,cAGnC,WACE,IAAIe,EAA8C,KAA/BvnC,IAAEwnC,KAAKzB,EAAac,OAAgBd,EAAac,MAAQ,KAEzEV,GACCA,IAAsBW,oBACtBX,IAAsBW,mBAAmBW,wBAClB,KAAvB1B,EAAac,OACdV,GAAuBA,IAAsBS,8BAE9CW,EAAe,IAEbxB,EAAanlC,KAAK,cACpB2mC,EAAexB,EAAanlC,KAAK,aAE/B2mC,EAAarjC,QAAQ,YAAc,IACrCqjC,EAAeA,EAAa7kB,UAAU,IAGxC,IAAIglB,IAAwB1B,EA0D5B,GAxDEG,QACoD,IAA7CA,IAAsBW,yBACoC,IAA1DX,IAAsBW,mBAAmBd,eAEhD0B,EAAsBvB,IAAsBW,mBAAmBd,cAGjEhmC,IAAE,gBAAgB2nC,gBAAgB,CAChCC,gBAAgB,EAChB5B,aAAc0B,EACdG,eAAgB,SAASlB,GACvBD,EAAaC,EAAUT,GACnBF,IACFhmC,IAAE,eAAe8nC,MAAM,QAClBzB,GACHrmC,IAAE,mBAAmBijC,WAI3B8E,aAAc,SAASpB,GACrBD,EAAaC,EAAUT,GACvBlmC,IAAE,eAAe8nC,MAAM,QAClBzB,GACHrmC,IAAE,mBAAmBijC,UAGzB+E,aACE7B,GACAA,IAAsBW,oBACtBX,IAAsBW,mBAAmBkB,aAC3CC,WACE9B,GACAA,IAAsBW,oBACtBX,IAAsBW,mBAAmBmB,WAC3CC,YAAaX,EACbY,kBAAmB,GACnBC,cAAc,EACdC,cACElC,GACAA,IAAsBW,oBACtBX,IAAsBW,mBAAmBuB,cAC3CC,oBACEnC,GACAA,IAAsBW,oBACtBX,IAAsBW,mBAAmBwB,oBACrCnC,IAAsBW,mBAAmBwB,oBACzC,GACNC,iBACEpC,GAAuBA,IAAsBqC,kBACzCrC,IAAsBqC,kBACtB,GACNC,mBACEtC,GACAA,IAAsBW,oBACtBX,IAAsBW,mBAAmB2B,qBAEzC5kC,OAAO6kC,OAAQ,CACjB,IAAMC,EAAW3oC,MAAI8nC,MAAMc,YAAY3iC,UAAU4iC,aACjD7oC,MAAI8nC,MAAMc,YAAY3iC,UAAU4iC,aAAe,aAC/C7oC,IAAE,eAAe8nC,MAAM,QACvBjkC,OAAO6L,WAAW,WAChB1P,MAAI8nC,MAAMc,YAAY3iC,UAAU4iC,aAAeF,GAC9C,UAEH3oC,IAAE,eAAe8nC,MAAM,QAEpBzB,GACHrmC,IAAE,eAAe8oC,GAAG,SAAU,WAC5B9oC,IAAE6D,OAAOyjC,eAAeyB,YAAY,cACpC/oC,IAAE,mBAAmBijC,WAM3B+F,KA+CE7C,GAAuBA,IAAsB8C,qBAC/C1C,EAAKC,SAAS,YAAYQ,KAAK,WAAY,YAEtCT,GA6BP2C,SAtjBe,SAAAC,GAIf,IAHA,IAAIp+B,EAAI,EACFq+B,EAAMD,EAAU1hC,OAFMub,EAAA,WAK1B,IAAMqmB,EAAM,GACVC,EAAWH,EAAUp+B,GACfu+B,EAASC,UAAU5hC,QAAQ,UAAW,KAAKsW,MAAM,KAErDxc,QAAQ,SAAA+nC,GACV,IAAIC,EAAU,KACRC,EAAK,iEAEPA,EAAG1nB,KAAKwnB,IACVC,EAAUD,EAAKG,MAAMD,GACrBF,EAAOA,EAAK7hC,QAAQ8hC,EAAS,YAAcA,EAAU,KAAOA,EAAU,QACtEJ,EAAIn+B,KAAKs+B,IAETH,EAAIn+B,KAAKs+B,KAIbF,EAASC,UAAYF,EAAI1nC,KAAK,MAlBxBoJ,EAAIq+B,EAAKr+B,IAAKiY,KAmjBtB4mB,WArhBiB,SAAAllC,GACjB,OAAO1E,IAAE,UACNoM,KAAK1H,GACLmlC,QAmhBHC,UAhhBgB,SAAAplC,GAChB,OAAO1E,IAAE,UACN6pC,KAAKnlC,GACL0H,OACAzE,QAAQ,UAAW,MA6gBtBoiC,aA1gBmB,WAEhB1jC,SAAS2jC,mBACT3jC,SAAS4jC,sBACT5jC,SAAS6jC,yBACT7jC,SAAS8jC,sBAEN9jC,SAAS+jC,gBAAgBC,kBAC3BhkC,SAAS+jC,gBAAgBC,oBAChBhkC,SAAS+jC,gBAAgBE,oBAClCjkC,SAAS+jC,gBAAgBE,sBAChBjkC,SAAS+jC,gBAAgBG,qBAClClkC,SAAS+jC,gBAAgBG,uBAChBlkC,SAAS+jC,gBAAgBI,yBAClCnkC,SAAS+jC,gBAAgBI,wBAAwBC,QAAQC,wBA6f7DC,eAxfqB,YAEnBtkC,SAAS2jC,mBACT3jC,SAAS4jC,sBACT5jC,SAAS6jC,yBACT7jC,SAAS8jC,uBAEL9jC,SAASukC,eACXvkC,SAASukC,iBACAvkC,SAASwkC,iBAClBxkC,SAASwkC,mBACAxkC,SAASykC,oBAClBzkC,SAASykC,sBACAzkC,SAAS0kC,sBAClB1kC,SAAS0kC,yBA2eb5G,UAAWA,EACX6G,WAhciB,SAAA5G,GACjBvgC,OAAO8gC,QAAQsG,aAAa,KAAM,KAAM7G,IAgcxCU,mBAAoBA,EACpBoG,mBAxYyB,SAAAnG,GACzBD,EAAmBC,EAAO,OAwY1BoG,oBArY0B,SAAAC,GAG1B,IAAMC,EAAe,GACjBD,GAAcA,EAAW3jC,OAAS,GACrB2jC,EAAW1oB,UAAU,EAAG0oB,EAAW3jC,OAAS,GAAGwW,MAAM,MAC7Dxc,QAAQ,SAAA6pC,GACTA,EAAKpnC,QAAQ,MAAQ,IACvBmnC,EAAaC,EAAKrtB,MAAM,KAAK,IAAMqtB,EAAKrtB,MAAM,KAAK,MAIzD,OAAOotB,GA0XPE,cAvXoB,SAAAC,GAIpB,OAHIA,aAAmBxrC,MACrBwrC,EAAUA,EAAQ,IAEbA,EAAQC,aAAeD,EAAQE,cAAgBF,EAAQG,YAAcH,EAAQI,aAoXpFC,gBAjXsB,SAAlBA,EAAmBvC,EAAUwC,EAAW33B,EAAU7L,GACtD,IAAMyjC,EAAMzC,aAAoBtpC,IAAIspC,EAAWtpC,IAAEspC,GACjD,GAAIwC,EAAUC,GACZ53B,EAAS43B,OACJ,CACLloC,OAAOkM,aAAag8B,EAAInrC,KAAK,yBAC7B,IAAMorC,EAAuBnoC,OAAO6L,WAAW,WAC7Cm8B,EAAgBvC,EAAUwC,EAAW33B,IACpC7L,GAAW,KACdyjC,EAAInrC,KAAK,uBAAwBorC,KAyWnCC,kBArWwB,SAACnnC,EAAYqP,GACrC,GAAIrP,IACFqP,EAASrP,QAET,IAAMonC,EAAepnC,EAAWrB,UAAU,SAAAyB,GACpCA,IACFgnC,EAAaC,UACbh4B,EAASrP,OA+VfsnC,gBAzVsB,SAAlBA,EAAmBC,EAAUl4B,EAAU7L,GACvC+jC,EACFl4B,EAASk4B,GAETxoC,OAAO6L,WAAW,WAChB08B,EAAgBC,EAAUl4B,IACzB7L,GAAW,MAoVhBgkC,eAhVqB,WACrB,IAAMC,EAAUvsC,IAAE,kEAAkEwsC,SAClFlF,eAEImF,EAAYF,EAAQ3sB,WACpBokB,EAAQyI,EAAUC,aAAeD,EAAUE,OAAO,IAAID,aAE5D,OADAH,EAAQtJ,SACDe,GA0UPqB,mBAAoBA,EACpBj/B,SAxTe,SAAAJ,QACe,IAAnBnC,OAAO8X,cAA2D,IAAzB9X,OAAO8X,QAAQ3V,aAC5C,IAAVA,GACT2V,QAAQ3V,MAAMA,GAEhB2V,QAAQ3V,OAAM,IAAIyW,OAAQmwB,SAoT5BC,gBAhTsB,SAACzhC,EAAGC,GAAJ,OAAUD,GAAKC,GAAKD,EAAE6U,gBAAkB5U,EAAE4U,eAiThE6sB,MA/SY,SAAAC,GACZ,OAAI,MAAOA,GAAsD,iBAARA,EAChDA,EAAIplC,QAAQ,sDAAuD,IAErEolC,GA4SPC,qBAzS2B,SAAAC,GAC3B,IAAK,IAAIliC,EAAI,EAAGA,EAAI1E,SAAS6mC,YAAYzlC,OAAQsD,IAE/C,IADA,IAAMoiC,EAAa9mC,SAAS6mC,YAAYniC,GAAGqiC,OAAS/mC,SAAS6mC,YAAYniC,GAAGsiC,SACnEC,EAAI,EAAGA,EAAIH,EAAW1lC,OAAQ6lC,IACrC,GAAIH,EAAWG,GAAGC,eAAiBN,EACjC,OAAOE,EAAWG,GAAGE,MAAQL,EAAWG,GAAGE,MAAQL,EAAWG,IAqSpEG,UA/RgB,SAACrhC,EAAMshC,GACvB,GAAmB,KAAfA,GAA8B,KAATthC,EACvB,OAAOA,EAGT,IAIIuhC,EAJAC,EAAUxhC,EACVyhC,EAAkB,GACtBH,EAAaA,EAAWztB,cAGxB,IAEE0tB,EADqBC,EAAQ3tB,cACH/b,QAAQwpC,KAChB,GAChBG,GACED,EAAQlrB,UAAU,EAAGirB,GACrB,WACAC,EAAQlrB,UAAUirB,EAAYA,EAAaD,EAAWjmC,QACtD,YACFmmC,EAAUA,EAAQlrB,UAAUirB,EAAaD,EAAWjmC,SAEpDomC,GAAmBD,QAEdD,GAAc,GAEvB,OAAOE,GAuQPnI,IAAKA,EACLoI,wBA3P8B,SAAAnI,GAO9BD,EAAIC,EAN0B,SAASA,EAAM16B,GACvC06B,EAAK16B,IAA6B,iBAAd06B,EAAK16B,WAGtB06B,EAAK16B,MAuPdjI,KA7OW,kBAAM4iC,IAAOA,IAAO,IAAMA,IAAO,IAAMA,IAAO,IAAMA,IAAO,IAAMA,IAAOA,IAAOA,KA8O1FmI,aA5OmB,SAAAhB,GAAG,OACtB/sC,IAAE,UACCoM,KAAK2gC,GACLlD,OACArC,QAyOHwG,uBA7C6B,SAAAC,GAE7B,IAAIC,EAAQD,EACNE,EAAqBD,EAAMvE,MAAM,uBAWvC,OAVIwE,GACFnuC,IAAEouC,KAAKD,EAAoB,SAACE,EAAKC,GAXnB,IAAAzE,EACV0E,EAWFL,EAAQA,EAAMvmC,QACZ2mC,EACAA,EAAGrH,OAAO,EAAGqH,EAAGpqC,QAAQ,MAAQ,GAC9BlE,IAAEwnC,MAfMqC,EAeSyE,EAAGrH,OAAOqH,EAAGpqC,QAAQ,MAAQ,GAAGkK,MAAM,GAAI,IAd7DmgC,EAAMloC,SAASmoC,cAAc,QAC/BjF,UAAYM,EACT0E,EAAIE,aAAeF,EAAIG,YAatB,SAIDR;;;;6DCnmBT15B,EAAAC,EAAAC,GAkBei6B,UAFF,SAAA53B,GAAU,OAAI63B,SAAS73B,IAAeA","file":"hue~notebook-bundle-1a0d487a3f343c023976.js","sourcesContent":["// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport $ from 'jquery';\nimport ko from 'knockout';\n\nimport apiQueueManager from 'api/apiQueueManager';\nimport CancellablePromise from 'api/cancellablePromise';\nimport hueDebug from 'utils/hueDebug';\nimport huePubSub from 'utils/huePubSub';\nimport hueUtils from 'utils/hueUtils';\n\nconst AUTOCOMPLETE_API_PREFIX = '/notebook/api/autocomplete/';\nconst SAMPLE_API_PREFIX = '/notebook/api/sample/';\nconst EXECUTE_API_PREFIX = '/notebook/api/execute/';\nconst DOCUMENTS_API = '/desktop/api2/doc/';\nconst DOCUMENTS_SEARCH_API = '/desktop/api2/docs/';\nconst FETCH_CONFIG = '/desktop/api2/get_config/';\nconst HDFS_API_PREFIX = '/filebrowser/view=' + encodeURIComponent('/');\nconst ADLS_API_PREFIX = '/filebrowser/view=' + encodeURIComponent('adl:/');\nconst GIT_API_PREFIX = '/desktop/api/vcs/contents/';\nconst S3_API_PREFIX = '/filebrowser/view=' + encodeURIComponent('S3A://');\nconst IMPALA_INVALIDATE_API = '/impala/api/invalidate';\nconst CONFIG_SAVE_API = '/desktop/api/configurations/save/';\nconst CONFIG_APPS_API = '/desktop/api/configurations';\nconst SOLR_COLLECTIONS_API = '/indexer/api/indexes/list/';\nconst SOLR_FIELDS_API = '/indexer/api/index/list/';\nconst DASHBOARD_TERMS_API = '/dashboard/get_terms';\nconst DASHBOARD_STATS_API = '/dashboard/get_stats';\nconst FORMAT_SQL_API = '/notebook/api/format';\nconst TOPO_URL = '/desktop/topo/';\n\nconst SEARCH_API = '/desktop/api/search/entities';\nconst INTERACTIVE_SEARCH_API = '/desktop/api/search/entities_interactive';\n\nconst HBASE_API_PREFIX = '/hbase/api/';\nconst SAVE_TO_FILE = '/filebrowser/save';\n\nconst NAV_URLS = {\n  ADD_TAGS: '/metadata/api/catalog/add_tags',\n  DELETE_TAGS: '/metadata/api/catalog/delete_tags',\n  FIND_ENTITY: '/metadata/api/catalog/find_entity',\n  LIST_TAGS: '/metadata/api/catalog/list_tags',\n  UPDATE_PROPERTIES: '/metadata/api/catalog/update_properties'\n};\n\nconst NAV_OPT_URLS = {\n  TOP_AGGS: '/metadata/api/optimizer/top_aggs',\n  TOP_COLUMNS: '/metadata/api/optimizer/top_columns',\n  TOP_FILTERS: '/metadata/api/optimizer/top_filters',\n  TOP_JOINS: '/metadata/api/optimizer/top_joins',\n  TOP_TABLES: '/metadata/api/optimizer/top_tables',\n  TABLE_DETAILS: '/metadata/api/optimizer/table_details'\n};\n\n/**\n *\n * @param {Object} options\n * @param {string} options.sourceType\n * @param {string} options.url\n * @param {boolean} options.refreshCache\n * @param {string} [options.hash] - Optional hash to use as well as the url\n * @param {Function} options.fetchFunction\n * @param {Function} options.successCallback\n * @param {string} [options.cacheType] - Possible values 'default'|'optimizer'. Default value 'default'\n * @param {Object} [options.editor] - Ace editor\n * @param {Object} [options.promise] - Optional promise that will be resolved if cached data exists\n */\nconst fetchCached = function(options) {\n  const self = this;\n  const cacheIdentifier = self.getAssistCacheIdentifier(options);\n  const cachedData = $.totalStorage(cacheIdentifier) || {};\n  const cachedId = options.hash ? options.url + options.hash : options.url;\n\n  if (\n    options.refreshCache ||\n    typeof cachedData[cachedId] == 'undefined' ||\n    self.hasExpired(cachedData[cachedId].timestamp, options.cacheType || 'default')\n  ) {\n    if (typeof options.editor !== 'undefined' && options.editor !== null) {\n      options.editor.showSpinner();\n    }\n    return options.fetchFunction(data => {\n      cachedData[cachedId] = {\n        timestamp: new Date().getTime(),\n        data: data\n      };\n      try {\n        $.totalStorage(cacheIdentifier, cachedData);\n      } catch (e) {}\n    });\n  } else {\n    if (options.promise) {\n      options.promise.resolve(cachedData[cachedId].data);\n    }\n\n    options.successCallback(cachedData[cachedId].data);\n  }\n};\n\n/**\n * Fetches the popularity for various aspects of the given tables\n *\n * @param {ApiHelper} apiHelper\n * @param {Object} options\n * @param {boolean} [options.silenceErrors]\n * @param {string[][]} options.paths\n * @param {string} url\n * @return {CancellablePromise}\n */\nconst genericNavOptMultiTableFetch = function(apiHelper, options, url) {\n  const deferred = $.Deferred();\n\n  const dbTables = {};\n  options.paths.forEach(path => {\n    dbTables[path.join('.')] = true;\n  });\n  const data = {\n    dbTables: ko.mapping.toJSON(Object.keys(dbTables))\n  };\n\n  const request = apiHelper.simplePost(url, data, {\n    silenceErrors: options.silenceErrors,\n    successCallback: function(data) {\n      data.hueTimestamp = Date.now();\n      deferred.resolve(data);\n    },\n    errorCallback: deferred.reject\n  });\n\n  return new CancellablePromise(deferred, request);\n};\n\n/**\n * Wrapper around the response from the Query API\n *\n * @param {string} sourceType\n * @param {Object} response\n *\n * @constructor\n */\nclass QueryResult {\n  constructor(sourceType, compute, response) {\n    const self = this;\n    self.id = hueUtils.UUID();\n    self.type = response.result && response.result.type ? response.result.type : sourceType;\n    self.compute = compute;\n    self.status = response.status || 'running';\n    self.result = response.result || {};\n    self.result.type = 'table';\n  }\n}\n\nclass ApiHelper {\n  constructor() {\n    const self = this;\n    self.queueManager = apiQueueManager;\n\n    huePubSub.subscribe('assist.clear.hdfs.cache', () => {\n      $.totalStorage(self.getAssistCacheIdentifier({ sourceType: 'hdfs' }), {});\n    });\n\n    huePubSub.subscribe('assist.clear.adls.cache', () => {\n      $.totalStorage(self.getAssistCacheIdentifier({ sourceType: 'adls' }), {});\n    });\n\n    huePubSub.subscribe('assist.clear.git.cache', () => {\n      $.totalStorage(self.getAssistCacheIdentifier({ sourceType: 'git' }), {});\n    });\n\n    huePubSub.subscribe('assist.clear.s3.cache', () => {\n      $.totalStorage(self.getAssistCacheIdentifier({ sourceType: 's3' }), {});\n    });\n\n    huePubSub.subscribe('assist.clear.collections.cache', () => {\n      $.totalStorage(self.getAssistCacheIdentifier({ sourceType: 'collections' }), {});\n    });\n\n    huePubSub.subscribe('assist.clear.hbase.cache', () => {\n      $.totalStorage(self.getAssistCacheIdentifier({ sourceType: 'hbase' }), {});\n    });\n\n    huePubSub.subscribe('assist.clear.document.cache', () => {\n      $.totalStorage(self.getAssistCacheIdentifier({ sourceType: 'document' }), {});\n    });\n\n    const clearAllCaches = function() {\n      self.clearDbCache({\n        sourceType: 'hive',\n        clearAll: true\n      });\n      self.clearDbCache({\n        sourceType: 'impala',\n        clearAll: true\n      });\n      $.totalStorage(self.getAssistCacheIdentifier({ sourceType: 'hdfs' }), {});\n      $.totalStorage(self.getAssistCacheIdentifier({ sourceType: 'adls' }), {});\n      $.totalStorage(self.getAssistCacheIdentifier({ sourceType: 'git' }), {});\n      $.totalStorage(self.getAssistCacheIdentifier({ sourceType: 's3' }), {});\n      $.totalStorage(self.getAssistCacheIdentifier({ sourceType: 'collections' }), {});\n      $.totalStorage(self.getAssistCacheIdentifier({ sourceType: 'hbase' }), {});\n      $.totalStorage(self.getAssistCacheIdentifier({ sourceType: 'document' }), {});\n    };\n\n    huePubSub.subscribe('assist.clear.all.caches', clearAllCaches);\n\n    if (window.performance && window.performance.navigation) {\n      if (window.performance.navigation.type === 1 && location.href.indexOf('/metastore') !== -1) {\n        // Browser refresh of the metastore page\n        clearAllCaches();\n      }\n    }\n  }\n\n  hasExpired(timestamp, cacheType) {\n    if (typeof hueDebug !== 'undefined' && typeof hueDebug.cacheTimeout !== 'undefined') {\n      return new Date().getTime() - timestamp > hueDebug.cacheTimeout;\n    }\n    return new Date().getTime() - timestamp > CACHEABLE_TTL[cacheType];\n  }\n\n  /**\n   * @param {string} sourceType\n   * @returns {string}\n   */\n  getTotalStorageUserPrefix(sourceType) {\n    return sourceType + '_' + window.LOGGED_USERNAME + '_' + window.location.hostname;\n  }\n\n  /**\n   * @param {object} options\n   * @param {string} options.sourceType\n   * @param {string} [options.cacheType] - Default value 'default'\n   * @returns {string}\n   */\n  getAssistCacheIdentifier(options) {\n    const self = this;\n    return (\n      'hue.assist.' +\n      (options.cacheType || 'default') +\n      '.' +\n      self.getTotalStorageUserPrefix(options.sourceType)\n    );\n  }\n\n  /**\n   *\n   * @param {string} owner - 'assist', 'viewModelA' etc.\n   * @param {string} id\n   * @param {*} [value] - Optional, undefined and null will remove the value\n   */\n  setInTotalStorage(owner, id, value) {\n    const self = this;\n    try {\n      const cachedData =\n        $.totalStorage('hue.user.settings.' + self.getTotalStorageUserPrefix(owner)) || {};\n      if (typeof value !== 'undefined' && value !== null) {\n        cachedData[id] = value;\n        $.totalStorage('hue.user.settings.' + self.getTotalStorageUserPrefix(owner), cachedData, {\n          secure: window.location.protocol.indexOf('https') > -1\n        });\n      } else if (cachedData[id]) {\n        delete cachedData[id];\n        $.totalStorage('hue.user.settings.' + self.getTotalStorageUserPrefix(owner), cachedData, {\n          secure: window.location.protocol.indexOf('https') > -1\n        });\n      }\n    } catch (e) {}\n  }\n\n  /**\n   *\n   * @param {string} owner - 'assist', 'viewModelA' etc.\n   * @param {string} id\n   * @param {*} [defaultValue]\n   * @returns {*}\n   */\n  getFromTotalStorage(owner, id, defaultValue) {\n    const self = this;\n    const cachedData =\n      $.totalStorage('hue.user.settings.' + self.getTotalStorageUserPrefix(owner)) || {};\n    return typeof cachedData[id] !== 'undefined' ? cachedData[id] : defaultValue;\n  }\n\n  /**\n   * @param {string} owner - 'assist', 'viewModelA' etc.\n   * @param {string} id\n   * @param {Observable} observable\n   * @param {*} [defaultValue] - Optional default value to use if not in total storage initially\n   */\n  withTotalStorage(owner, id, observable, defaultValue, noInit) {\n    const self = this;\n\n    const cachedValue = self.getFromTotalStorage(owner, id, defaultValue);\n\n    if (!noInit && cachedValue !== 'undefined') {\n      observable(cachedValue);\n    }\n\n    observable.subscribe(newValue => {\n      if (owner === 'assist' && id === 'assist_panel_visible') {\n        huePubSub.publish('assist.forceRender');\n      }\n      self.setInTotalStorage(owner, id, newValue);\n    });\n    return observable;\n  }\n\n  /**\n   * @param {Object} [response]\n   * @param {number} [response.status]\n   * @returns {boolean} - True if actually an error\n   */\n  successResponseIsError(response) {\n    return (\n      typeof response !== 'undefined' &&\n      (typeof response.traceback !== 'undefined' ||\n        (typeof response.status !== 'undefined' && response.status !== 0) ||\n        response.code === 503 ||\n        response.code === 500)\n    );\n  }\n\n  /**\n   * @param {Object} options\n   * @param {Function} [options.errorCallback]\n   * @param {boolean} [options.silenceErrors]\n   * @returns {Function}\n   */\n  assistErrorCallback(options) {\n    return function(errorResponse) {\n      let errorMessage = 'Unknown error occurred';\n      if (typeof errorResponse !== 'undefined' && errorResponse !== null) {\n        if (\n          typeof errorResponse.statusText !== 'undefined' &&\n          errorResponse.statusText === 'abort'\n        ) {\n          return;\n        } else if (typeof errorResponse.responseText !== 'undefined') {\n          try {\n            const errorJs = JSON.parse(errorResponse.responseText);\n            if (typeof errorJs.message !== 'undefined') {\n              errorMessage = errorJs.message;\n            } else {\n              errorMessage = errorResponse.responseText;\n            }\n          } catch (err) {\n            errorMessage = errorResponse.responseText;\n          }\n        } else if (typeof errorResponse.message !== 'undefined' && errorResponse.message !== null) {\n          errorMessage = errorResponse.message;\n        } else if (\n          typeof errorResponse.statusText !== 'undefined' &&\n          errorResponse.statusText !== null\n        ) {\n          errorMessage = errorResponse.statusText;\n        } else if (\n          errorResponse.error !== 'undefined' &&\n          Object.prototype.toString.call(errorResponse.error) === '[object String]'\n        ) {\n          errorMessage = errorResponse.error;\n        } else if (Object.prototype.toString.call(errorResponse) === '[object String]') {\n          errorMessage = errorResponse;\n        }\n      }\n\n      if (!options || !options.silenceErrors) {\n        hueUtils.logError(errorResponse);\n        if (errorMessage && errorMessage.indexOf('AuthorizationException') === -1) {\n          $(document).trigger('error', errorMessage);\n        }\n      }\n\n      if (options && options.errorCallback) {\n        options.errorCallback(errorMessage);\n      }\n      return errorMessage;\n    };\n  }\n\n  cancelActiveRequest(request) {\n    if (typeof request !== 'undefined' && request !== null) {\n      const readyState = request.getReadyState ? request.getReadyState() : request.readyState;\n      if (readyState < 4) {\n        request.abort();\n      }\n    }\n  }\n\n  /**\n   * @param {string} url\n   * @param {Object} data\n   * @param {Object} options\n   * @param {function} [options.successCallback]\n   * @param {function} [options.errorCallback]\n   * @param {boolean} [options.silenceErrors]\n   * @param {string} [options.dataType] - Default: Intelligent Guess (xml, json, script, text, html)\n   *\n   * @return {Promise}\n   */\n  simplePost(url, data, options) {\n    const self = this;\n    const deferred = $.Deferred();\n\n    const request = $.post({\n      url: url,\n      data: data,\n      dataType: options && options.dataType\n    })\n      .done(data => {\n        if (self.successResponseIsError(data)) {\n          deferred.reject(self.assistErrorCallback(options)(data));\n          return;\n        }\n        if (options && options.successCallback) {\n          options.successCallback(data);\n        }\n        deferred.resolve(data);\n      })\n      .fail(self.assistErrorCallback(options));\n\n    request.fail(data => {\n      deferred.reject(self.assistErrorCallback(options)(data));\n    });\n\n    const promise = deferred.promise();\n\n    promise.getReadyState = function() {\n      return request.readyState;\n    };\n\n    promise.abort = function() {\n      request.abort();\n    };\n\n    return promise;\n  }\n\n  /**\n   * @param {Object} data\n   * @param {Object} options\n   * @param {function} [options.successCallback]\n   */\n  saveSnippetToFile(data, options) {\n    const self = this;\n    $.post(\n      SAVE_TO_FILE,\n      data,\n      result => {\n        if (typeof options.successCallback !== 'undefined') {\n          options.successCallback(result);\n        }\n      },\n      'json'\n    ).fail(self.assistErrorCallback(options));\n  }\n\n  /**\n   * @param {string} url\n   * @param {Object} data\n   * @param {Object} options\n   * @param {function} [options.successCallback]\n   * @param {function} [options.errorCallback]\n   * @param {boolean} [options.silenceErrors]\n   */\n  simpleGet(url, data, options) {\n    const self = this;\n    if (!options) {\n      options = {};\n    }\n    return $.get(url, data, data => {\n      if (self.successResponseIsError(data)) {\n        self.assistErrorCallback(options)(data);\n      } else if (typeof options.successCallback !== 'undefined') {\n        options.successCallback(data);\n      }\n    }).fail(self.assistErrorCallback(options));\n  }\n\n  fetchUsersAndGroups(options) {\n    $.ajax({\n      method: 'GET',\n      url: '/desktop/api/users/autocomplete',\n      data: options.data || {},\n      contentType: 'application/json'\n    })\n      .done(response => {\n        options.successCallback(response);\n      })\n      .fail(response => {\n        options.errorCallback(response);\n      });\n  }\n\n  fetchUsersByIds(options) {\n    $.ajax({\n      method: 'GET',\n      url: '/desktop/api/users',\n      data: { userids: options.userids },\n      contentType: 'application/json'\n    })\n      .done(response => {\n        options.successCallback(response);\n      })\n      .fail(response => {\n        options.errorCallback(response);\n      });\n  }\n\n  /**\n   *\n   * @param {Object} options\n   * @param {string} options.location\n   * @param {boolean} [options.silenceErrors]\n   */\n  fetchTopo(options) {\n    const url = TOPO_URL + options.location;\n    return this.simpleGet(url, undefined, options);\n  }\n\n  /**\n   *\n   * @param {Object} options\n   * @param {string[]} options.path\n   * @param {string} options.type - 's3', 'adls' or 'hdfs'\n   * @param {number} [options.offset]\n   * @param {number} [options.length]\n   * @param {boolean} [options.silenceErrors]\n   */\n  fetchStoragePreview(options) {\n    const self = this;\n    let url;\n    if (options.type === 's3') {\n      url = S3_API_PREFIX;\n    } else if (options.type === 'adls') {\n      url = ADLS_API_PREFIX;\n    } else {\n      url = HDFS_API_PREFIX;\n    }\n\n    const clonedPath = options.path.concat();\n    if (clonedPath.length && clonedPath[0] === '/') {\n      clonedPath.shift();\n    }\n    url += clonedPath.join('/').replace(/#/g, '%23') + '?compression=none&mode=text';\n    url += '&offset=' + (options.offset || 0);\n    url += '&length=' + (options.length || 118784);\n\n    const deferred = $.Deferred();\n    $.ajax({\n      dataType: 'json',\n      url: url,\n      success: function(data) {\n        if (self.successResponseIsError(data)) {\n          deferred.reject(self.assistErrorCallback(options)(data));\n        } else {\n          deferred.resolve(data);\n        }\n      },\n      fail: deferred.reject\n    });\n\n    return deferred.promise();\n  }\n\n  /**\n   * @param {Object} options\n   * @param {Function} options.successCallback\n   * @param {Function} [options.errorCallback]\n   * @param {boolean} [options.silenceErrors]\n   * @param {Number} [options.timeout]\n   * @param {Object} [options.editor] - Ace editor\n   *\n   * @param {string[]} options.pathParts\n   * @param {number} [options.pageSize] - Default 500\n   * @param {number} [options.page] - Default 1\n   * @param {string} [options.filter]\n   */\n  fetchHdfsPath(options) {\n    const self = this;\n    if (\n      options.pathParts.length > 0 &&\n      (options.pathParts[0] === '/' || options.pathParts[0] === '')\n    ) {\n      options.pathParts.shift();\n    }\n    let url =\n      HDFS_API_PREFIX +\n      encodeURI(options.pathParts.join('/')) +\n      '?format=json&sortby=name&descending=false&pagesize=' +\n      (options.pageSize || 500) +\n      '&pagenum=' +\n      (options.page || 1);\n    if (options.filter) {\n      url += '&filter=' + options.filter;\n    }\n    const fetchFunction = function(storeInCache) {\n      if (options.timeout === 0) {\n        self.assistErrorCallback(options)({ status: -1 });\n        return;\n      }\n      return $.ajax({\n        dataType: 'json',\n        url: url,\n        timeout: options.timeout,\n        success: function(data) {\n          if (\n            !data.error &&\n            !self.successResponseIsError(data) &&\n            typeof data.files !== 'undefined' &&\n            data.files !== null\n          ) {\n            if (data.files.length > 2 && !options.filter) {\n              storeInCache(data);\n            }\n            options.successCallback(data);\n          } else {\n            self.assistErrorCallback(options)(data);\n          }\n        }\n      })\n        .fail(self.assistErrorCallback(options))\n        .always(() => {\n          if (typeof options.editor !== 'undefined' && options.editor !== null) {\n            options.editor.hideSpinner();\n          }\n        });\n    };\n\n    return fetchCached.bind(self)(\n      $.extend({}, options, {\n        sourceType: 'hdfs',\n        url: url,\n        fetchFunction: fetchFunction\n      })\n    );\n  }\n\n  /**\n   * @param {Object} options\n   * @param {Function} options.successCallback\n   * @param {Function} [options.errorCallback]\n   * @param {boolean} [options.silenceErrors]\n   * @param {Number} [options.timeout]\n   * @param {Object} [options.editor] - Ace editor\n   *\n   * @param {string[]} options.pathParts\n   * @param {number} [options.pageSize] - Default 500\n   * @param {number} [options.page] - Default 1\n   * @param {string} [options.filter]\n   */\n  fetchAdlsPath(options) {\n    const self = this;\n    options.pathParts.shift();\n    let url =\n      ADLS_API_PREFIX +\n      encodeURI(options.pathParts.join('/')) +\n      '?format=json&sortby=name&descending=false&pagesize=' +\n      (options.pageSize || 500) +\n      '&pagenum=' +\n      (options.page || 1);\n    if (options.filter) {\n      url += '&filter=' + options.filter;\n    }\n    const fetchFunction = function(storeInCache) {\n      if (options.timeout === 0) {\n        self.assistErrorCallback(options)({ status: -1 });\n        return;\n      }\n      return $.ajax({\n        dataType: 'json',\n        url: url,\n        timeout: options.timeout,\n        success: function(data) {\n          if (\n            !data.error &&\n            !self.successResponseIsError(data) &&\n            typeof data.files !== 'undefined' &&\n            data.files !== null\n          ) {\n            if (data.files.length > 2 && !options.filter) {\n              storeInCache(data);\n            }\n            options.successCallback(data);\n          } else {\n            self.assistErrorCallback(options)(data);\n          }\n        }\n      })\n        .fail(self.assistErrorCallback(options))\n        .always(() => {\n          if (typeof options.editor !== 'undefined' && options.editor !== null) {\n            options.editor.hideSpinner();\n          }\n        });\n    };\n\n    return fetchCached.bind(self)(\n      $.extend({}, options, {\n        sourceType: 'adls',\n        url: url,\n        fetchFunction: fetchFunction\n      })\n    );\n  }\n\n  /**\n   * @param {Object} options\n   * @param {Function} options.successCallback\n   * @param {Function} [options.errorCallback]\n   * @param {boolean} [options.silenceErrors]\n   * @param {Number} [options.timeout]\n   *\n   * @param {string[]} options.pathParts\n   * @param {string} options.fileType\n   */\n  fetchGitContents(options) {\n    const self = this;\n    const url =\n      GIT_API_PREFIX +\n      '?path=' +\n      encodeURI(options.pathParts.join('/')) +\n      '&fileType=' +\n      options.fileType;\n    const fetchFunction = function(storeInCache) {\n      if (options.timeout === 0) {\n        self.assistErrorCallback(options)({ status: -1 });\n        return;\n      }\n      $.ajax({\n        dataType: 'json',\n        url: url,\n        timeout: options.timeout,\n        success: function(data) {\n          if (!data.error && !self.successResponseIsError(data)) {\n            if (\n              data.fileType === 'dir' &&\n              typeof data.files !== 'undefined' &&\n              data.files !== null\n            ) {\n              if (data.files.length > 2) {\n                storeInCache(data);\n              }\n              options.successCallback(data);\n            } else if (\n              data.fileType === 'file' &&\n              typeof data.content !== 'undefined' &&\n              data.content !== null\n            ) {\n              options.successCallback(data);\n            }\n          } else {\n            self.assistErrorCallback(options)(data);\n          }\n        }\n      }).fail(self.assistErrorCallback(options));\n    };\n\n    fetchCached.bind(self)(\n      $.extend({}, options, {\n        sourceType: 'git',\n        url: url,\n        fetchFunction: fetchFunction\n      })\n    );\n  }\n\n  /**\n   * @param {Object} options\n   * @param {Function} options.successCallback\n   * @param {Function} [options.errorCallback]\n   * @param {boolean} [options.silenceErrors]\n   * @param {Number} [options.timeout]\n   * @param {Object} [options.editor] - Ace editor\n   *\n   * @param {string[]} options.pathParts\n   * @param {number} [options.pageSize] - Default 500\n   * @param {number} [options.page] - Default 1\n   * @param {string} [options.filter]\n   */\n  fetchS3Path(options) {\n    const self = this;\n    options.pathParts.shift(); // remove the trailing /\n    let url =\n      S3_API_PREFIX +\n      encodeURI(options.pathParts.join('/')) +\n      '?format=json&sortby=name&descending=false&pagesize=' +\n      (options.pageSize || 500) +\n      '&pagenum=' +\n      (options.page || 1);\n    if (options.filter) {\n      url += '&filter=' + options.filter;\n    }\n    const fetchFunction = function(storeInCache) {\n      if (options.timeout === 0) {\n        self.assistErrorCallback(options)({ status: -1 });\n        return;\n      }\n\n      $.ajax({\n        dataType: 'json',\n        url: url,\n        timeout: options.timeout,\n        success: function(data) {\n          if (\n            !data.error &&\n            !self.successResponseIsError(data) &&\n            typeof data.files !== 'undefined' &&\n            data.files !== null\n          ) {\n            if (data.files.length > 2 && !options.filter) {\n              storeInCache(data);\n            }\n            options.successCallback(data);\n          } else {\n            self.assistErrorCallback(options)(data);\n          }\n        }\n      })\n        .fail(self.assistErrorCallback(options))\n        .always(() => {\n          if (typeof options.editor !== 'undefined' && options.editor !== null) {\n            options.editor.hideSpinner();\n          }\n        });\n    };\n\n    fetchCached.bind(self)(\n      $.extend({}, options, {\n        sourceType: 's3',\n        url: url,\n        fetchFunction: fetchFunction\n      })\n    );\n  }\n\n  /**\n   * @param {Object} options\n   * @param {String} options.collectionName\n   * @param {String} options.fieldName\n   * @param {String} options.prefix\n   * @param {String} [options.engine]\n   * @param {Function} options.successCallback\n   * @param {Function} [options.alwaysCallback]\n   * @param {Number} [options.timeout]\n   *\n   */\n  fetchDashboardTerms(options) {\n    const self = this;\n    if (options.timeout === 0) {\n      self.assistErrorCallback(options)({ status: -1 });\n      return;\n    }\n    $.ajax({\n      dataType: 'json',\n      url: DASHBOARD_TERMS_API,\n      type: 'POST',\n      data: {\n        collection: ko.mapping.toJSON({\n          id: '',\n          name: options.collectionName,\n          engine: options.engine || 'solr'\n        }),\n        analysis: ko.mapping.toJSON({\n          name: options.fieldName,\n          terms: {\n            prefix: options.prefix || ''\n          }\n        })\n      },\n      timeout: options.timeout,\n      success: function(data) {\n        if (!data.error && !self.successResponseIsError(data) && data.status === 0) {\n          options.successCallback(data);\n        } else {\n          self.assistErrorCallback(options)(data);\n        }\n      }\n    })\n      .fail(self.assistErrorCallback(options))\n      .always(options.alwaysCallback);\n  }\n\n  /**\n   * @param {Object} options\n   * @param {String} options.collectionName\n   * @param {String} options.fieldName\n   * @param {String} [options.engine]\n   * @param {Function} options.successCallback\n   * @param {Function} [options.alwaysCallback]\n   * @param {Number} [options.timeout]\n   *\n   */\n  fetchDashboardStats(options) {\n    const self = this;\n    if (options.timeout === 0) {\n      self.assistErrorCallback(options)({ status: -1 });\n      return;\n    }\n    $.ajax({\n      dataType: 'json',\n      url: DASHBOARD_STATS_API,\n      type: 'POST',\n      data: {\n        collection: ko.mapping.toJSON({\n          id: '',\n          name: options.collectionName,\n          engine: options.engine || 'solr'\n        }),\n        analysis: ko.mapping.toJSON({\n          name: options.fieldName,\n          stats: {\n            facet: ''\n          }\n        }),\n        query: ko.mapping.toJSON({\n          qs: [{ q: '' }],\n          fqs: []\n        })\n      },\n      timeout: options.timeout,\n      success: function(data) {\n        if (!data.error && !self.successResponseIsError(data) && data.status === 0) {\n          options.successCallback(data);\n        } else if (data.status === 1) {\n          options.notSupportedCallback(data);\n        } else {\n          self.assistErrorCallback(options)(data);\n        }\n      }\n    })\n      .fail(self.assistErrorCallback(options))\n      .always(options.alwaysCallback);\n  }\n\n  /**\n   * @param {Object} options\n   * @param {Function} options.successCallback\n   * @param {Function} [options.errorCallback]\n   * @param {boolean} [options.silenceErrors]\n   * @param {Number} [options.timeout]\n   * @param {Object} [options.editor] - Ace editor\n   */\n  fetchHBase(options) {\n    const self = this;\n    let suffix = 'getClusters';\n    if (options.parent.name !== '') {\n      suffix = 'getTableList/' + options.parent.name;\n    }\n    const url = HBASE_API_PREFIX + suffix;\n    const fetchFunction = function(storeInCache) {\n      if (options.timeout === 0) {\n        self.assistErrorCallback(options)({ status: -1 });\n        return;\n      }\n      $.ajax({\n        dataType: 'json',\n        url: url,\n        timeout: options.timeout,\n        success: function(data) {\n          if (!data.error && !self.successResponseIsError(data)) {\n            storeInCache(data);\n            options.successCallback(data);\n          } else {\n            self.assistErrorCallback(options)(data);\n          }\n        }\n      })\n        .fail(self.assistErrorCallback(options))\n        .always(() => {\n          if (typeof options.editor !== 'undefined' && options.editor !== null) {\n            options.editor.hideSpinner();\n          }\n        });\n    };\n\n    fetchCached.bind(self)(\n      $.extend({}, options, {\n        sourceType: 'hbase',\n        url: url,\n        fetchFunction: fetchFunction\n      })\n    );\n  }\n\n  /**\n   * @param {Object} options\n   * @param {Number} options.pastMs\n   * @param {Number} options.stepMs\n   *\n   * @return {Promise}\n   */\n  fetchResourceStats(options) {\n    const self = this;\n\n    const queryMetric = function(metricName) {\n      const now = Date.now();\n      return self.simplePost('/metadata/api/prometheus/query', {\n        query: ko.mapping.toJSON(metricName),\n        start: Math.floor((now - options.pastMs) / 1000),\n        end: Math.floor(now / 1000),\n        step: options.stepMs / 1000\n      });\n    };\n\n    const combinedDeferred = $.Deferred();\n    $.when(\n      queryMetric('round((go_memstats_alloc_bytes / go_memstats_sys_bytes) * 100)'), // CPU percentage\n      queryMetric('round((go_memstats_alloc_bytes / go_memstats_sys_bytes) * 100)'), // Memory percentage\n      queryMetric('round((go_memstats_alloc_bytes / go_memstats_sys_bytes) * 100)'), // IO percentage\n      queryMetric('impala_queries_count{datawarehouse=\"' + options.clusterName + '\"}'), // Sum of all queries in flight (currently total query executed for testing purpose)\n      queryMetric('impala_queries{datawarehouse=\"' + options.clusterName + '\"}') // Queued queries\n    )\n      .done(function() {\n        const timestampIndex = {};\n        for (let j = 0; j < arguments.length; j++) {\n          const response = arguments[j];\n          if (response.data.result[0]) {\n            const values = response.data.result[0].values;\n            for (let i = 0; i < values.length; i++) {\n              if (!timestampIndex[values[i][0]]) {\n                timestampIndex[values[i][0]] = [values[i][0] * 1000, 0, 0, 0, 0, 0]; // Adjust back to milliseconds\n              }\n              timestampIndex[values[i][0]][j + 1] = parseFloat(values[i][1]);\n            }\n          }\n        }\n        const result = [];\n        Object.keys(timestampIndex).forEach(key => {\n          result.push(timestampIndex[key]);\n        });\n        result.sort((a, b) => {\n          return a[0] - b[0];\n        });\n        combinedDeferred.resolve(result);\n      })\n      .fail(combinedDeferred.reject);\n\n    return combinedDeferred.promise();\n  }\n\n  /**\n   * @param {Object} options\n   * @param {Function} [options.successCallback]\n   * @param {Function} [options.errorCallback]\n   * @param {boolean} [options.silenceErrors]\n   */\n  fetchConfigurations(options) {\n    const self = this;\n    self.simpleGet(CONFIG_APPS_API, {}, options);\n  }\n\n  saveGlobalConfiguration(options) {\n    const self = this;\n    self.simplePost(\n      CONFIG_APPS_API,\n      {\n        configuration: ko.mapping.toJSON(options.configuration)\n      },\n      options\n    );\n  }\n\n  /**\n   * @param {Object} options\n   * @param {Function} [options.successCallback]\n   * @param {Function} [options.errorCallback]\n   * @param {boolean} [options.silenceErrors]\n   *\n   * @param {string} options.app\n   * @param {Object} options.properties\n   * @param {boolean} [options.isDefault]\n   * @param {Number} [options.groupId]\n   * @param {Number} [options.userId]\n   */\n  saveConfiguration(options) {\n    const self = this;\n    self.simplePost(\n      CONFIG_SAVE_API,\n      {\n        app: options.app,\n        properties: ko.mapping.toJSON(options.properties),\n        is_default: options.isDefault,\n        group_id: options.groupId,\n        user_id: options.userId\n      },\n      options\n    );\n  }\n\n  /**\n   * @param {Object} options\n   * @param {Function} options.successCallback\n   * @param {Function} [options.errorCallback]\n   * @param {boolean} [options.silenceErrors]\n   *\n   * @param {string} [options.uuid]\n   */\n  fetchDocuments(options) {\n    const self = this;\n\n    let id = '';\n    if (options.uuid) {\n      id += options.uuid;\n    }\n    if (options.type && options.type !== 'all') {\n      id += options.type;\n    }\n\n    let promise = self.queueManager.getQueued(DOCUMENTS_API, id);\n    const firstInQueue = typeof promise === 'undefined';\n    if (firstInQueue) {\n      promise = $.Deferred();\n      self.queueManager.addToQueue(promise, DOCUMENTS_API, id);\n    }\n\n    promise.done(options.successCallback).fail(self.assistErrorCallback(options));\n\n    if (!firstInQueue) {\n      return;\n    }\n\n    const data = {\n      uuid: options.uuid\n    };\n\n    if (options.type && options.type !== 'all') {\n      data.type = ['directory', options.type];\n    }\n\n    $.ajax({\n      url: DOCUMENTS_API,\n      data: data,\n      traditional: true,\n      success: function(data) {\n        if (!self.successResponseIsError(data)) {\n          promise.resolve(data);\n        } else {\n          promise.reject(data);\n        }\n      }\n    }).fail(promise.reject);\n  }\n\n  /**\n   * @param {Object} options\n   * @param {Function} options.successCallback\n   * @param {Function} [options.errorCallback]\n   * @param {boolean} [options.silenceErrors]\n   *\n   * @param {string} [options.path]\n   * @param {string} [options.query]\n   * @param {string} [options.type]\n   * @param {int} [options.page]\n   * @param {int} [options.limit]\n   */\n  searchDocuments(options) {\n    const self = this;\n    return $.ajax({\n      url: DOCUMENTS_SEARCH_API,\n      data: {\n        uuid: options.uuid,\n        text: options.query,\n        type: options.type,\n        page: options.page,\n        limit: options.limit,\n        include_trashed: options.include_trashed\n      },\n      success: function(data) {\n        if (!self.successResponseIsError(data)) {\n          options.successCallback(data);\n        } else {\n          self.assistErrorCallback(options)(data);\n        }\n      }\n    }).fail(self.assistErrorCallback(options));\n  }\n\n  /**\n   * @param {Object} options\n   * @param {number} options.uuid\n   * @param {boolean} [options.silenceErrors]\n   * @param {boolean} [options.fetchContents]\n   *\n   * @return {CancellablePromise}\n   */\n  fetchDocument(options) {\n    const self = this;\n    const deferred = $.Deferred();\n    const request = $.ajax({\n      url: DOCUMENTS_API,\n      data: {\n        uuid: options.uuid,\n        data: !!options.fetchContents\n      },\n      success: function(data) {\n        if (!self.successResponseIsError(data)) {\n          deferred.resolve(data);\n        } else {\n          deferred.reject(\n            self.assistErrorCallback({\n              silenceErrors: options.silenceErrors\n            })\n          );\n        }\n      }\n    }).fail(\n      self.assistErrorCallback({\n        silenceErrors: options.silenceErrors,\n        errorCallback: deferred.reject\n      })\n    );\n    return new CancellablePromise(deferred, request);\n  }\n\n  /**\n   * @param {Object} options\n   * @param {Function} options.successCallback\n   * @param {Function} [options.errorCallback]\n   * @param {boolean} [options.silenceErrors]\n   *\n   * @param {string} options.parentUuid\n   * @param {string} options.name\n   */\n  createDocumentsFolder(options) {\n    const self = this;\n    self.simplePost(\n      DOCUMENTS_API + 'mkdir',\n      {\n        parent_uuid: ko.mapping.toJSON(options.parentUuid),\n        name: ko.mapping.toJSON(options.name)\n      },\n      options\n    );\n  }\n\n  /**\n   * @param {Object} options\n   * @param {Function} options.successCallback\n   * @param {Function} [options.errorCallback]\n   * @param {boolean} [options.silenceErrors]\n   *\n   * @param {string} options.uuid\n   * @param {string} options.name\n   */\n  updateDocument(options) {\n    const self = this;\n    self.simplePost(\n      DOCUMENTS_API + 'update',\n      {\n        uuid: ko.mapping.toJSON(options.uuid),\n        name: options.name\n      },\n      options\n    );\n  }\n\n  /**\n   * @param {Object} options\n   * @param {Function} options.successCallback\n   * @param {Function} [options.errorCallback]\n   * @param {Function} [options.progressHandler]\n   * @param {boolean} [options.silenceErrors]\n   *\n   * @param {FormData} options.formData\n   */\n  uploadDocument(options) {\n    const self = this;\n    $.ajax({\n      url: DOCUMENTS_API + 'import',\n      type: 'POST',\n      success: function(data) {\n        if (!self.successResponseIsError(data)) {\n          options.successCallback(data);\n        } else {\n          self.assistErrorCallback(options)(data);\n        }\n      },\n      xhr: function() {\n        const myXhr = $.ajaxSettings.xhr();\n        if (myXhr.upload && options.progressHandler) {\n          myXhr.upload.addEventListener('progress', options.progressHandler, false);\n        }\n        return myXhr;\n      },\n      dataType: 'json',\n      data: options.formData,\n      cache: false,\n      contentType: false,\n      processData: false\n    }).fail(self.assistErrorCallback(options));\n  }\n\n  /**\n   *\n   * @param {Function} options.successCallback\n   * @param {Function} [options.errorCallback]\n   * @param {boolean} [options.silenceErrors]\n   *\n   * @param {number} options.sourceId - The ID of the source document\n   * @param {number} options.destinationId - The ID of the target document\n   */\n  moveDocument(options) {\n    const self = this;\n    self.simplePost(\n      DOCUMENTS_API + 'move',\n      {\n        source_doc_uuid: ko.mapping.toJSON(options.sourceId),\n        destination_doc_uuid: ko.mapping.toJSON(options.destinationId)\n      },\n      options\n    );\n  }\n\n  /**\n   * @param {Object} options\n   * @param {Function} options.successCallback\n   * @param {Function} [options.errorCallback]\n   * @param {boolean} [options.silenceErrors]\n   *\n   * @param {string} options.uuid\n   * @param {string} [options.skipTrash] - Default false\n   */\n  deleteDocument(options) {\n    const self = this;\n    self.simplePost(\n      DOCUMENTS_API + 'delete',\n      {\n        uuid: ko.mapping.toJSON(options.uuid),\n        skip_trash: ko.mapping.toJSON(options.skipTrash || false)\n      },\n      options\n    );\n  }\n\n  /**\n   * @param {Object} options\n   * @param {Function} options.successCallback\n   * @param {Function} [options.errorCallback]\n   * @param {boolean} [options.silenceErrors]\n   *\n   * @param {string} options.uuid\n   */\n  copyDocument(options) {\n    const self = this;\n    self.simplePost(\n      DOCUMENTS_API + 'copy',\n      {\n        uuid: ko.mapping.toJSON(options.uuid)\n      },\n      options\n    );\n  }\n\n  /**\n   * @param {Object} options\n   * @param {Function} options.successCallback\n   * @param {Function} [options.errorCallback]\n   * @param {boolean} [options.silenceErrors]\n   *\n   * @param {string} options.uuid\n   */\n  restoreDocument(options) {\n    const self = this;\n    self.simplePost(\n      DOCUMENTS_API + 'restore',\n      {\n        uuids: ko.mapping.toJSON(options.uuids)\n      },\n      options\n    );\n  }\n\n  /**\n   *\n   * @param {Object} options\n   * @param {string} options.sourceType\n   * @param {string} [options.databaseName]\n   * @param {string} [options.tableName]\n   * @param {string} [options.cacheType] - Possible values 'default', 'optimizer. Default value 'default'\n   * @param {string[]} [options.fields]\n   * @param {boolean} [options.clearAll]\n   */\n  clearDbCache(options) {\n    const self = this;\n    const cacheIdentifier = self.getAssistCacheIdentifier(options);\n    if (options.clearAll) {\n      $.totalStorage(cacheIdentifier, {});\n    } else {\n      let url = AUTOCOMPLETE_API_PREFIX;\n      if (options.databaseName) {\n        url += options.databaseName;\n      }\n      if (options.tableName) {\n        url += '/' + options.tableName;\n      }\n      if (options.fields) {\n        url += options.fields.length > 0 ? '/' + options.fields.join('/') : '';\n      }\n      const cachedData = $.totalStorage(cacheIdentifier) || {};\n      delete cachedData[url];\n      $.totalStorage(cacheIdentifier, cachedData);\n    }\n  }\n\n  /**\n   * @param {Object} options\n   * @param {string} options.sourceType\n   * @param {string} options.invalidate - 'invalidate' or 'invalidateAndFlush'\n   * @param {string[]} [options.path]\n   * @param {ContextCompute} [options.compute]\n   * @param {boolean} [options.silenceErrors]\n   */\n  invalidateSourceMetadata(options) {\n    const self = this;\n    const deferred = $.Deferred();\n\n    if (\n      options.sourceType === 'impala' &&\n      (options.invalidate === 'invalidate' || options.invalidate === 'invalidateAndFlush')\n    ) {\n      const data = {\n        flush_all: options.invalidate === 'invalidateAndFlush',\n        cluster: JSON.stringify(options.compute)\n      };\n\n      if (options.path && options.path.length > 0) {\n        data.database = options.path[0];\n      }\n      if (options.path && options.path.length > 1) {\n        data.table = options.path[1];\n      }\n\n      const request = self\n        .simplePost(IMPALA_INVALIDATE_API, data, options)\n        .done(deferred.resolve)\n        .fail(deferred.reject);\n\n      return new CancellablePromise(deferred, request);\n    }\n\n    return deferred.resolve().promise();\n  }\n\n  /**\n   * @param {Object} options\n   * @param {string} options.sourceType\n   * @param {ContextCompute} options.compute\n   * @param {boolean} [options.silenceErrors]\n   * @param {number} [options.timeout]\n   *\n   * @param {string[]} [options.path] - The path to fetch\n   *\n   * @return {CancellablePromise}\n   */\n  fetchSourceMetadata(options) {\n    const self = this;\n    const deferred = $.Deferred();\n\n    const isQuery = options.sourceType.indexOf('-query') !== -1;\n    const sourceType = isQuery ? options.sourceType.replace('-query', '') : options.sourceType;\n\n    const request = $.ajax({\n      type: 'POST',\n      url: AUTOCOMPLETE_API_PREFIX + (isQuery ? options.path.slice(1) : options.path).join('/'),\n      data: {\n        notebook: {},\n        snippet: ko.mapping.toJSON({\n          type: sourceType,\n          source: isQuery ? 'query' : 'data'\n        }),\n        cluster: ko.mapping.toJSON(options.compute ? options.compute : '\"\"')\n      },\n      timeout: options.timeout\n    })\n      .done(data => {\n        data.notFound =\n          data.status === 0 &&\n          data.code === 500 &&\n          data.error &&\n          (data.error.indexOf('Error 10001') !== -1 ||\n            data.error.indexOf('AnalysisException') !== -1);\n        data.hueTimestamp = Date.now();\n\n        // TODO: Display warning in autocomplete when an entity can't be found\n        // Hive example: data.error: [...] SemanticException [Error 10001]: Table not found default.foo\n        // Impala example: data.error: [...] AnalysisException: Could not resolve path: 'default.foo'\n        if (!data.notFound && self.successResponseIsError(data)) {\n          self.assistErrorCallback({\n            silenceErrors: options.silenceErrors,\n            errorCallback: deferred.reject\n          })(data);\n        } else {\n          deferred.resolve(data);\n        }\n      })\n      .fail(\n        self.assistErrorCallback({\n          silenceErrors: options.silenceErrors,\n          errorCallback: deferred.reject\n        })\n      );\n\n    return new CancellablePromise(deferred, request);\n  }\n\n  updateSourceMetadata(options) {\n    const self = this;\n    let url;\n    const data = {\n      source_type: options.sourceType\n    };\n    if (options.path.length === 1) {\n      url = '/metastore/databases/' + options.path[0] + '/alter';\n      data.properties = ko.mapping.toJSON(options.properties);\n    } else if (options.path.length === 2) {\n      url = '/metastore/table/' + options.path[0] + '/' + options.path[1] + '/alter';\n      if (options.properties) {\n        if (options.properties.comment) {\n          data.comment = options.properties.comment;\n        }\n        if (options.properties.name) {\n          data.new_table_name = options.properties.name;\n        }\n      }\n    } else if (options.path > 2) {\n      url = '/metastore/table/' + options.path[0] + '/' + options.path[1] + '/alter_column';\n      data.column = options.path.slice(2).join('.');\n      if (options.properties) {\n        if (options.properties.comment) {\n          data.comment = options.properties.comment;\n        }\n        if (options.properties.name) {\n          data.new_column_name = options.properties.name;\n        }\n        if (options.properties.type) {\n          data.new_column_type = options.properties.name;\n        }\n        if (options.properties.partitions) {\n          data.partition_spec = ko.mapping.toJSON(options.properties.partitions);\n        }\n      }\n    }\n    return self.simplePost(url, data, options);\n  }\n\n  /**\n   * Fetches the analysis for the given source and path\n   *\n   * @param {Object} options\n   * @param {boolean} [options.silenceErrors]\n   *\n   * @param {ContextCompute} options.compute\n   * @param {string} options.sourceType\n   * @param {string[]} options.path\n   *\n   * @return {CancellablePromise}\n   */\n  fetchAnalysis(options) {\n    const self = this;\n    const deferred = $.Deferred();\n\n    let url = '/notebook/api/describe/' + options.path[0];\n\n    if (options.path.length > 1) {\n      url += '/' + options.path[1] + '/';\n    }\n\n    if (options.path.length > 2) {\n      url += 'stats/' + options.path.slice(2).join('/');\n    }\n\n    const data = {\n      format: 'json',\n      cluster: JSON.stringify(options.compute),\n      source_type: options.sourceType\n    };\n\n    const request = self['simplePost'](url, data, {\n      silenceErrors: options.silenceErrors,\n      successCallback: function(response) {\n        if (options.path.length === 1) {\n          if (response.data) {\n            response.data.hueTimestamp = Date.now();\n            deferred.resolve(response.data);\n          } else {\n            deferred.reject();\n          }\n        } else {\n          deferred.resolve(response);\n        }\n      },\n      errorCallback: deferred.reject\n    });\n\n    return new CancellablePromise(deferred, request);\n  }\n\n  /**\n   * Fetches the partitions for the given path\n   *\n   * @param {Object} options\n   * @param {boolean} [options.silenceErrors]\n   *\n   * @param {string[]} options.path\n   * @param {ContextCompute} options.compute\n   *\n   * @return {CancellablePromise}\n   */\n  fetchPartitions(options) {\n    const self = this;\n    const deferred = $.Deferred();\n\n    // TODO: No sourceType needed?\n    const request = $.post('/metastore/table/' + options.path.join('/') + '/partitions', {\n      format: 'json',\n      cluster: JSON.stringify(options.compute)\n    })\n      .done(response => {\n        if (!self.successResponseIsError(response)) {\n          if (!response) {\n            response = {};\n          }\n          response.hueTimestamp = Date.now();\n          deferred.resolve(response);\n        } else {\n          self.assistErrorCallback({\n            silenceErrors: options.silenceErrors,\n            errorCallback: deferred.reject\n          })(response);\n        }\n      })\n      .fail(response => {\n        // Don't report any partitions if it's not partitioned instead of error to prevent unnecessary calls\n        if (\n          response &&\n          response.responseText &&\n          response.responseText.indexOf('is not partitioned') !== -1\n        ) {\n          deferred.resolve({\n            hueTimestamp: Date.now(),\n            partition_keys_json: [],\n            partition_values_json: []\n          });\n        } else {\n          self.assistErrorCallback({\n            silenceErrors: options.silenceErrors,\n            errorCallback: deferred.reject\n          })(response);\n        }\n      });\n\n    return new CancellablePromise(deferred, request);\n  }\n\n  /**\n   * Refreshes the analysis for the given source and path\n   *\n   * @param {Object} options\n   * @param {boolean} [options.silenceErrors]\n   *\n   * @param {string} options.sourceType\n   * @param {ContextCompute} options.compute\n   * @param {string[]} options.path\n   *\n   * @return {CancellablePromise}\n   */\n  refreshAnalysis(options) {\n    const self = this;\n\n    if (options.path.length === 1) {\n      return self.fetchAnalysis(options);\n    }\n    const deferred = $.Deferred();\n\n    const promises = [];\n\n    const pollForAnalysis = (url, delay) => {\n      window.setTimeout(() => {\n        promises.push(\n          self.simplePost(url, undefined, {\n            silenceErrors: options.silenceErrors,\n            successCallback: function(data) {\n              promises.pop();\n              if (data.isSuccess) {\n                promises.push(\n                  self\n                    .fetchAnalysis(options)\n                    .done(deferred.resolve)\n                    .fail(deferred.reject)\n                );\n              } else if (data.isFailure) {\n                deferred.reject(data);\n              } else {\n                pollForAnalysis(url, 1000);\n              }\n            },\n            errorCallback: deferred.reject\n          })\n        );\n      }, delay);\n    };\n\n    const url =\n      '/' +\n      (options.sourceType === 'hive' ? 'beeswax' : options.sourceType) +\n      '/api/analyze/' +\n      options.path.join('/') +\n      '/';\n\n    promises.push(\n      self.simplePost(url, undefined, {\n        silenceErrors: options.silenceErrors,\n        successCallback: function(data) {\n          promises.pop();\n          if (data.status === 0 && data.watch_url) {\n            pollForAnalysis(data.watch_url, 500);\n          } else {\n            deferred.reject();\n          }\n        },\n        errorCallback: deferred.reject\n      })\n    );\n\n    return new CancellablePromise(deferred, undefined, promises);\n  }\n\n  /**\n   * Checks the status for the given snippet ID\n   * Note: similar to notebook and search check_status.\n   *\n   * @param {Object} options\n   * @param {Object} options.notebookJson\n   * @param {Object} options.snippetJson\n   * @param {boolean} [options.silenceErrors]\n   *\n   * @return {CancellablePromise}\n   */\n  whenAvailable(options) {\n    const self = this;\n    const deferred = $.Deferred();\n    const cancellablePromises = [];\n\n    let waitTimeout = -1;\n\n    deferred.fail(() => {\n      window.clearTimeout(waitTimeout);\n    });\n\n    const waitForAvailable = () => {\n      const request = self\n        .simplePost(\n          '/notebook/api/check_status',\n          {\n            notebook: options.notebookJson,\n            snippet: options.snippetJson,\n            cluster: ko.mapping.toJSON(options.compute ? options.compute : '\"\"')\n          },\n          {\n            silenceErrors: options.silenceErrors\n          }\n        )\n        .done(response => {\n          if (response && response.query_status && response.query_status.status) {\n            const status = response.query_status.status;\n            if (status === 'available') {\n              deferred.resolve();\n            } else if (status === 'running' || status === 'starting' || status === 'waiting') {\n              waitTimeout = window.setTimeout(() => {\n                waitForAvailable();\n              }, 500);\n            } else {\n              deferred.reject();\n            }\n          }\n        })\n        .fail(deferred.reject);\n\n      cancellablePromises.push(new CancellablePromise(request, request));\n    };\n\n    waitForAvailable();\n    return new CancellablePromise(deferred, undefined, cancellablePromises);\n  }\n\n  /**\n   *\n   * @param {ExecutableStatement} executable\n   *\n   * @return {{snippet: string, notebook: string}}\n   */\n  static adaptExecutableToNotebook(executable) {\n    const statement = executable.getStatement();\n    const snippet = {\n      type: executable.sourceType,\n      result: {\n        handle: executable.handle\n      },\n      status: executable.status,\n      id: executable.snippetId || hueUtils.UUID(),\n      statement_raw: statement,\n      statement: statement,\n      variables: [],\n      compute: executable.compute,\n      database: executable.database,\n      properties: { settings: [] }\n    };\n\n    const notebook = {\n      type: executable.sourceType,\n      snippets: [snippet],\n      id: executable.notebookId,\n      name: '',\n      isSaved: false,\n      sessions: executable.sessions || []\n    };\n\n    return {\n      snippet: JSON.stringify(snippet),\n      notebook: JSON.stringify(notebook)\n    };\n  }\n\n  /**\n   * @typedef {Object} ExecutionHandle\n   * @property {string} guid\n   * @property {boolean} has_more_statements\n   * @property {boolean} has_result_set\n   * @property {Object} log_context\n   * @property {number} modified_row_count\n   * @property {number} operation_type\n   * @property {string} previous_statement_hash\n   * @property {string} secret\n   * @property {string} session_guid\n   * @property {string} statement\n   * @property {number} statement_id\n   * @property {number} statements_count\n   */\n\n  /**\n   * API function to execute an ExecutableStatement\n   *\n   * @param {Object} options\n   * @param {boolean} [options.silenceErrors]\n   * @param {ExecutableStatement} options.executable\n   *\n   * @return {Promise<ExecutionHandle>}\n   */\n  executeStatement(options) {\n    const executable = options.executable;\n    const url = EXECUTE_API_PREFIX + executable.sourceType;\n    const deferred = $.Deferred();\n\n    this.simplePost(url, ApiHelper.adaptExecutableToNotebook(executable), options)\n      .done(response => {\n        if (response.handle) {\n          deferred.resolve(response.handle);\n        } else {\n          deferred.reject('No handle in execute response');\n        }\n      })\n      .fail(deferred.reject);\n\n    const promise = deferred.promise();\n\n    promise.cancel = () => {\n      const cancelDeferred = $.Deferred();\n      deferred\n        .done(handle => {\n          if (options.executable.handle !== handle) {\n            options.executable.handle = handle;\n          }\n          this.cancelStatement(options).always(cancelDeferred.resolve);\n        })\n        .fail(cancelDeferred.resolve);\n      return cancelDeferred;\n    };\n\n    return promise;\n  }\n\n  /**\n   *\n   * @param {Object} options\n   * @param {boolean} [options.silenceErrors]\n   * @param {ExecutableStatement} options.executable\n   *\n   * @return {CancellablePromise<string>}\n   */\n  checkExecutionStatus(options) {\n    const deferred = $.Deferred();\n\n    const request = this.simplePost(\n      '/notebook/api/check_status',\n      ApiHelper.adaptExecutableToNotebook(options.executable),\n      options\n    )\n      .done(response => {\n        deferred.resolve(response.query_status.status);\n      })\n      .fail(deferred.reject);\n\n    return new CancellablePromise(deferred, request);\n  }\n\n  /**\n   *\n   * @param {Object} options\n   * @param {boolean} [options.silenceErrors]\n   * @param {ExecutableStatement} options.executable\n   *\n   * @return {Promise}\n   */\n  cancelStatement(options) {\n    return this.simplePost(\n      '/notebook/api/cancel_statement',\n      ApiHelper.adaptExecutableToNotebook(options.executable),\n      options\n    );\n  }\n\n  /**\n   * @typedef {Object} ResultResponseMeta\n   * @property {string} comment\n   * @property {string} name\n   * @property {string} type\n   */\n\n  /**\n   * @typedef {Object} ResultResponse\n   * @property {Object[]} data\n   * @property {boolean} has_more\n   * @property {boolean} isEscaped\n   * @property {ResultResponseMeta[]} meta\n   * @property {string} type\n   */\n\n  /**\n   *\n   * @param {Object} options\n   * @param {boolean} [options.silenceErrors]\n   * @param {ExecutableStatement} options.executable\n   * @param {number} options.rows\n   * @param {boolean} options.startOver\n   *\n   * @return {Promise<ResultResponse>}\n   */\n  async fetchResults(options) {\n    return new Promise((resolve, reject) => {\n      const data = ApiHelper.adaptExecutableToNotebook(options.executable);\n      data.rows = options.rows;\n      data.startOver = !!options.startOver;\n\n      this.simplePost(\n        '/notebook/api/fetch_result_data',\n        data,\n        {\n          silenceErrors: options.silenceErrors,\n          dataType: 'text'\n        },\n        options\n      )\n        .done(response => {\n          const data = JSON.bigdataParse(response);\n          resolve(data.result);\n        })\n        .fail(reject);\n    });\n  }\n\n  /**\n   *\n   * @param {Object} options\n   * @param {boolean} [options.silenceErrors]\n   * @param {ExecutableStatement} options.executable\n   *\n   * @return {Promise<ResultResponse>}\n   */\n  async fetchResultSize(options) {\n    return new Promise((resolve, reject) => {\n      this.simplePost(\n        '/notebook/api/fetch_result_size',\n        ApiHelper.adaptExecutableToNotebook(options.executable),\n        options\n      )\n        .done(response => {\n          resolve(response.result);\n        })\n        .fail(reject);\n    });\n  }\n\n  /**\n   *\n   * @param {Object} options\n   * @param {boolean} [options.silenceErrors]\n   * @param {ExecutableStatement} options.executable\n   *\n   * @return {Promise}\n   */\n  closeStatement(options) {\n    const executable = options.executable;\n\n    return this.simplePost(\n      '/notebook/api/close_statement',\n      ApiHelper.adaptExecutableToNotebook({\n        sourceType: executable.sourceType,\n        handle: executable.handle\n      }),\n      options\n    );\n  }\n\n  /**\n   * Fetches samples for the given source and path\n   *\n   * @param {Object} options\n   * @param {boolean} [options.silenceErrors]\n   *\n   * @param {string} options.sourceType\n   * @param {ContextCompute} options.compute\n   * @param {number} [options.sampleCount] - Default 100\n   * @param {string[]} options.path\n   * @param {string} [options.operation] - Default 'default'\n   *\n   * @return {CancellablePromise}\n   */\n  fetchSample(options) {\n    const self = this;\n    const deferred = $.Deferred();\n\n    const cancellablePromises = [];\n\n    let notebookJson = null;\n    let snippetJson = null;\n\n    const cancelQuery = function() {\n      if (notebookJson) {\n        self.simplePost(\n          '/notebook/api/cancel_statement',\n          {\n            notebook: notebookJson,\n            snippet: snippetJson,\n            cluster: ko.mapping.toJSON(options.compute ? options.compute : '\"\"')\n          },\n          { silenceErrors: options.silenceErrors }\n        );\n      }\n    };\n\n    self\n      .simplePost(\n        SAMPLE_API_PREFIX + options.path.join('/'),\n        {\n          notebook: {},\n          snippet: JSON.stringify({\n            type: options.sourceType,\n            compute: options.compute\n          }),\n          async: true,\n          operation: '\"' + (options.operation || 'default') + '\"',\n          cluster: ko.mapping.toJSON(options.compute ? options.compute : '\"\"')\n        },\n        {\n          silenceErrors: options.silenceErrors\n        }\n      )\n      .done(sampleResponse => {\n        const queryResult = new QueryResult(options.sourceType, options.compute, sampleResponse);\n\n        notebookJson = JSON.stringify({ type: options.sourceType });\n        snippetJson = JSON.stringify(queryResult);\n\n        if (sampleResponse && sampleResponse.rows) {\n          // Sync results\n          const data = { data: sampleResponse.rows, meta: sampleResponse.full_headers };\n          data.hueTimestamp = Date.now();\n          deferred.resolve(data);\n        } else {\n          cancellablePromises.push(\n            self\n              .whenAvailable({\n                notebookJson: notebookJson,\n                snippetJson: snippetJson,\n                compute: options.compute,\n                silenceErrors: options.silenceErrors\n              })\n              .done(() => {\n                const resultRequest = self\n                  .simplePost(\n                    '/notebook/api/fetch_result_data',\n                    {\n                      notebook: notebookJson,\n                      snippet: snippetJson,\n                      rows: options.sampleCount || 100,\n                      startOver: 'false'\n                    },\n                    {\n                      silenceErrors: options.silenceErrors\n                    }\n                  )\n                  .done(sampleResponse => {\n                    const data = (sampleResponse && sampleResponse.result) || {\n                      data: [],\n                      meta: []\n                    };\n                    data.hueTimestamp = Date.now();\n                    deferred.resolve(data);\n                  })\n                  .fail(deferred.reject);\n\n                cancellablePromises.push(resultRequest, resultRequest);\n              })\n              .fail(deferred.reject)\n          );\n        }\n      })\n      .fail(deferred.reject);\n\n    cancellablePromises.push({\n      cancel: cancelQuery\n    });\n\n    return new CancellablePromise(deferred, undefined, cancellablePromises);\n  }\n\n  /**\n   * Fetches a navigator entity for the given source and path\n   *\n   * @param {Object} options\n   * @param {boolean} [options.silenceErrors]\n   *\n   * @param {boolean} [options.isView] - Default false\n   * @param {string[]} options.path\n   *\n   * @return {CancellablePromise}\n   */\n  fetchNavigatorMetadata(options) {\n    const self = this;\n    const deferred = $.Deferred();\n    let url = NAV_URLS.FIND_ENTITY;\n\n    if (options.path.length === 1) {\n      url += '?type=database&name=' + options.path[0];\n    } else if (options.path.length === 2) {\n      url +=\n        (options.isView ? '?type=view' : '?type=table') +\n        '&database=' +\n        options.path[0] +\n        '&name=' +\n        options.path[1];\n    } else if (options.path.length === 3) {\n      url +=\n        '?type=field&database=' +\n        options.path[0] +\n        '&table=' +\n        options.path[1] +\n        '&name=' +\n        options.path[2];\n    } else {\n      return new CancellablePromise($.Deferred().reject());\n    }\n\n    const request = self.simplePost(\n      url,\n      {\n        notebook: {},\n        snippet: ko.mapping.toJSON({\n          type: 'nav'\n        })\n      },\n      {\n        silenceErrors: options.silenceErrors,\n        successCallback: function(data) {\n          data = data.entity || data;\n          data.hueTimestamp = Date.now();\n          deferred.resolve(data);\n        },\n        errorCallback: deferred.reject\n      }\n    );\n\n    return new CancellablePromise(deferred, request);\n  }\n\n  /**\n   * Updates Navigator properties and custom metadata for the given entity\n   *\n   * @param {Object} options\n   * @param {string} options.identity - The identifier for the Navigator entity to update\n   * @param {Object} [options.properties]\n   * @param {Object} [options.modifiedCustomMetadata]\n   * @param {string[]} [options.deletedCustomMetadataKeys]\n   * @param {boolean} [options.silenceErrors]\n   *\n   * @return {Promise}\n   */\n  updateNavigatorProperties(options) {\n    const self = this;\n    const data = { id: ko.mapping.toJSON(options.identity) };\n\n    if (options.properties) {\n      data.properties = ko.mapping.toJSON(options.properties);\n    }\n    if (options.modifiedCustomMetadata) {\n      data.modifiedCustomMetadata = ko.mapping.toJSON(options.modifiedCustomMetadata);\n    }\n    if (options.deletedCustomMetadataKeys) {\n      data.deletedCustomMetadataKeys = ko.mapping.toJSON(options.deletedCustomMetadataKeys);\n    }\n    return self.simplePost(NAV_URLS.UPDATE_PROPERTIES, data, options);\n  }\n\n  /**\n   * Lists all available navigator tags\n   *\n   * @param {Object} options\n   * @param {boolean} [options.silenceErrors]\n   *\n   * @return {CancellablePromise}\n   */\n  fetchAllNavigatorTags(options) {\n    const self = this;\n\n    const deferred = $.Deferred();\n\n    const request = self.simplePost(NAV_URLS.LIST_TAGS, undefined, {\n      silenceErrors: options.silenceErrors,\n      successCallback: function(data) {\n        if (data && data.tags) {\n          deferred.resolve(data.tags);\n        } else {\n          deferred.resolve({});\n        }\n      },\n      errorCallback: deferred.reject\n    });\n\n    return new CancellablePromise(deferred, request);\n  }\n\n  addNavTags(entityId, tags) {\n    const self = this;\n    return self.simplePost(NAV_URLS.ADD_TAGS, {\n      id: ko.mapping.toJSON(entityId),\n      tags: ko.mapping.toJSON(tags)\n    });\n  }\n\n  deleteNavTags(entityId, tags) {\n    const self = this;\n    return self.simplePost(NAV_URLS.DELETE_TAGS, {\n      id: ko.mapping.toJSON(entityId),\n      tags: ko.mapping.toJSON(tags)\n    });\n  }\n\n  /**\n   * Fetches navOpt popularity for the children of the given path\n   *\n   * @param {Object} options\n   * @param {boolean} [options.silenceErrors]\n   * @param {string[][]} options.paths\n   * @return {CancellablePromise}\n   */\n  fetchNavOptPopularity(options) {\n    const self = this;\n    const deferred = $.Deferred();\n    let url, data;\n\n    if (options.paths.length === 1 && options.paths[0].length === 1) {\n      url = NAV_OPT_URLS.TOP_TABLES;\n      data = {\n        database: options.paths[0][0]\n      };\n    } else {\n      url = NAV_OPT_URLS.TOP_COLUMNS;\n      const dbTables = [];\n      options.paths.forEach(path => {\n        dbTables.push(path.join('.'));\n      });\n      data = {\n        dbTables: ko.mapping.toJSON(dbTables)\n      };\n    }\n\n    const request = self.simplePost(url, data, {\n      silenceErrors: options.silenceErrors,\n      successCallback: function(data) {\n        data.hueTimestamp = Date.now();\n        deferred.resolve(data);\n      },\n      errorCallback: deferred.reject\n    });\n\n    return new CancellablePromise(deferred, request);\n  }\n\n  /**\n   * Fetches the popular aggregate functions for the given tables\n   *\n   * @param {Object} options\n   * @param {boolean} [options.silenceErrors]\n   * @param {string[][]} options.paths\n   * @return {CancellablePromise}\n   */\n  fetchNavOptTopAggs(options) {\n    return genericNavOptMultiTableFetch(this, options, NAV_OPT_URLS.TOP_AGGS);\n  }\n\n  /**\n   * Fetches the popular columns for the given tables\n   *\n   * @param {Object} options\n   * @param {boolean} [options.silenceErrors]\n   * @param {string[][]} options.paths\n   * @return {CancellablePromise}\n   */\n  fetchNavOptTopColumns(options) {\n    return genericNavOptMultiTableFetch(this, options, NAV_OPT_URLS.TOP_COLUMNS);\n  }\n\n  /**\n   * Fetches the popular filters for the given tables\n   *\n   * @param {Object} options\n   * @param {boolean} [options.silenceErrors]\n   * @param {string[][]} options.paths\n   * @return {CancellablePromise}\n   */\n  fetchNavOptTopFilters(options) {\n    return genericNavOptMultiTableFetch(this, options, NAV_OPT_URLS.TOP_FILTERS);\n  }\n\n  /**\n   * Fetches the popular joins for the given tables\n   *\n   * @param {Object} options\n   * @param {boolean} [options.silenceErrors]\n   * @param {string[][]} options.paths\n   * @return {CancellablePromise}\n   */\n  fetchNavOptTopJoins(options) {\n    return genericNavOptMultiTableFetch(this, options, NAV_OPT_URLS.TOP_JOINS);\n  }\n\n  /**\n   * Fetches navOpt meta for the given path, only possible for tables atm.\n   *\n   * @param {Object} options\n   * @param {boolean} [options.silenceErrors]\n   * @param {string[]} options.path\n   *\n   * @return {CancellablePromise}\n   */\n  fetchNavOptMeta(options) {\n    const self = this;\n    const deferred = $.Deferred();\n\n    const request = self.simplePost(\n      NAV_OPT_URLS.TABLE_DETAILS,\n      {\n        databaseName: options.path[0],\n        tableName: options.path[1]\n      },\n      {\n        silenceErrors: options.silenceErrors,\n        successCallback: function(response) {\n          if (response.status === 0 && response.details) {\n            response.details.hueTimestamp = Date.now();\n            deferred.resolve(response.details);\n          } else {\n            deferred.reject();\n          }\n        },\n        errorCallback: deferred.reject\n      }\n    );\n\n    return new CancellablePromise(deferred, request);\n  }\n\n  /**\n   * @param {Object} options\n   * @param {boolean} [options.silenceErrors]\n   * @param {ContextCompute} options.compute\n   * @param {string} options.queryId\n   * @return {CancellablePromise}\n   */\n  fetchQueryExecutionAnalysis(options) {\n    const self = this;\n    //var url = '/metadata/api/workload_analytics/get_impala_query/';\n    const url = '/impala/api/query/alanize';\n    const deferred = $.Deferred();\n\n    let tries = 0;\n\n    const cancellablePromises = [];\n\n    const promise = new CancellablePromise(deferred, undefined, cancellablePromises);\n\n    const pollForAnalysis = () => {\n      if (tries === 10) {\n        deferred.reject();\n        return;\n      }\n      tries++;\n      cancellablePromises.pop(); // Remove the last one\n      cancellablePromises.push(\n        deferred,\n        self\n          .simplePost(\n            url,\n            {\n              cluster: JSON.stringify(options.compute),\n              query_id: '\"' + options.queryId + '\"'\n            },\n            options\n          )\n          .done(response => {\n            if (response && response.data) {\n              deferred.resolve(response.data);\n            } else {\n              const timeout = window.setTimeout(() => {\n                pollForAnalysis();\n              }, 1000 + tries * 500); // TODO: Adjust once fully implemented;\n              promise.onCancel(() => {\n                window.clearTimeout(timeout);\n              });\n            }\n          })\n          .fail(deferred.reject)\n      );\n    };\n\n    pollForAnalysis();\n\n    return promise;\n  }\n\n  fixQueryExecutionAnalysis(options) {\n    const self = this;\n    const url = '/impala/api/query/alanize/fix';\n    const deferred = $.Deferred();\n\n    const request = self.simplePost(\n      url,\n      {\n        cluster: JSON.stringify(options.compute),\n        fix: JSON.stringify(options.fix),\n        start_time: options.start_time\n      },\n      {\n        silenceErrors: options.silenceErrors,\n        successCallback: function(response) {\n          if (response.status === 0) {\n            deferred.resolve(response.details);\n          } else {\n            deferred.reject();\n          }\n        },\n        errorCallback: deferred.reject\n      }\n    );\n\n    return new CancellablePromise(deferred, request);\n  }\n\n  fetchQueryExecutionStatistics(options) {\n    const self = this;\n    const url = '/impala/api/query/alanize/metrics';\n    const deferred = $.Deferred();\n\n    const request = self.simplePost(\n      url,\n      {\n        cluster: JSON.stringify(options.cluster),\n        query_id: '\"' + options.queryId + '\"'\n      },\n      {\n        silenceErrors: options.silenceErrors,\n        successCallback: function(response) {\n          if (response.status === 0) {\n            deferred.resolve(response.data);\n          } else {\n            deferred.reject();\n          }\n        },\n        errorCallback: deferred.reject\n      }\n    );\n\n    return new CancellablePromise(deferred, request);\n  }\n\n  /**\n   * @param {Object} options\n   * @param {boolean} [options.silenceErrors]\n   * @param {string} options.sourceType\n   * @return {Promise}\n   */\n  fetchContextNamespaces(options) {\n    const self = this;\n    const url = '/desktop/api2/context/namespaces/' + options.sourceType;\n    return self.simpleGet(url, undefined, options);\n  }\n\n  /**\n   * @param {Object} options\n   * @param {boolean} [options.silenceErrors]\n   * @param {string} options.sourceType\n   * @return {Promise}\n   */\n  fetchContextComputes(options) {\n    const self = this;\n    const url = '/desktop/api2/context/computes/' + options.sourceType;\n    return self.simpleGet(url, undefined, options);\n  }\n\n  /**\n   * @param {Object} options\n   * @param {boolean} [options.silenceErrors]\n   * @param {string} options.sourceType\n   * @return {Promise}\n   */\n  fetchContextClusters(options) {\n    const self = this;\n    const url = '/desktop/api2/context/clusters/' + options.sourceType;\n    return self.simpleGet(url, undefined, options);\n  }\n\n  getClusterConfig(data) {\n    return $.post(FETCH_CONFIG, data);\n  }\n\n  fetchHueDocsInteractive(query) {\n    const deferred = $.Deferred();\n    const request = $.post(INTERACTIVE_SEARCH_API, {\n      query_s: ko.mapping.toJSON(query),\n      limit: 50,\n      sources: '[\"documents\"]'\n    })\n      .done(data => {\n        if (data.status === 0) {\n          deferred.resolve(data);\n        } else {\n          deferred.reject(data);\n        }\n      })\n      .fail(deferred.reject);\n    return new CancellablePromise(deferred, request);\n  }\n\n  fetchNavEntitiesInteractive(options) {\n    const deferred = $.Deferred();\n    const request = $.post(INTERACTIVE_SEARCH_API, {\n      query_s: ko.mapping.toJSON(options.query),\n      field_facets: ko.mapping.toJSON(options.facets || []),\n      limit: 50,\n      sources: '[\"sql\", \"hdfs\", \"s3\"]'\n    })\n      .done(data => {\n        if (data.status === 0) {\n          deferred.resolve(data);\n        } else {\n          deferred.reject(data);\n        }\n      })\n      .fail(deferred.reject);\n    return new CancellablePromise(deferred, request);\n  }\n\n  searchEntities(options) {\n    const self = this;\n    const deferred = $.Deferred();\n\n    const request = self.simplePost(\n      SEARCH_API,\n      {\n        query_s: ko.mapping.toJSON(options.query),\n        limit: options.limit || 100,\n        raw_query: !!options.rawQuery,\n        sources: options.sources ? ko.mapping.toJSON(options.sources) : '[\"sql\"]'\n      },\n      {\n        silenceErrors: options.silenceErrors,\n        successCallback: deferred.resolve,\n        errorCallback: deferred.reject\n      }\n    );\n\n    return new CancellablePromise(deferred, request);\n  }\n\n  /**\n   *\n   * @param {Object} options\n   * @param {string} options.statements\n   * @param {boolean} [options.silenceErrors]\n   */\n  formatSql(options) {\n    const self = this;\n    const deferred = $.Deferred();\n\n    const request = self.simplePost(\n      FORMAT_SQL_API,\n      {\n        statements: options.statements\n      },\n      {\n        silenceErrors: options.silenceErrors,\n        successCallback: deferred.resolve,\n        errorCallback: deferred.reject\n      }\n    );\n\n    return new CancellablePromise(deferred, request);\n  }\n}\n\nconst apiHelper = new ApiHelper();\n\nexport default apiHelper;\n","// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nclass ApiQueueManager {\n  constructor() {\n    const self = this;\n    self.callQueue = {};\n  }\n\n  getQueued(url, hash) {\n    const self = this;\n    return self.callQueue[url + (hash || '')];\n  }\n\n  addToQueue(promise, url, hash) {\n    const self = this;\n    self.callQueue[url + (hash || '')] = promise;\n    promise.always(() => {\n      delete self.callQueue[url + (hash || '')];\n    });\n  }\n}\n\nconst apiQueueManager = new ApiQueueManager();\n\nexport default apiQueueManager;\n","// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport $ from 'jquery';\nimport apiHelper from 'api/apiHelper';\n\nclass CancellablePromise {\n  constructor(deferred, request, otherCancellables) {\n    const self = this;\n    self.cancelCallbacks = [];\n    self.deferred = deferred;\n    self.request = request;\n    self.otherCancellables = otherCancellables;\n    self.cancelled = false;\n    self.cancelPrevented = false;\n  }\n\n  /**\n   * A promise might be shared across multiple components in the UI, in some cases cancel is not an option and calling\n   * this will prevent that to happen.\n   *\n   * One example is autocompletion of databases while the assist is loading the database tree, closing the autocomplete\n   * results would make the assist loading fail if cancel hasn't been prevented.\n   *\n   * @returns {CancellablePromise}\n   */\n  preventCancel() {\n    const self = this;\n    self.cancelPrevented = true;\n    return self;\n  }\n\n  cancel() {\n    const self = this;\n    if (self.cancelPrevented || self.cancelled || self.state() !== 'pending') {\n      return $.Deferred()\n        .resolve()\n        .promise();\n    }\n\n    self.cancelled = true;\n    if (self.request) {\n      apiHelper.cancelActiveRequest(self.request);\n    }\n\n    if (self.state && self.state() === 'pending' && self.deferred.reject) {\n      self.deferred.reject();\n    }\n\n    const cancelPromises = [];\n    if (self.otherCancellables) {\n      self.otherCancellables.forEach(cancellable => {\n        if (cancellable.cancel) {\n          cancelPromises.push(cancellable.cancel());\n        }\n      });\n    }\n\n    while (self.cancelCallbacks.length) {\n      self.cancelCallbacks.pop()();\n    }\n    return $.when(cancelPromises);\n  }\n\n  onCancel(callback) {\n    const self = this;\n    if (self.cancelled) {\n      callback();\n    } else {\n      self.cancelCallbacks.push(callback);\n    }\n    return self;\n  }\n\n  then() {\n    const self = this;\n    self.deferred.then.apply(self.deferred, arguments);\n    return self;\n  }\n\n  done(callback) {\n    const self = this;\n    self.deferred.done.apply(self.deferred, arguments);\n    return self;\n  }\n\n  fail(callback) {\n    const self = this;\n    self.deferred.fail.apply(self.deferred, arguments);\n    return self;\n  }\n\n  always(callback) {\n    const self = this;\n    self.deferred.always.apply(self.deferred, arguments);\n    return self;\n  }\n\n  pipe(callback) {\n    const self = this;\n    self.deferred.pipe.apply(self.deferred, arguments);\n    return self;\n  }\n\n  progress(callback) {\n    const self = this;\n    self.deferred.progress.apply(self.deferred, arguments);\n    return self;\n  }\n\n  state() {\n    const self = this;\n    return self.deferred.state && self.deferred.state();\n  }\n}\n\nexport default CancellablePromise;\n","// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport apiHelper from 'api/apiHelper';\n\n/**\n * Wrapper function around ApiHelper calls, it will also save the entry on success.\n *\n * @param {string} apiHelperFunction - The name of the ApiHelper function to call\n * @param {string} attributeName - The attribute to set\n * @param {DataCatalogEntry|MultiTableEntry} entry - The catalog entry\n * @param {Object} [apiOptions]\n * @param {boolean} [apiOptions.silenceErrors]\n */\nconst fetchAndSave = (apiHelperFunction, attributeName, entry, apiOptions) =>\n  apiHelper[apiHelperFunction]({\n    sourceType: entry.dataCatalog.sourceType,\n    compute: entry.compute,\n    path: entry.path, // Set for DataCatalogEntry\n    paths: entry.paths, // Set for MultiTableEntry\n    silenceErrors: apiOptions && apiOptions.silenceErrors,\n    isView: entry.isView && entry.isView() // MultiTable entries don't have this property\n  }).done(data => {\n    entry[attributeName] = data;\n    entry.saveLater();\n  });\n\n/**\n * Helper function that adds sets the silence errors option to true if not specified\n *\n * @param {Object} [options]\n * @return {Object}\n */\nconst setSilencedErrors = options => {\n  if (!options) {\n    options = {};\n  }\n  if (typeof options.silenceErrors === 'undefined') {\n    options.silenceErrors = true;\n  }\n  return options;\n};\n\n/**\n * Helper function to apply the cancellable option to an existing or new promise\n *\n * @param {CancellablePromise} [promise]\n * @param {Object} [options]\n * @param {boolean} [options.cancellable] - Default false\n *\n * @return {CancellablePromise}\n */\nconst applyCancellable = (promise, options) => {\n  if (promise && promise.preventCancel && (!options || !options.cancellable)) {\n    promise.preventCancel();\n  }\n  return promise;\n};\n\nexport default {\n  applyCancellable: applyCancellable,\n  fetchAndSave: fetchAndSave,\n  setSilencedErrors: setSilencedErrors\n};\n","// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport $ from 'jquery';\nimport localforage from 'localforage';\n\nimport apiHelper from 'api/apiHelper';\nimport CancellablePromise from 'api/cancellablePromise';\nimport catalogUtils from 'catalog/catalogUtils';\nimport DataCatalogEntry from 'catalog/dataCatalogEntry';\nimport GeneralDataCatalog from 'catalog/generalDataCatalog';\nimport MultiTableEntry from 'catalog/multiTableEntry';\n\nconst STORAGE_POSTFIX = window.LOGGED_USERNAME;\nconst DATA_CATALOG_VERSION = 5;\n\nlet cacheEnabled = true;\n\n/**\n * Creates a cache identifier given a namespace and path(s)\n *\n * @param {Object|DataCatalogEntry} options\n * @param {Object} options.namespace\n * @param {string} options.namespace.id\n * @param {string[]} [options.path]\n * @param {string[][]} [options.paths]\n * @return {string}\n */\nconst generateEntryCacheId = function(options) {\n  let id = options.namespace.id;\n  if (options.path) {\n    if (typeof options.path === 'string') {\n      id += '_' + options.path;\n    } else if (options.path.length) {\n      id += '_' + options.path.join('.');\n    }\n  } else if (options.paths && options.paths.length) {\n    const pathSet = {};\n    options.paths.forEach(path => {\n      pathSet[path.join('.')] = true;\n    });\n    const uniquePaths = Object.keys(pathSet);\n    uniquePaths.sort();\n    id += '_' + uniquePaths.join(',');\n  }\n  return id;\n};\n\n/**\n * Helper function to fill a catalog entry with cached metadata.\n *\n * @param {DataCatalogEntry} dataCatalogEntry - The entry to fill\n * @param {Object} storeEntry - The cached version\n */\nconst mergeEntry = function(dataCatalogEntry, storeEntry) {\n  const mergeAttribute = function(attributeName, ttl, promiseName) {\n    if (\n      storeEntry.version === DATA_CATALOG_VERSION &&\n      storeEntry[attributeName] &&\n      (!storeEntry[attributeName].hueTimestamp ||\n        Date.now() - storeEntry[attributeName].hueTimestamp < ttl)\n    ) {\n      dataCatalogEntry[attributeName] = storeEntry[attributeName];\n      if (promiseName) {\n        dataCatalogEntry[promiseName] = $.Deferred()\n          .resolve(dataCatalogEntry[attributeName])\n          .promise();\n      }\n    }\n  };\n\n  mergeAttribute('definition', CACHEABLE_TTL.default);\n  mergeAttribute('sourceMeta', CACHEABLE_TTL.default, 'sourceMetaPromise');\n  mergeAttribute('analysis', CACHEABLE_TTL.default, 'analysisPromise');\n  mergeAttribute('partitions', CACHEABLE_TTL.default, 'partitionsPromise');\n  mergeAttribute('sample', CACHEABLE_TTL.default, 'samplePromise');\n  mergeAttribute('navigatorMeta', CACHEABLE_TTL.default, 'navigatorMetaPromise');\n  mergeAttribute('navOptMeta', CACHEABLE_TTL.optimizer, 'navOptMetaPromise');\n  mergeAttribute('navOptPopularity', CACHEABLE_TTL.optimizer);\n};\n\n/**\n * Helper function to fill a multi table catalog entry with cached metadata.\n *\n * @param {MultiTableEntry} multiTableCatalogEntry - The entry to fill\n * @param {Object} storeEntry - The cached version\n */\nconst mergeMultiTableEntry = function(multiTableCatalogEntry, storeEntry) {\n  const mergeAttribute = function(attributeName, ttl, promiseName) {\n    if (\n      storeEntry.version === DATA_CATALOG_VERSION &&\n      storeEntry[attributeName] &&\n      (!storeEntry[attributeName].hueTimestamp ||\n        Date.now() - storeEntry[attributeName].hueTimestamp < ttl)\n    ) {\n      multiTableCatalogEntry[attributeName] = storeEntry[attributeName];\n      if (promiseName) {\n        multiTableCatalogEntry[promiseName] = $.Deferred()\n          .resolve(multiTableCatalogEntry[attributeName])\n          .promise();\n      }\n    }\n  };\n\n  mergeAttribute('topAggs', CACHEABLE_TTL.optimizer, 'topAggsPromise');\n  mergeAttribute('topColumns', CACHEABLE_TTL.optimizer, 'topColumnsPromise');\n  mergeAttribute('topFilters', CACHEABLE_TTL.optimizer, 'topFiltersPromise');\n  mergeAttribute('topJoins', CACHEABLE_TTL.optimizer, 'topJoinsPromise');\n};\n\nclass DataCatalog {\n  /**\n   * @param {string} sourceType\n   *\n   * @constructor\n   */\n  constructor(sourceType) {\n    const self = this;\n    self.sourceType = sourceType;\n    self.entries = {};\n    self.temporaryEntries = {};\n    self.multiTableEntries = {};\n    self.store = localforage.createInstance({\n      name: 'HueDataCatalog_' + self.sourceType + '_' + STORAGE_POSTFIX\n    });\n    self.multiTableStore = localforage.createInstance({\n      name: 'HueDataCatalog_' + self.sourceType + '_multiTable_' + STORAGE_POSTFIX\n    });\n  }\n\n  /**\n   * Disables the caching for subsequent operations, mainly used for test purposes\n   */\n  static disableCache() {\n    cacheEnabled = false;\n  }\n\n  /**\n   * Enables the cache for subsequent operations, mainly used for test purposes\n   */\n  static enableCache() {\n    cacheEnabled = true;\n  }\n\n  /**\n   * Returns true if the catalog can have NavOpt metadata\n   *\n   * @return {boolean}\n   */\n  canHaveNavOptMetadata() {\n    const self = this;\n    return HAS_OPTIMIZER && (self.sourceType === 'hive' || self.sourceType === 'impala');\n  }\n\n  /**\n   * Clears the data catalog and cache for the given path and any children thereof.\n   *\n   * @param {ContextNamespace} [namespace] - The context namespace\n   * @param {ContextCompute} [compute] - The context compute\n   * @param {string[]} rootPath - The path to clear\n   */\n  clearStorageCascade(namespace, compute, rootPath) {\n    const self = this;\n    const deferred = $.Deferred();\n    if (!namespace || !compute) {\n      if (rootPath.length === 0) {\n        self.entries = {};\n        self.store\n          .clear()\n          .then(deferred.resolve)\n          .catch(deferred.reject);\n        return deferred.promise();\n      }\n      return deferred.reject().promise();\n    }\n\n    const keyPrefix = generateEntryCacheId({ namespace: namespace, path: rootPath });\n    Object.keys(self.entries).forEach(key => {\n      if (key.indexOf(keyPrefix) === 0) {\n        delete self.entries[key];\n      }\n    });\n\n    const deletePromises = [];\n    const keysDeferred = $.Deferred();\n    deletePromises.push(keysDeferred.promise());\n    self.store\n      .keys()\n      .then(keys => {\n        keys.forEach(key => {\n          if (key.indexOf(keyPrefix) === 0) {\n            const deleteDeferred = $.Deferred();\n            deletePromises.push(deleteDeferred.promise());\n            self.store\n              .removeItem(key)\n              .then(deleteDeferred.resolve)\n              .catch(deleteDeferred.reject);\n          }\n        });\n        keysDeferred.resolve();\n      })\n      .catch(keysDeferred.reject);\n\n    return $.when.apply($, deletePromises);\n  }\n\n  /**\n   * Updates the cache for the given entry\n   *\n   * @param {DataCatalogEntry} dataCatalogEntry\n   * @return {Promise}\n   */\n  persistCatalogEntry(dataCatalogEntry) {\n    const self = this;\n    if (!cacheEnabled || CACHEABLE_TTL.default <= 0) {\n      return $.Deferred()\n        .resolve()\n        .promise();\n    }\n    const deferred = $.Deferred();\n\n    const identifier = generateEntryCacheId(dataCatalogEntry);\n\n    self.store\n      .setItem(identifier, {\n        version: DATA_CATALOG_VERSION,\n        definition: dataCatalogEntry.definition,\n        sourceMeta: dataCatalogEntry.sourceMeta,\n        analysis: dataCatalogEntry.analysis,\n        partitions: dataCatalogEntry.partitions,\n        sample: dataCatalogEntry.sample,\n        navigatorMeta: dataCatalogEntry.navigatorMeta,\n        navOptMeta: dataCatalogEntry.navOptMeta,\n        navOptPopularity: dataCatalogEntry.navOptPopularity\n      })\n      .then(deferred.resolve)\n      .catch(deferred.reject);\n\n    return deferred.promise();\n  }\n\n  /**\n   * Loads Navigator Optimizer popularity for multiple tables in one go.\n   *\n   * @param {Object} options\n   * @param {ContextNamespace} options.namespace - The context namespace\n   * @param {ContextCompute} options.compute - The context compute\n   * @param {string[][]} options.paths\n   * @param {boolean} [options.silenceErrors] - Default true\n   * @param {boolean} [options.cancellable] - Default false\n   *\n   * @return {CancellablePromise}\n   */\n  loadNavOptPopularityForTables(options) {\n    const self = this;\n    const deferred = $.Deferred();\n    const cancellablePromises = [];\n    let popularEntries = [];\n    const pathsToLoad = [];\n\n    options = catalogUtils.setSilencedErrors(options);\n\n    const existingPromises = [];\n    options.paths.forEach(path => {\n      const existingDeferred = $.Deferred();\n      self\n        .getEntry({ namespace: options.namespace, compute: options.compute, path: path })\n        .done(tableEntry => {\n          if (tableEntry.navOptPopularityForChildrenPromise) {\n            tableEntry.navOptPopularityForChildrenPromise\n              .done(existingPopularEntries => {\n                popularEntries = popularEntries.concat(existingPopularEntries);\n                existingDeferred.resolve();\n              })\n              .fail(existingDeferred.reject);\n          } else if (tableEntry.definition && tableEntry.definition.navOptLoaded) {\n            cancellablePromises.push(\n              tableEntry\n                .getChildren(options)\n                .done(childEntries => {\n                  childEntries.forEach(childEntry => {\n                    if (childEntry.navOptPopularity) {\n                      popularEntries.push(childEntry);\n                    }\n                  });\n                  existingDeferred.resolve();\n                })\n                .fail(existingDeferred.reject)\n            );\n          } else {\n            pathsToLoad.push(path);\n            existingDeferred.resolve();\n          }\n        })\n        .fail(existingDeferred.reject);\n      existingPromises.push(existingDeferred.promise());\n    });\n\n    $.when.apply($, existingPromises).always(() => {\n      const loadDeferred = $.Deferred();\n      if (pathsToLoad.length) {\n        cancellablePromises.push(\n          apiHelper\n            .fetchNavOptPopularity({\n              silenceErrors: options.silenceErrors,\n              paths: pathsToLoad\n            })\n            .done(data => {\n              const perTable = {};\n\n              const splitNavOptValuesPerTable = function(listName) {\n                if (data.values[listName]) {\n                  data.values[listName].forEach(column => {\n                    let tableMeta = perTable[column.dbName + '.' + column.tableName];\n                    if (!tableMeta) {\n                      tableMeta = { values: [] };\n                      perTable[column.dbName + '.' + column.tableName] = tableMeta;\n                    }\n                    if (!tableMeta.values[listName]) {\n                      tableMeta.values[listName] = [];\n                    }\n                    tableMeta.values[listName].push(column);\n                  });\n                }\n              };\n\n              if (data.values) {\n                splitNavOptValuesPerTable('filterColumns');\n                splitNavOptValuesPerTable('groupbyColumns');\n                splitNavOptValuesPerTable('joinColumns');\n                splitNavOptValuesPerTable('orderbyColumns');\n                splitNavOptValuesPerTable('selectColumns');\n              }\n\n              const tablePromises = [];\n\n              Object.keys(perTable).forEach(path => {\n                const tableDeferred = $.Deferred();\n                self\n                  .getEntry({ namespace: options.namespace, compute: options.compute, path: path })\n                  .done(entry => {\n                    cancellablePromises.push(\n                      entry.trackedPromise(\n                        'navOptPopularityForChildrenPromise',\n                        entry\n                          .applyNavOptResponseToChildren(perTable[path], options)\n                          .done(entries => {\n                            popularEntries = popularEntries.concat(entries);\n                            tableDeferred.resolve();\n                          })\n                          .fail(tableDeferred.resolve)\n                      )\n                    );\n                  })\n                  .fail(tableDeferred.reject);\n                tablePromises.push(tableDeferred.promise());\n              });\n\n              $.when.apply($, tablePromises).always(() => {\n                loadDeferred.resolve();\n              });\n            })\n            .fail(loadDeferred.reject)\n        );\n      } else {\n        loadDeferred.resolve();\n      }\n      loadDeferred.always(() => {\n        $.when\n          .apply($, cancellablePromises)\n          .done(() => {\n            deferred.resolve(popularEntries);\n          })\n          .fail(deferred.reject);\n      });\n    });\n\n    return catalogUtils.applyCancellable(\n      new CancellablePromise(deferred, cancellablePromises),\n      options\n    );\n  }\n\n  /**\n   * @param {Object} options\n   * @param {ContextNamespace} options.namespace - The context namespace\n   * @param {ContextCompute} options.compute - The context compute\n   * @param {string|string[]} options.path\n   * @return {DataCatalogEntry}\n   */\n  getKnownEntry(options) {\n    const self = this;\n    return self.entries[generateEntryCacheId(options)];\n  }\n\n  /**\n   * Adds a temporary table to the data catalog. This would allow autocomplete etc. of tables that haven't\n   * been created yet.\n   *\n   * Calling this returns a handle that allows deletion of any created entries by calling delete() on the handle.\n   *\n   * @param {Object} options\n   * @param {string} options.name\n   * @param {ContextNamespace} options.namespace - The context namespace\n   * @param {ContextCompute} options.compute - The context compute\n   *\n   * @param {Object[]} options.columns\n   * @param {string} options.columns[].name\n   * @param {string} options.columns[].type\n   * @param {Object[][]} options.sample\n   *\n   * @return {Object}\n   */\n  addTemporaryTable(options) {\n    const self = this;\n    const tableDeferred = $.Deferred();\n    const path = ['default', options.name];\n\n    const identifiersToClean = [];\n\n    const addEntryMeta = function(entry, sourceMeta) {\n      entry.sourceMeta = sourceMeta || entry.definition;\n      entry.sourceMetaPromise = $.Deferred()\n        .resolve(entry.sourceMeta)\n        .promise();\n      entry.navigatorMeta = { comment: '' };\n      entry.navigatorMetaPromise = $.Deferred()\n        .resolve(entry.navigatorMeta)\n        .promise();\n      entry.analysis = { is_view: false };\n      entry.analysisPromise = $.Deferred()\n        .resolve(entry.analysis)\n        .promise();\n    };\n\n    let removeTable = function() {}; // noop until actually added\n\n    const sourceIdentifier = generateEntryCacheId({\n      namespace: options.namespace,\n      path: []\n    });\n\n    if (!self.temporaryEntries[sourceIdentifier]) {\n      const sourceDeferred = $.Deferred();\n      self.temporaryEntries[sourceIdentifier] = sourceDeferred.promise();\n      const sourceEntry = new DataCatalogEntry({\n        isTemporary: true,\n        dataCatalog: self,\n        namespace: options.namespace,\n        compute: options.compute,\n        path: [],\n        definition: {\n          index: 0,\n          navOptLoaded: true,\n          type: 'source'\n        }\n      });\n      addEntryMeta(sourceEntry);\n      identifiersToClean.push(sourceIdentifier);\n      sourceEntry.childrenPromise = $.Deferred()\n        .resolve([])\n        .promise();\n      sourceDeferred.resolve(sourceEntry);\n    }\n\n    self.temporaryEntries[sourceIdentifier].done(sourceEntry => {\n      sourceEntry.getChildren().done(existingTemporaryDatabases => {\n        const databaseIdentifier = generateEntryCacheId({\n          namespace: options.namespace,\n          path: ['default']\n        });\n\n        if (!self.temporaryEntries[databaseIdentifier]) {\n          const databaseDeferred = $.Deferred();\n          self.temporaryEntries[databaseIdentifier] = databaseDeferred.promise();\n          const databaseEntry = new DataCatalogEntry({\n            isTemporary: true,\n            dataCatalog: self,\n            namespace: options.namespace,\n            compute: options.compute,\n            path: ['default'],\n            definition: {\n              index: 0,\n              navOptLoaded: true,\n              type: 'database'\n            }\n          });\n          addEntryMeta(databaseEntry);\n          identifiersToClean.push(databaseIdentifier);\n          databaseEntry.childrenPromise = $.Deferred()\n            .resolve([])\n            .promise();\n          databaseDeferred.resolve(databaseEntry);\n          existingTemporaryDatabases.push(databaseEntry);\n        }\n\n        self.temporaryEntries[databaseIdentifier].done(databaseEntry => {\n          databaseEntry.getChildren().done(existingTemporaryTables => {\n            const tableIdentifier = generateEntryCacheId({\n              namespace: options.namespace,\n              path: path\n            });\n            self.temporaryEntries[tableIdentifier] = tableDeferred.promise();\n            identifiersToClean.push(tableIdentifier);\n\n            const tableEntry = new DataCatalogEntry({\n              isTemporary: true,\n              dataCatalog: self,\n              namespace: options.namespace,\n              compute: options.compute,\n              path: path,\n              definition: {\n                comment: '',\n                index: 0,\n                name: options.name,\n                navOptLoaded: true,\n                type: 'table'\n              }\n            });\n            existingTemporaryTables.push(tableEntry);\n            const indexToDelete = existingTemporaryTables.length - 1;\n            removeTable = function() {\n              existingTemporaryTables.splice(indexToDelete, 1);\n            };\n\n            const childrenDeferred = $.Deferred();\n            tableEntry.childrenPromise = childrenDeferred.promise();\n\n            if (options.columns) {\n              const childEntries = [];\n\n              addEntryMeta(tableEntry, {\n                columns: [],\n                extended_columns: [],\n                comment: '',\n                notFound: false,\n                is_view: false\n              });\n\n              tableEntry.sample = {\n                data: options.sample || [],\n                meta: tableEntry.sourceMeta.extended_columns\n              };\n              tableEntry.samplePromise = $.Deferred()\n                .resolve(tableEntry.sample)\n                .promise();\n\n              let index = 0;\n              options.columns.forEach(column => {\n                const columnPath = path.concat(column.name);\n                const columnIdentifier = generateEntryCacheId({\n                  namespace: options.namespace,\n                  path: columnPath\n                });\n\n                const columnDeferred = $.Deferred();\n                self.temporaryEntries[columnIdentifier] = columnDeferred.promise();\n                identifiersToClean.push(columnIdentifier);\n\n                const columnEntry = new DataCatalogEntry({\n                  isTemporary: true,\n                  dataCatalog: self,\n                  namespace: options.namespace,\n                  compute: options.compute,\n                  path: columnPath,\n                  definition: {\n                    comment: '',\n                    index: index++,\n                    name: column.name,\n                    partitionKey: false,\n                    type: column.type\n                  }\n                });\n\n                columnEntry.sample = {\n                  data: [],\n                  meta: column\n                };\n                if (options.sample) {\n                  options.sample.forEach(sampleRow => {\n                    columnEntry.sample.data.push([sampleRow[index - 1]]);\n                  });\n                }\n                columnEntry.samplePromise = $.Deferred()\n                  .resolve(columnEntry.sample)\n                  .promise();\n\n                tableEntry.sourceMeta.columns.push(column.name);\n                tableEntry.sourceMeta.extended_columns.push(columnEntry.definition);\n                columnDeferred.resolve(columnEntry);\n                addEntryMeta(columnEntry, {\n                  comment: '',\n                  name: column.name,\n                  notFount: false,\n                  sample: [],\n                  type: column.type\n                });\n\n                childEntries.push(columnEntry);\n              });\n              childrenDeferred.resolve(childEntries);\n            } else {\n              childrenDeferred.resolve([]);\n            }\n\n            tableDeferred.resolve(tableEntry);\n          });\n        });\n      });\n    });\n\n    return {\n      delete: function() {\n        removeTable();\n        while (identifiersToClean.length) {\n          delete self.entries[identifiersToClean.pop()];\n        }\n      }\n    };\n  }\n\n  /**\n   * @param {Object} options\n   * @param {string|string[]} options.path\n   * @param {ContextNamespace} options.namespace - The context namespace\n   * @param {ContextCompute} options.compute - The context compute\n   * @param {Object} [options.definition] - The initial definition if not already set on the entry\n   * @param {boolean} [options.cachedOnly] - Default: false\n   * @param {boolean} [options.temporaryOnly] - Default: false\n   * // @param {Session} [options.session]\n   * @return {Promise}\n   */\n  getEntry(options) {\n    const self = this;\n    const identifier = generateEntryCacheId(options);\n    if (options.temporaryOnly) {\n      return (\n        self.temporaryEntries[identifier] ||\n        $.Deferred()\n          .reject()\n          .promise()\n      );\n    }\n    if (self.entries[identifier]) {\n      return self.entries[identifier];\n    }\n\n    const deferred = $.Deferred();\n    self.entries[identifier] = deferred.promise();\n\n    if (!cacheEnabled) {\n      deferred\n        .resolve(\n          new DataCatalogEntry({\n            dataCatalog: self,\n            namespace: options.namespace,\n            compute: options.compute,\n            path: options.path,\n            definition: options.definition\n          })\n        )\n        .promise();\n    } else {\n      self.store\n        .getItem(identifier)\n        .then(storeEntry => {\n          const definition = storeEntry ? storeEntry.definition : options.definition;\n          const entry = new DataCatalogEntry({\n            dataCatalog: self,\n            namespace: options.namespace,\n            compute: options.compute,\n            path: options.path,\n            definition: definition\n          });\n          if (storeEntry) {\n            mergeEntry(entry, storeEntry);\n          } else if (!options.cachedOnly && options.definition) {\n            entry.saveLater();\n          }\n          deferred.resolve(entry);\n        })\n        .catch(error => {\n          console.warn(error);\n          const entry = new DataCatalogEntry({\n            dataCatalog: self,\n            namespace: options.namespace,\n            compute: options.compute,\n            path: options.path,\n            definition: options.definition\n          });\n          if (!options.cachedOnly && options.definition) {\n            entry.saveLater();\n          }\n          deferred.resolve(entry);\n        });\n    }\n\n    return self.entries[identifier];\n  }\n\n  /**\n   *\n   * @param {Object} options\n   * @param {ContextNamespace} options.namespace - The context namespace\n   * @param {ContextCompute} options.compute - The context compute\n   * @param {string[][]} options.paths\n   *\n   * @return {Promise}\n   */\n  getMultiTableEntry(options) {\n    const self = this;\n    const identifier = generateEntryCacheId(options);\n    if (self.multiTableEntries[identifier]) {\n      return self.multiTableEntries[identifier];\n    }\n\n    const deferred = $.Deferred();\n    self.multiTableEntries[identifier] = deferred.promise();\n\n    if (!cacheEnabled) {\n      deferred\n        .resolve(\n          new MultiTableEntry({ identifier: identifier, dataCatalog: self, paths: options.paths })\n        )\n        .promise();\n    } else {\n      self.multiTableStore\n        .getItem(identifier)\n        .then(storeEntry => {\n          const entry = new MultiTableEntry({\n            identifier: identifier,\n            dataCatalog: self,\n            paths: options.paths\n          });\n          if (storeEntry) {\n            mergeMultiTableEntry(entry, storeEntry);\n          }\n          deferred.resolve(entry);\n        })\n        .catch(error => {\n          console.warn(error);\n          deferred.resolve(\n            new MultiTableEntry({ identifier: identifier, dataCatalog: self, paths: options.paths })\n          );\n        });\n    }\n\n    return self.multiTableEntries[identifier];\n  }\n\n  /**\n   * Updates the cache for the given multi tableentry\n   *\n   * @param {MultiTableEntry} multiTableEntry\n   * @return {Promise}\n   */\n  persistMultiTableEntry(multiTableEntry) {\n    const self = this;\n    if (!cacheEnabled || CACHEABLE_TTL.default <= 0 || CACHEABLE_TTL.optimizer <= 0) {\n      return $.Deferred()\n        .resolve()\n        .promise();\n    }\n    const deferred = $.Deferred();\n    self.multiTableStore\n      .setItem(multiTableEntry.identifier, {\n        version: DATA_CATALOG_VERSION,\n        topAggs: multiTableEntry.topAggs,\n        topColumns: multiTableEntry.topColumns,\n        topFilters: multiTableEntry.topFilters,\n        topJoins: multiTableEntry.topJoins\n      })\n      .then(deferred.resolve)\n      .catch(deferred.reject);\n    return deferred.promise();\n  }\n}\n\nconst generalDataCatalog = new GeneralDataCatalog();\nconst sourceBoundCatalogs = {};\n\n/**\n * Helper function to get the DataCatalog instance for a given data source.\n *\n * @param {string} sourceType\n * @return {DataCatalog}\n */\nconst getCatalog = function(sourceType) {\n  if (!sourceType) {\n    throw new Error('getCatalog called without sourceType');\n  }\n  return (\n    sourceBoundCatalogs[sourceType] ||\n    (sourceBoundCatalogs[sourceType] = new DataCatalog(sourceType))\n  );\n};\n\nexport default {\n  /**\n   * Adds a detached (temporary) entry to the data catalog. This would allow autocomplete etc. of tables that haven't\n   * been created yet.\n   *\n   * Calling this returns a handle that allows deletion of any created entries by calling delete() on the handle.\n   *\n   * @param {Object} options\n   * @param {string} options.sourceType\n   * @param {ContextNamespace} options.namespace - The context namespace\n   * @param {ContextCompute} options.compute - The context compute\n   * @param {string} options.name\n   *\n   * @param {Object[]} options.columns\n   * @param {string} options.columns[].name\n   * @param {string} options.columns[].type\n   * @param {Object[][]} options.sample\n   *\n   * @return {Object}\n   */\n  addTemporaryTable: function(options) {\n    return getCatalog(options.sourceType).addTemporaryTable(options);\n  },\n\n  /**\n   * @param {Object} options\n   * @param {string} options.sourceType\n   * @param {ContextNamespace} options.namespace - The context namespace\n   * @param {ContextCompute} options.compute - The context compute\n   * @param {string|string[]} options.path\n   * @param {Object} [options.definition] - Optional initial definition\n   * @param {boolean} [options.temporaryOnly] - Default: false\n   *\n   * @return {Promise}\n   */\n  getEntry: function(options) {\n    return getCatalog(options.sourceType).getEntry(options);\n  },\n\n  /**\n   * @param {Object} options\n   * @param {string} options.sourceType\n   * @param {ContextNamespace} options.namespace - The context namespace\n   * @param {ContextCompute} options.compute - The context compute\n   * @param {string[][]} options.paths\n   *\n   * @return {Promise}\n   */\n  getMultiTableEntry: function(options) {\n    return getCatalog(options.sourceType).getMultiTableEntry(options);\n  },\n\n  /**\n   * This can be used as a shorthand function to get the child entries of the given path. Same as first calling\n   * getEntry then getChildren.\n   *\n   * @param {Object} options\n   * @param {string} options.sourceType\n   * @param {ContextNamespace} options.namespace - The context namespace\n   * @param {ContextCompute} options.compute - The context compute\n   * @param {string|string[]} options.path\n   * @param {Object} [options.definition] - Optional initial definition of the parent entry\n   * @param {boolean} [options.silenceErrors]\n   * @param {boolean} [options.cachedOnly]\n   * @param {boolean} [options.refreshCache]\n   * @param {boolean} [options.cancellable] - Default false\n   *\n   * @return {CancellablePromise}\n   */\n  getChildren: function(options) {\n    const deferred = $.Deferred();\n    const cancellablePromises = [];\n    getCatalog(options.sourceType)\n      .getEntry(options)\n      .done(entry => {\n        cancellablePromises.push(\n          entry\n            .getChildren(options)\n            .done(deferred.resolve)\n            .fail(deferred.reject)\n        );\n      })\n      .fail(deferred.reject);\n    return new CancellablePromise(deferred, undefined, cancellablePromises);\n  },\n\n  /**\n   * @param {string} sourceType\n   *\n   * @return {DataCatalog}\n   */\n  getCatalog: getCatalog,\n\n  /**\n   * @param {Object} [options]\n   * @param {boolean} [options.silenceErrors]\n   * @param {boolean} [options.refreshCache]\n   *\n   * @return {Promise}\n   */\n  getAllNavigatorTags: generalDataCatalog.getAllNavigatorTags.bind(generalDataCatalog),\n\n  /**\n   * @param {string[]} tagsToAdd\n   * @param {string[]} tagsToRemove\n   */\n  updateAllNavigatorTags: generalDataCatalog.updateAllNavigatorTags.bind(generalDataCatalog),\n\n  enableCache: function() {\n    cacheEnabled = true;\n  },\n\n  disableCache: function() {\n    cacheEnabled = false;\n  },\n\n  applyCancellable: catalogUtils.applyCancellable\n};\n","// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport $ from 'jquery';\nimport ko from 'knockout';\n\nimport apiHelper from 'api/apiHelper';\nimport CancellablePromise from 'api/cancellablePromise';\nimport catalogUtils from 'catalog/catalogUtils';\nimport huePubSub from 'utils/huePubSub';\n\n/**\n * Helper function to reload the source meta for the given entry\n *\n * @param {DataCatalogEntry} dataCatalogEntry\n * @param {Object} [options]\n * @param {boolean} [options.silenceErrors]\n *\n * @return {CancellablePromise}\n */\nconst reloadSourceMeta = function(dataCatalogEntry, options) {\n  if (dataCatalogEntry.dataCatalog.invalidatePromise) {\n    const deferred = $.Deferred();\n    const cancellablePromises = [];\n    dataCatalogEntry.dataCatalog.invalidatePromise.always(() => {\n      cancellablePromises.push(\n        catalogUtils\n          .fetchAndSave('fetchSourceMetadata', 'sourceMeta', dataCatalogEntry, options)\n          .done(deferred.resolve)\n          .fail(deferred.reject)\n      );\n    });\n    return dataCatalogEntry.trackedPromise(\n      'sourceMetaPromise',\n      new CancellablePromise(deferred, undefined, cancellablePromises)\n    );\n  }\n\n  return dataCatalogEntry.trackedPromise(\n    'sourceMetaPromise',\n    catalogUtils.fetchAndSave('fetchSourceMetadata', 'sourceMeta', dataCatalogEntry, options)\n  );\n};\n\n/**\n * Helper function to reload the navigator meta for the given entry\n *\n * @param {DataCatalogEntry} dataCatalogEntry\n * @param {Object} [apiOptions]\n * @param {boolean} [apiOptions.silenceErrors] - Default true\n *\n * @return {CancellablePromise}\n */\nconst reloadNavigatorMeta = function(dataCatalogEntry, apiOptions) {\n  if (dataCatalogEntry.canHaveNavigatorMetadata()) {\n    return dataCatalogEntry\n      .trackedPromise(\n        'navigatorMetaPromise',\n        catalogUtils.fetchAndSave(\n          'fetchNavigatorMetadata',\n          'navigatorMeta',\n          dataCatalogEntry,\n          apiOptions\n        )\n      )\n      .done(navigatorMeta => {\n        if (navigatorMeta && dataCatalogEntry.commentObservable) {\n          dataCatalogEntry.commentObservable(dataCatalogEntry.getResolvedComment());\n        }\n      });\n  }\n  dataCatalogEntry.navigatorMetaPromise = $.Deferred().reject();\n  return dataCatalogEntry.navigatorMetaPromise;\n};\n\n/**\n * Helper function to reload the analysis for the given entry\n *\n * @param {DataCatalogEntry} dataCatalogEntry\n * @param {Object} [apiOptions]\n * @param {boolean} [apiOptions.silenceErrors]\n * @param {boolean} [apiOptions.refreshAnalysis]\n *\n * @return {CancellablePromise}\n */\nconst reloadAnalysis = function(dataCatalogEntry, apiOptions) {\n  return dataCatalogEntry.trackedPromise(\n    'analysisPromise',\n    catalogUtils.fetchAndSave(\n      apiOptions && apiOptions.refreshAnalysis ? 'refreshAnalysis' : 'fetchAnalysis',\n      'analysis',\n      dataCatalogEntry,\n      apiOptions\n    )\n  );\n};\n\n/**\n * Helper function to reload the partitions for the given entry\n *\n * @param {DataCatalogEntry} dataCatalogEntry\n * @param {Object} [apiOptions]\n * @param {boolean} [apiOptions.silenceErrors]\n *\n * @return {CancellablePromise}\n */\nconst reloadPartitions = function(dataCatalogEntry, apiOptions) {\n  return dataCatalogEntry.trackedPromise(\n    'partitionsPromise',\n    catalogUtils.fetchAndSave('fetchPartitions', 'partitions', dataCatalogEntry, apiOptions)\n  );\n};\n\n/**\n * Helper function to reload the sample for the given entry\n *\n * @param {DataCatalogEntry} dataCatalogEntry\n * @param {Object} [apiOptions]\n * @param {boolean} [apiOptions.silenceErrors]\n *\n * @return {CancellablePromise}\n */\nconst reloadSample = function(dataCatalogEntry, apiOptions) {\n  return dataCatalogEntry.trackedPromise(\n    'samplePromise',\n    catalogUtils.fetchAndSave('fetchSample', 'sample', dataCatalogEntry, apiOptions)\n  );\n};\n\n/**\n * Helper function to reload the nav opt metadata for the given entry\n *\n * @param {DataCatalogEntry} dataCatalogEntry\n * @param {Object} [apiOptions]\n * @param {boolean} [apiOptions.silenceErrors] - Default true\n *\n * @return {CancellablePromise}\n */\nconst reloadNavOptMeta = function(dataCatalogEntry, apiOptions) {\n  if (dataCatalogEntry.dataCatalog.canHaveNavOptMetadata()) {\n    return dataCatalogEntry.trackedPromise(\n      'navOptMetaPromise',\n      catalogUtils.fetchAndSave('fetchNavOptMeta', 'navOptMeta', dataCatalogEntry, apiOptions)\n    );\n  }\n  dataCatalogEntry.navOptMetaPromise = $.Deferred.reject().promise();\n  return dataCatalogEntry.navOptMetaPromise;\n};\n\n/**\n * Helper function to get details from the multi-table catalog for just this specific table\n *\n * @param {DataCatalogEntry} catalogEntry\n * @param {Object} [options]\n * @param {boolean} [options.silenceErrors] - Default false\n * @param {boolean} [options.cachedOnly] - Default false\n * @param {boolean} [options.refreshCache] - Default false\n * @param {boolean} [options.cancellable] - Default false\n * @param {string} functionName - The function to call, i.e. 'getTopAggs' etc.\n * @return {CancellablePromise}\n */\nconst getFromMultiTableCatalog = function(catalogEntry, options, functionName) {\n  const deferred = $.Deferred();\n  if (!catalogEntry.isTableOrView()) {\n    return deferred.reject();\n  }\n  const cancellablePromises = [];\n  catalogEntry.dataCatalog\n    .getMultiTableEntry({\n      namespace: catalogEntry.namespace,\n      compute: catalogEntry.compute,\n      paths: [catalogEntry.path]\n    })\n    .done(multiTableEntry => {\n      cancellablePromises.push(\n        multiTableEntry[functionName](options)\n          .done(deferred.resolve)\n          .fail(deferred.reject)\n      );\n    })\n    .fail(deferred.reject);\n  return new CancellablePromise(deferred, undefined, cancellablePromises);\n};\n\n/**\n * @param {DataCatalog} options.dataCatalog\n * @param {string|string[]} options.path\n * @param {ContextNamespace} options.namespace - The context namespace\n * @param {ContextCompute} options.compute - The context compute\n * @param {Object} options.definition - Initial known metadata on creation (normally comes from the parent entry)\n * @param {boolean} [options.isTemporary] - Default false\n *\n * @constructor\n */\nclass DataCatalogEntry {\n  constructor(options) {\n    const self = this;\n\n    self.namespace = options.namespace;\n    self.compute = options.compute;\n    self.dataCatalog = options.dataCatalog;\n    self.path =\n      typeof options.path === 'string' && options.path\n        ? options.path.split('.')\n        : options.path || [];\n    self.name = self.path.length ? self.path[self.path.length - 1] : options.dataCatalog.sourceType;\n    self.isTemporary = options.isTemporary;\n\n    self.definition = options.definition;\n\n    if (!self.definition) {\n      if (self.path.length === 0) {\n        self.definition = { type: 'source' };\n      } else if (self.path.length === 1) {\n        self.definition = { type: 'database' };\n      } else if (self.path.length === 2) {\n        self.definition = { type: 'table' };\n      }\n    }\n\n    self.reset();\n  }\n\n  /**\n   * Resets the entry to an empty state, it might still have some details cached\n   */\n  reset() {\n    const self = this;\n    self.saveTimeout = -1;\n    self.sourceMetaPromise = undefined;\n    self.sourceMeta = undefined;\n\n    self.navigatorMeta = undefined;\n    self.navigatorMetaPromise = undefined;\n\n    self.analysis = undefined;\n    self.analysisPromise = undefined;\n\n    self.partitions = undefined;\n    self.partitionsPromise = undefined;\n\n    self.sample = undefined;\n    self.samplePromise = undefined;\n\n    self.navOptPopularity = undefined;\n    self.navOptMeta = undefined;\n    self.navOptMetaPromise = undefined;\n\n    self.navigatorMetaForChildrenPromise = undefined;\n    self.navOptPopularityForChildrenPromise = undefined;\n\n    self.childrenPromise = undefined;\n\n    if (self.path.length) {\n      const parent = self.dataCatalog.getKnownEntry({\n        namespace: self.namespace,\n        compute: self.compute,\n        path: self.path.slice(0, self.path.length - 1)\n      });\n      if (parent) {\n        parent.navigatorMetaForChildrenPromise = undefined;\n        parent.navOptPopularityForChildrenPromise = undefined;\n      }\n    }\n  }\n\n  /**\n   * Helper function that ensure that cancellable promises are not tracked anymore when cancelled\n   *\n   * @param {string} promiseName - The attribute name to use\n   * @param {CancellablePromise} cancellablePromise\n   */\n  trackedPromise(promiseName, cancellablePromise) {\n    const self = this;\n    self[promiseName] = cancellablePromise;\n    return cancellablePromise.fail(() => {\n      if (cancellablePromise.cancelled) {\n        delete self[promiseName];\n      }\n    });\n  }\n\n  /**\n   * Resets the entry and clears the cache\n   *\n   * @param {Object} options\n   * @param {string} [options.invalidate] - 'cache', 'invalidate' or 'invalidateAndFlush', default 'cache', only used for Impala\n   * @param {boolean} [options.cascade] - Default false, only used when the entry is for the source\n   * @param {boolean} [options.silenceErrors] - Default false\n   * @return {CancellablePromise}\n   */\n  clearCache(options) {\n    const self = this;\n\n    if (!options) {\n      options = {};\n    }\n\n    let invalidatePromise;\n    let invalidate = options.invalidate || 'cache';\n\n    if (invalidate !== 'cache' && self.getSourceType() === 'impala') {\n      if (window.IS_K8S_ONLY) {\n        invalidate = 'invalidateAndFlush';\n      }\n      if (self.dataCatalog.invalidatePromise) {\n        invalidatePromise = self.dataCatalog.invalidatePromise;\n      } else {\n        invalidatePromise = apiHelper.invalidateSourceMetadata({\n          sourceType: self.getSourceType(),\n          compute: self.compute,\n          invalidate: invalidate,\n          path: self.path,\n          silenceErrors: options.silenceErrors\n        });\n        self.dataCatalog.invalidatePromise = invalidatePromise;\n        invalidatePromise.always(() => {\n          delete self.dataCatalog.invalidatePromise;\n        });\n      }\n    } else {\n      invalidatePromise = $.Deferred()\n        .resolve()\n        .promise();\n    }\n\n    if (self.definition && self.definition.navOptLoaded) {\n      delete self.definition.navOptLoaded;\n    }\n\n    self.reset();\n    const saveDeferred = options.cascade\n      ? self.dataCatalog.clearStorageCascade(self.namespace, self.compute, self.path)\n      : self.save();\n\n    const clearPromise = $.when(invalidatePromise, saveDeferred);\n\n    clearPromise.always(() => {\n      huePubSub.publish('data.catalog.entry.refreshed', {\n        entry: self,\n        cascade: !!options.cascade\n      });\n    });\n\n    return new CancellablePromise(clearPromise, undefined, [invalidatePromise]);\n  }\n\n  /**\n   * Save the entry to cache\n   *\n   * @return {Promise}\n   */\n  save() {\n    const self = this;\n    window.clearTimeout(self.saveTimeout);\n    return self.dataCatalog.persistCatalogEntry(self);\n  }\n\n  /**\n   * Save the entry at a later point of time\n   */\n  saveLater() {\n    const self = this;\n    if (CACHEABLE_TTL.default > 0) {\n      window.clearTimeout(self.saveTimeout);\n      self.saveTimeout = window.setTimeout(() => {\n        self.save();\n      }, 1000);\n    }\n  }\n\n  /**\n   * Get the children of the catalog entry, columns for a table entry etc.\n   *\n   * @param {Object} [options]\n   * @param {boolean} [options.silenceErrors]\n   * @param {boolean} [options.cachedOnly]\n   * @param {boolean} [options.refreshCache]\n   * @param {boolean} [options.cancellable] - Default false\n   *\n   * @return {CancellablePromise}\n   */\n  getChildren(options) {\n    const self = this;\n    if (self.childrenPromise && (!options || !options.refreshCache)) {\n      return catalogUtils.applyCancellable(self.childrenPromise, options);\n    }\n    const deferred = $.Deferred();\n\n    if (options && options.cachedOnly && !self.sourceMeta && !self.sourceMetaPromise) {\n      return deferred.reject(false).promise();\n    }\n\n    const sourceMetaPromise = self\n      .getSourceMeta(options)\n      .done(sourceMeta => {\n        if (!sourceMeta || sourceMeta.notFound) {\n          deferred.reject();\n          return;\n        }\n        const promises = [];\n        let index = 0;\n        const partitionKeys = {};\n        if (sourceMeta.partition_keys) {\n          sourceMeta.partition_keys.forEach(partitionKey => {\n            partitionKeys[partitionKey.name] = true;\n          });\n        }\n\n        const entities =\n          sourceMeta.databases ||\n          sourceMeta.tables_meta ||\n          sourceMeta.extended_columns ||\n          sourceMeta.fields ||\n          sourceMeta.columns;\n\n        if (entities) {\n          entities.forEach(entity => {\n            if (!sourceMeta.databases || (entity.name || entity) !== '_impala_builtins') {\n              promises.push(\n                self.dataCatalog\n                  .getEntry({\n                    namespace: self.namespace,\n                    compute: self.compute,\n                    path: self.path.concat(entity.name || entity)\n                  })\n                  .done(catalogEntry => {\n                    if (\n                      !catalogEntry.definition ||\n                      typeof catalogEntry.definition.index === 'undefined'\n                    ) {\n                      const definition = typeof entity === 'object' ? entity : {};\n                      if (typeof entity !== 'object') {\n                        if (self.path.length === 0) {\n                          definition.type = 'database';\n                        } else if (self.path.length === 1) {\n                          definition.type = 'table';\n                        } else if (self.path.length === 2) {\n                          definition.type = 'column';\n                        }\n                      }\n                      if (sourceMeta.partition_keys) {\n                        definition.partitionKey = !!partitionKeys[entity.name];\n                      }\n                      definition.index = index++;\n                      catalogEntry.definition = definition;\n                      catalogEntry.saveLater();\n                    }\n                  })\n              );\n            }\n          });\n        }\n        if (\n          (self.getSourceType() === 'impala' || self.getSourceType() === 'hive') &&\n          self.isComplex()\n        ) {\n          (sourceMeta.type === 'map' ? ['key', 'value'] : ['item']).forEach(path => {\n            if (sourceMeta[path]) {\n              promises.push(\n                self.dataCatalog\n                  .getEntry({\n                    namespace: self.namespace,\n                    compute: self.compute,\n                    path: self.path.concat(path)\n                  })\n                  .done(catalogEntry => {\n                    if (\n                      !catalogEntry.definition ||\n                      typeof catalogEntry.definition.index === 'undefined'\n                    ) {\n                      const definition = sourceMeta[path];\n                      definition.index = index++;\n                      definition.isMapValue = path === 'value';\n                      catalogEntry.definition = definition;\n                      catalogEntry.saveLater();\n                    }\n                  })\n              );\n            }\n          });\n        }\n        $.when.apply($, promises).done(function() {\n          deferred.resolve(Array.prototype.slice.call(arguments));\n        });\n      })\n      .fail(deferred.reject);\n\n    return catalogUtils.applyCancellable(\n      self.trackedPromise(\n        'childrenPromise',\n        new CancellablePromise(deferred, undefined, [sourceMetaPromise])\n      ),\n      options\n    );\n  }\n\n  /**\n   * Loads navigator metadata for children, only applicable to databases and tables\n   *\n   * @param {Object} [options]\n   * @param {boolean} [options.refreshCache]\n   * @param {boolean} [options.silenceErrors] - Default true\n   * @param {boolean} [options.cancellable] - Default false\n   *\n   * @return {CancellablePromise}\n   */\n  loadNavigatorMetaForChildren(options) {\n    const self = this;\n\n    options = catalogUtils.setSilencedErrors(options);\n\n    if (!self.canHaveNavigatorMetadata() || self.isField()) {\n      return $.Deferred()\n        .reject()\n        .promise();\n    }\n\n    if (self.navigatorMetaForChildrenPromise && (!options || !options.refreshCache)) {\n      return catalogUtils.applyCancellable(self.navigatorMetaForChildrenPromise, options);\n    }\n\n    const deferred = $.Deferred();\n\n    const cancellablePromises = [];\n\n    cancellablePromises.push(\n      self\n        .getChildren(options)\n        .done(children => {\n          const someHaveNavMeta = children.some(childEntry => {\n            return childEntry.navigatorMeta;\n          });\n          if (someHaveNavMeta && (!options || !options.refreshCache)) {\n            deferred.resolve(children);\n            return;\n          }\n\n          let query;\n          // TODO: Add sourceType to nav search query\n          if (self.path.length) {\n            query = 'parentPath:\"/' + self.path.join('/') + '\" AND type:(table view field)';\n          } else {\n            query = 'type:database';\n          }\n\n          const rejectUnknown = () => {\n            children.forEach(childEntry => {\n              if (!childEntry.navigatorMeta) {\n                childEntry.navigatorMeta = {};\n                childEntry.navigatorMetaPromise = $.Deferred()\n                  .reject()\n                  .promise();\n              }\n            });\n          };\n\n          cancellablePromises.push(\n            apiHelper\n              .searchEntities({\n                query: query,\n                rawQuery: true,\n                limit: children.length,\n                silenceErrors: options && options.silenceErrors\n              })\n              .done(result => {\n                if (result && result.entities) {\n                  const childEntryIndex = {};\n                  children.forEach(childEntry => {\n                    childEntryIndex[childEntry.name.toLowerCase()] = childEntry;\n                  });\n\n                  result.entities.forEach(entity => {\n                    const matchingChildEntry =\n                      childEntryIndex[(entity.original_name || entity.originalName).toLowerCase()];\n                    if (matchingChildEntry) {\n                      matchingChildEntry.navigatorMeta = entity;\n                      entity.hueTimestamp = Date.now();\n                      matchingChildEntry.navigatorMetaPromise = $.Deferred()\n                        .resolve(matchingChildEntry.navigatorMeta)\n                        .promise();\n                      if (entity && matchingChildEntry.commentObservable) {\n                        matchingChildEntry.commentObservable(\n                          matchingChildEntry.getResolvedComment()\n                        );\n                      }\n                      matchingChildEntry.saveLater();\n                    }\n                  });\n                }\n                rejectUnknown();\n                deferred.resolve(children);\n              })\n              .fail(() => {\n                rejectUnknown();\n                deferred.reject();\n              })\n          );\n        })\n        .fail(deferred.reject)\n    );\n\n    return catalogUtils.applyCancellable(\n      self.trackedPromise(\n        'navigatorMetaForChildrenPromise',\n        new CancellablePromise(deferred, null, cancellablePromises)\n      ),\n      options\n    );\n  }\n\n  /**\n   * Helper function used when loading navopt metdata for children\n   *\n   * @param {Object} response\n   * @param {Object} [options]\n   * @param {boolean} [options.silenceErrors] - Default false\n   *\n   * @return {CancellablePromise}\n   */\n  applyNavOptResponseToChildren(response, options) {\n    const self = this;\n    const deferred = $.Deferred();\n    if (!self.definition) {\n      self.definition = {};\n    }\n    self.definition.navOptLoaded = true;\n    self.saveLater();\n\n    const childPromise = self\n      .getChildren(options)\n      .done(childEntries => {\n        const entriesByName = {};\n        childEntries.forEach(childEntry => {\n          entriesByName[childEntry.name.toLowerCase()] = childEntry;\n        });\n        const updatedIndex = {};\n\n        if (self.isDatabase() && response.top_tables) {\n          response.top_tables.forEach(topTable => {\n            const matchingChild = entriesByName[topTable.name.toLowerCase()];\n            if (matchingChild) {\n              matchingChild.navOptPopularity = topTable;\n              matchingChild.saveLater();\n              updatedIndex[matchingChild.getQualifiedPath()] = matchingChild;\n            }\n          });\n        } else if (self.isTableOrView() && response.values) {\n          const addNavOptPopularity = function(columns, type) {\n            if (columns) {\n              columns.forEach(column => {\n                const matchingChild = entriesByName[column.columnName.toLowerCase()];\n                if (matchingChild) {\n                  if (!matchingChild.navOptPopularity) {\n                    matchingChild.navOptPopularity = {};\n                  }\n                  matchingChild.navOptPopularity[type] = column;\n                  matchingChild.saveLater();\n                  updatedIndex[matchingChild.getQualifiedPath()] = matchingChild;\n                }\n              });\n            }\n          };\n\n          addNavOptPopularity(response.values.filterColumns, 'filterColumn');\n          addNavOptPopularity(response.values.groupbyColumns, 'groupByColumn');\n          addNavOptPopularity(response.values.joinColumns, 'joinColumn');\n          addNavOptPopularity(response.values.orderbyColumns, 'orderByColumn');\n          addNavOptPopularity(response.values.selectColumns, 'selectColumn');\n        }\n        const popularEntries = [];\n        Object.keys(updatedIndex).forEach(path => {\n          popularEntries.push(updatedIndex[path]);\n        });\n        deferred.resolve(popularEntries);\n      })\n      .fail(deferred.reject);\n\n    return new CancellablePromise(deferred, undefined, [childPromise]);\n  }\n\n  /**\n   * Loads nav opt popularity for the children of this entry.\n   *\n   * @param {Object} [options]\n   * @param {boolean} [options.refreshCache]\n   * @param {boolean} [options.silenceErrors] - Default true\n   * @param {boolean} [options.cancellable] - Default false\n   *\n   * @return {CancellablePromise}\n   */\n  loadNavOptPopularityForChildren(options) {\n    const self = this;\n\n    options = catalogUtils.setSilencedErrors(options);\n\n    if (!self.dataCatalog.canHaveNavOptMetadata()) {\n      return $.Deferred()\n        .reject()\n        .promise();\n    }\n    if (self.navOptPopularityForChildrenPromise && (!options || !options.refreshCache)) {\n      return catalogUtils.applyCancellable(self.navOptPopularityForChildrenPromise, options);\n    }\n    const deferred = $.Deferred();\n    const cancellablePromises = [];\n    if (self.definition && self.definition.navOptLoaded && (!options || !options.refreshCache)) {\n      cancellablePromises.push(\n        self\n          .getChildren(options)\n          .done(childEntries => {\n            deferred.resolve(\n              childEntries.filter(entry => {\n                return entry.navOptPopularity;\n              })\n            );\n          })\n          .fail(deferred.reject)\n      );\n    } else if (self.isDatabase() || self.isTableOrView()) {\n      cancellablePromises.push(\n        apiHelper\n          .fetchNavOptPopularity({\n            silenceErrors: options && options.silenceErrors,\n            refreshCache: options && options.refreshCache,\n            paths: [self.path]\n          })\n          .done(data => {\n            cancellablePromises.push(\n              self\n                .applyNavOptResponseToChildren(data, options)\n                .done(deferred.resolve)\n                .fail(deferred.reject)\n            );\n          })\n          .fail(deferred.reject)\n      );\n    } else {\n      deferred.resolve([]);\n    }\n\n    return catalogUtils.applyCancellable(\n      self.trackedPromise(\n        'navOptPopularityForChildrenPromise',\n        new CancellablePromise(deferred, undefined, cancellablePromises)\n      ),\n      options\n    );\n  }\n\n  /**\n   * Returns true if the catalog entry can have navigator metadata\n   *\n   * @return {boolean}\n   */\n  canHaveNavigatorMetadata() {\n    const self = this;\n    return (\n      window.HAS_CATALOG &&\n      (self.getSourceType() === 'hive' || self.getSourceType() === 'impala') &&\n      (self.isDatabase() || self.isTableOrView() || self.isColumn())\n    );\n  }\n\n  /**\n   * Returns the currently known comment without loading any additional metadata\n   *\n   * @return {string}\n   */\n  getResolvedComment() {\n    const self = this;\n    if (\n      self.navigatorMeta &&\n      (self.getSourceType() === 'hive' || self.getSourceType() === 'impala')\n    ) {\n      return self.navigatorMeta.description || self.navigatorMeta.originalDescription || '';\n    }\n    return (self.sourceMeta && self.sourceMeta.comment) || '';\n  }\n\n  /**\n   * This can be used to get an observable for the comment which will be updated once a comment has been\n   * resolved.\n   *\n   * @return {ko.observable}\n   */\n  getCommentObservable() {\n    const self = this;\n    if (!self.commentObservable) {\n      self.commentObservable = ko.observable(self.getResolvedComment());\n    }\n    return self.commentObservable;\n  }\n\n  /**\n   * Checks whether the comment is known and has been loaded from the proper source\n   *\n   * @return {boolean}\n   */\n  hasResolvedComment() {\n    const self = this;\n    if (self.canHaveNavigatorMetadata()) {\n      return typeof self.navigatorMeta !== 'undefined';\n    }\n    return typeof self.sourceMeta !== 'undefined';\n  }\n\n  /**\n   * Gets the comment for this entry, fetching it if necessary from the proper source.\n   *\n   * @param {Object} [options]\n   * @param {boolean} [options.silenceErrors]\n   * @param {boolean} [options.cachedOnly]\n   * @param {boolean} [options.refreshCache]\n   * @param {boolean} [options.cancellable] - Default false\n   *\n   * @return {CancellablePromise}\n   */\n  getComment(options) {\n    const self = this;\n    const deferred = $.Deferred();\n    const cancellablePromises = [];\n\n    const resolveWithSourceMeta = function() {\n      if (self.sourceMeta) {\n        deferred.resolve(self.sourceMeta.comment || '');\n      } else if (self.definition && typeof self.definition.comment !== 'undefined') {\n        deferred.resolve(self.definition.comment);\n      } else {\n        cancellablePromises.push(\n          self\n            .getSourceMeta(options)\n            .done(sourceMeta => {\n              deferred.resolve((sourceMeta && sourceMeta.comment) || '');\n            })\n            .fail(deferred.reject)\n        );\n      }\n    };\n\n    if (self.canHaveNavigatorMetadata()) {\n      if (self.navigatorMetaPromise) {\n        self.navigatorMetaPromise\n          .done(() => {\n            deferred.resolve(\n              self.navigatorMeta.description || self.navigatorMeta.originalDescription || ''\n            );\n          })\n          .fail(resolveWithSourceMeta);\n      } else if (self.navigatorMeta) {\n        deferred.resolve(\n          self.navigatorMeta.description || self.navigatorMeta.originalDescription || ''\n        );\n      } else {\n        cancellablePromises.push(\n          self\n            .getNavigatorMeta(options)\n            .done(navigatorMeta => {\n              if (navigatorMeta) {\n                deferred.resolve(\n                  navigatorMeta.description || navigatorMeta.originalDescription || ''\n                );\n              } else {\n                resolveWithSourceMeta();\n              }\n            })\n            .fail(resolveWithSourceMeta)\n        );\n      }\n    } else {\n      resolveWithSourceMeta();\n    }\n\n    return catalogUtils.applyCancellable(\n      new CancellablePromise(deferred, undefined, cancellablePromises),\n      options\n    );\n  }\n\n  /**\n   * Updates custom navigator metadata for the catalog entry\n   *\n   * @param {Object} [modifiedCustomMetadata] - The custom metadata to update, only supply what has been changed\n   * @param {string[]} [deletedCustomMetadataKeys] - The custom metadata to delete identifier by the keys\n   * @param {Object} [apiOptions]\n   * @param {boolean} [apiOptions.silenceErrors]\n   *\n   * @return {Promise}\n   */\n  updateNavigatorCustomMetadata(modifiedCustomMetadata, deletedCustomMetadataKeys, apiOptions) {\n    const self = this;\n    const deferred = $.Deferred();\n\n    if (self.canHaveNavigatorMetadata()) {\n      if (\n        self.navigatorMeta === {} ||\n        (self.navigatorMeta && typeof self.navigatorMeta.identity === 'undefined')\n      ) {\n        if (!apiOptions) {\n          apiOptions = {};\n        }\n        apiOptions.refreshCache = true;\n      }\n      self\n        .getNavigatorMeta(apiOptions)\n        .done(navigatorMeta => {\n          if (navigatorMeta) {\n            apiHelper\n              .updateNavigatorProperties({\n                identity: navigatorMeta.identity,\n                modifiedCustomMetadata: modifiedCustomMetadata,\n                deletedCustomMetadataKeys: deletedCustomMetadataKeys\n              })\n              .done(entity => {\n                if (entity) {\n                  self.navigatorMeta = entity;\n                  self.navigatorMetaPromise = $.Deferred()\n                    .resolve(self.navigatorMeta)\n                    .promise();\n                  self.saveLater();\n                  deferred.resolve(self.navigatorMeta);\n                } else {\n                  deferred.reject();\n                }\n              })\n              .fail(deferred.reject);\n          }\n        })\n        .fail(deferred.reject);\n    } else {\n      deferred.reject();\n    }\n\n    return deferred.promise();\n  }\n\n  /**\n   * Sets the comment in the proper source\n   *\n   * @param {string} comment\n   * @param {Object} [apiOptions]\n   * @param {boolean} [apiOptions.silenceErrors]\n   * @param {boolean} [apiOptions.refreshCache]\n   *\n   * @return {Promise}\n   */\n  setComment(comment, apiOptions) {\n    const self = this;\n    const deferred = $.Deferred();\n\n    if (self.canHaveNavigatorMetadata()) {\n      if (\n        self.navigatorMeta === {} ||\n        (self.navigatorMeta && typeof self.navigatorMeta.identity === 'undefined')\n      ) {\n        if (!apiOptions) {\n          apiOptions = {};\n        }\n        apiOptions.refreshCache = true;\n      }\n      self\n        .getNavigatorMeta(apiOptions)\n        .done(navigatorMeta => {\n          if (navigatorMeta) {\n            apiHelper\n              .updateNavigatorProperties({\n                identity: navigatorMeta.identity,\n                properties: {\n                  description: comment\n                }\n              })\n              .done(entity => {\n                if (entity) {\n                  self.navigatorMeta = entity;\n                  self.navigatorMetaPromise = $.Deferred()\n                    .resolve(self.navigatorMeta)\n                    .promise();\n                  self.saveLater();\n                }\n                self.getComment(apiOptions).done(comment => {\n                  if (self.commentObservable && self.commentObservable() !== comment) {\n                    self.commentObservable(comment);\n                  }\n                  deferred.resolve(comment);\n                });\n              })\n              .fail(deferred.reject);\n          }\n        })\n        .fail(deferred.reject);\n    } else {\n      apiHelper\n        .updateSourceMetadata({\n          sourceType: self.getSourceType(),\n          path: self.path,\n          properties: {\n            comment: comment\n          }\n        })\n        .done(() => {\n          reloadSourceMeta(self, {\n            silenceErrors: apiOptions && apiOptions.silenceErrors,\n            refreshCache: true\n          }).done(() => {\n            self.getComment(apiOptions).done(deferred.resolve);\n          });\n        })\n        .fail(deferred.reject);\n    }\n\n    return deferred.promise();\n  }\n\n  /**\n   * Adds a list of tags and updates the navigator metadata of the entry\n   *\n   * @param {string[]} tags\n   *\n   * @return {Promise}\n   */\n  addNavigatorTags(tags) {\n    const self = this;\n    const deferred = $.Deferred();\n    if (self.canHaveNavigatorMetadata()) {\n      self\n        .getNavigatorMeta()\n        .done(navMeta => {\n          if (navMeta && typeof navMeta.identity !== 'undefined') {\n            apiHelper\n              .addNavTags(navMeta.identity, tags)\n              .done(entity => {\n                if (entity) {\n                  self.navigatorMeta = entity;\n                  self.navigatorMetaPromise = $.Deferred()\n                    .resolve(self.navigatorMeta)\n                    .promise();\n                  self.saveLater();\n                } else {\n                  deferred.reject();\n                }\n                deferred.resolve(self.navigatorMeta);\n              })\n              .fail(deferred.reject);\n          } else {\n            deferred.reject();\n          }\n        })\n        .fail(deferred.reject);\n    } else {\n      deferred.reject();\n    }\n    return deferred.promise();\n  }\n\n  /**\n   * Removes a list of tags and updates the navigator metadata of the entry\n   *\n   * @param {string[]} tags\n   *\n   * @return {Promise}\n   */\n  deleteNavigatorTags(tags) {\n    const self = this;\n    const deferred = $.Deferred();\n    if (self.canHaveNavigatorMetadata()) {\n      self\n        .getNavigatorMeta()\n        .done(navMeta => {\n          if (navMeta && typeof navMeta.identity !== 'undefined') {\n            apiHelper\n              .deleteNavTags(navMeta.identity, tags)\n              .done(entity => {\n                if (entity) {\n                  self.navigatorMeta = entity;\n                  self.navigatorMetaPromise = $.Deferred()\n                    .resolve(self.navigatorMeta)\n                    .promise();\n                  self.saveLater();\n                } else {\n                  deferred.reject();\n                }\n                deferred.resolve(self.navigatorMeta);\n              })\n              .fail(deferred.reject);\n          } else {\n            deferred.reject();\n          }\n        })\n        .fail(deferred.reject);\n    } else {\n      deferred.reject();\n    }\n    return deferred.promise();\n  }\n\n  /**\n   * Checks if the entry can have children or not without fetching additional metadata.\n   *\n   * @return {boolean}\n   */\n  hasPossibleChildren() {\n    const self = this;\n    return (\n      self.path.length < 3 ||\n      (!self.definition && !self.sourceMeta) ||\n      (self.sourceMeta && /^(?:struct|array|map)/i.test(self.sourceMeta.type)) ||\n      (self.definition && /^(?:struct|array|map)/i.test(self.definition.type))\n    );\n  }\n\n  /**\n   * Returns the index representing the order in which the backend returned this entry.\n   *\n   * @return {number}\n   */\n  getIndex() {\n    const self = this;\n    return self.definition && self.definition.index ? self.definition.index : 0;\n  }\n\n  /**\n   * Returns the source type of this entry.\n   *\n   * @return {string} - 'impala', 'hive', 'solr', etc.\n   */\n  getSourceType() {\n    const self = this;\n    return self.dataCatalog.sourceType;\n  }\n\n  /**\n   * Returns true if the entry represents a data source.\n   *\n   * @return {boolean}\n   */\n  isSource() {\n    const self = this;\n    return self.path.length === 0;\n  }\n\n  /**\n   * Returns true if the entry is a database.\n   *\n   * @return {boolean}\n   */\n  isDatabase() {\n    const self = this;\n    return self.path.length === 1;\n  }\n\n  /**\n   * Returns true if the entry is a table or a view.\n   *\n   * @return {boolean}\n   */\n  isTableOrView() {\n    const self = this;\n    return self.path.length === 2;\n  }\n\n  /**\n   * Returns the default title used for the entry, the qualified path with type for fields. Optionally include\n   * the comment after, if already resolved.\n   *\n   * @param {boolean} [includeComment] - Default false\n   * @return {string}\n   */\n  getTitle(includeComment) {\n    const self = this;\n    let title = self.getQualifiedPath();\n    if (self.isField()) {\n      const type = self.getType();\n      if (type) {\n        title += ' (' + type + ')';\n      }\n    }\n    if (includeComment && self.hasResolvedComment() && self.getResolvedComment()) {\n      title += ' - ' + self.getResolvedComment();\n    }\n    return title;\n  }\n\n  /**\n   * Returns the fully qualified path for this entry.\n   *\n   * @return {string}\n   */\n  getQualifiedPath() {\n    const self = this;\n    return self.path.join('.');\n  }\n\n  /**\n   * Returns the display name for the entry, name or qualified path plus type for fields\n   *\n   * @param {boolean} qualified - Whether to use the qualified path or not, default false\n   * @return {string}\n   */\n  getDisplayName(qualified) {\n    const self = this;\n    let displayName = qualified ? self.getQualifiedPath() : self.name;\n    if (self.isField()) {\n      const type = self.getType();\n      if (type) {\n        displayName += ' (' + type + ')';\n      }\n    }\n    return displayName;\n  }\n\n  /**\n   * Returns true for columns that are a primary key. Note that the definition has to come from a parent entry, i.e.\n   * getChildren().\n   *\n   * @return {boolean}\n   */\n  isPrimaryKey() {\n    const self = this;\n    return self.isColumn() && self.definition && /true/i.test(self.definition.primary_key);\n  }\n\n  /**\n   * Returns true if the entry is a partition key. Note that the definition has to come from a parent entry, i.e.\n   * getChildren().\n   *\n   * @return {boolean}\n   */\n  isPartitionKey() {\n    const self = this;\n    return self.definition && !!self.definition.partitionKey;\n  }\n\n  /**\n   * Returns true if the entry is a table. It will be accurate once the source meta has been loaded.\n   *\n   * @return {boolean}\n   */\n  isTable() {\n    const self = this;\n    if (self.path.length === 2) {\n      if (\n        self.analysis &&\n        self.analysis.details &&\n        self.analysis.details.properties &&\n        self.analysis.details.properties.table_type === 'VIRTUAL_VIEW'\n      ) {\n        return false;\n      }\n      if (self.sourceMeta) {\n        return !self.sourceMeta.is_view;\n      }\n      if (self.definition && self.definition.type) {\n        return self.definition.type.toLowerCase() === 'table';\n      }\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Returns true if the entry is a table. It will be accurate once the source meta has been loaded.\n   *\n   * @return {boolean}\n   */\n  isView() {\n    const self = this;\n    return (\n      self.path.length === 2 &&\n      ((self.sourceMeta && self.sourceMeta.is_view) ||\n        (self.definition &&\n          self.definition.type &&\n          self.definition.type.toLowerCase() === 'view') ||\n        (self.analysis &&\n          self.analysis.details &&\n          self.analysis.details.properties &&\n          self.analysis.details.properties.table_type === 'VIRTUAL_VIEW'))\n    );\n  }\n\n  /**\n   * Returns true if the entry is a column.\n   *\n   * @return {boolean}\n   */\n  isColumn() {\n    const self = this;\n    return self.path.length === 3;\n  }\n\n  /**\n   * Returns true if the entry is a column. It will be accurate once the source meta has been loaded or if loaded from\n   * a parent entry via getChildren().\n   *\n   * @return {boolean}\n   */\n  isComplex() {\n    const self = this;\n    return (\n      self.path.length > 2 &&\n      ((self.sourceMeta && /^(?:struct|array|map)/i.test(self.sourceMeta.type)) ||\n        (self.definition && /^(?:struct|array|map)/i.test(self.definition.type)))\n    );\n  }\n\n  /**\n   * Returns true if the entry is a field, i.e. column or child of a complex type.\n   *\n   * @return {boolean}\n   */\n  isField() {\n    const self = this;\n    return self.path.length > 2;\n  }\n\n  /**\n   * Returns true if the entry is an array. It will be accurate once the source meta has been loaded or if loaded from\n   * a parent entry via getChildren().\n   *\n   * @return {boolean}\n   */\n  isArray() {\n    const self = this;\n    return (\n      (self.sourceMeta && /^array/i.test(self.sourceMeta.type)) ||\n      (self.definition && /^array/i.test(self.definition.type))\n    );\n  }\n\n  /**\n   * Returns true if the entry is a map. It will be accurate once the source meta has been loaded or if loaded from\n   * a parent entry via getChildren().\n   *\n   * @return {boolean}\n   */\n  isMap() {\n    const self = this;\n    return (\n      (self.sourceMeta && /^map/i.test(self.sourceMeta.type)) ||\n      (self.definition && /^map/i.test(self.definition.type))\n    );\n  }\n\n  /**\n   * Returns true if the entry is a map value. It will be accurate once the source meta has been loaded or if loaded\n   * from a parent entry via getChildren().\n   *\n   * @return {boolean}\n   */\n  isMapValue() {\n    const self = this;\n    return self.definition && self.definition.isMapValue;\n  }\n\n  /**\n   * Returns the type of the entry. It will be accurate once the source meta has been loaded or if loaded from\n   * a parent entry via getChildren().\n   *\n   * The returned string is always lower case and for complex entries the type definition is stripped to\n   * either 'array', 'map' or 'struct'.\n   *\n   * @return {string}\n   */\n  getType() {\n    const self = this;\n    let type = self.getRawType();\n    if (type.indexOf('<') !== -1) {\n      type = type.substring(0, type.indexOf('<'));\n    }\n    return type.toLowerCase();\n  }\n\n  /**\n   * Returns the raw type of the entry. It will be accurate once the source meta has been loaded or if loaded from\n   * a parent entry via getChildren().\n   *\n   * For complex entries the type definition is the full version.\n   *\n   * @return {string}\n   */\n  getRawType() {\n    const self = this;\n    return (self.sourceMeta && self.sourceMeta.type) || self.definition.type || '';\n  }\n\n  /**\n   * Gets the source metadata for the entry. It will fetch it if not cached or if the refresh option is set.\n   *\n   * @param {Object} [options]\n   * @param {boolean} [options.silenceErrors]\n   * @param {boolean} [options.cachedOnly]\n   * @param {boolean} [options.refreshCache]\n   * @param {boolean} [options.cancellable] - Default false\n   *\n   * @return {CancellablePromise}\n   */\n  getSourceMeta(options) {\n    const self = this;\n    if (options && options.cachedOnly) {\n      return (\n        catalogUtils.applyCancellable(self.sourceMetaPromise, options) ||\n        $.Deferred()\n          .reject(false)\n          .promise()\n      );\n    }\n    if (options && options.refreshCache) {\n      return catalogUtils.applyCancellable(reloadSourceMeta(self, options));\n    }\n    return catalogUtils.applyCancellable(\n      self.sourceMetaPromise || reloadSourceMeta(self, options),\n      options\n    );\n  }\n\n  /**\n   * Gets the analysis for the entry. It will fetch it if not cached or if the refresh option is set.\n   *\n   * @param {Object} [options]\n   * @param {boolean} [options.silenceErrors]\n   * @param {boolean} [options.cachedOnly]\n   * @param {boolean} [options.refreshCache] - Clears the browser cache\n   * @param {boolean} [options.refreshAnalysis] - Performs a hard refresh on the source level\n   * @param {boolean} [options.cancellable] - Default false\n   *\n   * @return {CancellablePromise}\n   */\n  getAnalysis(options) {\n    const self = this;\n    if (options && options.cachedOnly) {\n      return (\n        catalogUtils.applyCancellable(self.analysisPromise, options) ||\n        $.Deferred()\n          .reject(false)\n          .promise()\n      );\n    }\n    if (options && (options.refreshCache || options.refreshAnalysis)) {\n      return catalogUtils.applyCancellable(reloadAnalysis(self, options), options);\n    }\n    return catalogUtils.applyCancellable(\n      self.analysisPromise || reloadAnalysis(self, options),\n      options\n    );\n  }\n\n  /**\n   * Gets the partitions for the entry. It will fetch it if not cached or if the refresh option is set.\n   *\n   * @param {Object} [options]\n   * @param {boolean} [options.silenceErrors]\n   * @param {boolean} [options.cachedOnly]\n   * @param {boolean} [options.refreshCache] - Clears the browser cache\n   * @param {boolean} [options.cancellable] - Default false\n   *\n   * @return {CancellablePromise}\n   */\n  getPartitions(options) {\n    const self = this;\n    if (!self.isTableOrView()) {\n      return $.Deferred()\n        .reject(false)\n        .promise();\n    }\n    if (options && options.cachedOnly) {\n      return (\n        catalogUtils.applyCancellable(self.partitionsPromise, options) ||\n        $.Deferred()\n          .reject(false)\n          .promise()\n      );\n    }\n    if (options && options.refreshCache) {\n      return catalogUtils.applyCancellable(reloadPartitions(self, options), options);\n    }\n    return catalogUtils.applyCancellable(\n      self.partitionsPromise || reloadPartitions(self, options),\n      options\n    );\n  }\n\n  /**\n   * Gets the Navigator metadata for the entry. It will fetch it if not cached or if the refresh option is set.\n   *\n   * @param {Object} [options]\n   * @param {boolean} [options.silenceErrors] - Default true\n   * @param {boolean} [options.cachedOnly]\n   * @param {boolean} [options.refreshCache]\n   * @param {boolean} [options.cancellable] - Default false\n   *\n   * @return {CancellablePromise}\n   */\n  getNavigatorMeta(options) {\n    const self = this;\n\n    options = catalogUtils.setSilencedErrors(options);\n\n    if (!self.canHaveNavigatorMetadata()) {\n      return $.Deferred()\n        .reject()\n        .promise();\n    }\n    if (options && options.cachedOnly) {\n      return (\n        catalogUtils.applyCancellable(self.navigatorMetaPromise, options) ||\n        $.Deferred()\n          .reject(false)\n          .promise()\n      );\n    }\n    if (options && options.refreshCache) {\n      return catalogUtils.applyCancellable(reloadNavigatorMeta(self, options), options);\n    }\n    return catalogUtils.applyCancellable(\n      self.navigatorMetaPromise || reloadNavigatorMeta(self, options),\n      options\n    );\n  }\n\n  /**\n   * Gets the Nav Opt metadata for the entry. It will fetch it if not cached or if the refresh option is set.\n   *\n   * @param {Object} [options]\n   * @param {boolean} [options.silenceErrors] - Default true\n   * @param {boolean} [options.cachedOnly] - Default false\n   * @param {boolean} [options.refreshCache] - Default false\n   * @param {boolean} [options.cancellable] - Default false\n   *\n   * @return {CancellablePromise}\n   */\n  getNavOptMeta(options) {\n    const self = this;\n\n    options = catalogUtils.setSilencedErrors(options);\n\n    if (!self.dataCatalog.canHaveNavOptMetadata() || !self.isTableOrView()) {\n      return $.Deferred()\n        .reject()\n        .promise();\n    }\n    if (options && options.cachedOnly) {\n      return (\n        catalogUtils.applyCancellable(self.navOptMetaPromise, options) ||\n        $.Deferred()\n          .reject(false)\n          .promise()\n      );\n    }\n    if (options && options.refreshCache) {\n      return catalogUtils.applyCancellable(reloadNavOptMeta(self, options), options);\n    }\n    return catalogUtils.applyCancellable(\n      self.navOptMetaPromise || reloadNavOptMeta(self, options),\n      options\n    );\n  }\n\n  /**\n   * Gets the sample for the entry, if unknown it will first check if any parent table already has the sample. It\n   * will fetch it if not cached or if the refresh option is set.\n   *\n   * @param {Object} [options]\n   * @param {boolean} [options.silenceErrors] - Default false\n   * @param {boolean} [options.cachedOnly] - Default false\n   * @param {boolean} [options.refreshCache] - Default false\n   * @param {boolean} [options.cancellable] - Default false\n   * @oaram {string} [options.operation]\n   *\n   * @return {CancellablePromise}\n   */\n  getSample(options) {\n    const self = this;\n\n    // This prevents caching of any non-standard sample queries, i.e. DISTINCT etc.\n    if (options && options.operation && options.operation !== 'default') {\n      return catalogUtils.applyCancellable(\n        apiHelper.fetchSample({\n          sourceType: self.dataCatalog.sourceType,\n          compute: self.compute,\n          path: self.path,\n          silenceErrors: options && options.silenceErrors,\n          operation: options.operation\n        }),\n        options\n      );\n    }\n\n    // Check if parent has a sample that we can reuse\n    if (!self.samplePromise && self.isColumn()) {\n      const deferred = $.Deferred();\n      const cancellablePromises = [];\n\n      const revertToSpecific = function() {\n        if (options && options.cachedOnly) {\n          deferred.reject();\n        } else {\n          cancellablePromises.push(\n            catalogUtils\n              .applyCancellable(reloadSample(self, options), options)\n              .done(deferred.resolve)\n              .fail(deferred.reject)\n          );\n        }\n      };\n\n      self.dataCatalog\n        .getEntry({\n          namespace: self.namespace,\n          compute: self.compute,\n          path: self.path.slice(0, 2),\n          definition: { type: 'table' }\n        })\n        .done(tableEntry => {\n          if (tableEntry && tableEntry.samplePromise) {\n            cancellablePromises.push(\n              catalogUtils.applyCancellable(tableEntry.samplePromise, options)\n            );\n\n            tableEntry.samplePromise\n              .done(parentSample => {\n                const colSample = {\n                  hueTimestamp: parentSample.hueTimestamp,\n                  has_more: parentSample.has_more,\n                  type: parentSample.type,\n                  data: [],\n                  meta: []\n                };\n                if (parentSample.meta) {\n                  for (let i = 0; i < parentSample.meta.length; i++) {\n                    if (parentSample.meta[i].name.toLowerCase() === self.name.toLowerCase()) {\n                      colSample.meta[0] = parentSample.meta[i];\n                      parentSample.data.forEach(parentRow => {\n                        colSample.data.push([parentRow[i]]);\n                      });\n                      break;\n                    }\n                  }\n                }\n                if (colSample.meta.length) {\n                  self.sample = colSample;\n                  deferred.resolve(self.sample);\n                } else {\n                  revertToSpecific();\n                }\n              })\n              .fail(revertToSpecific);\n          } else {\n            revertToSpecific();\n          }\n        })\n        .fail(revertToSpecific);\n\n      return catalogUtils.applyCancellable(\n        self.trackedPromise(\n          'samplePromise',\n          new CancellablePromise(deferred, undefined, cancellablePromises)\n        ),\n        options\n      );\n    }\n\n    if (options && options.cachedOnly) {\n      return (\n        catalogUtils.applyCancellable(self.samplePromise, options) ||\n        $.Deferred()\n          .reject(false)\n          .promise()\n      );\n    }\n    if (options && options.refreshCache) {\n      return catalogUtils.applyCancellable(reloadSample(self, options), options);\n    }\n    return catalogUtils.applyCancellable(\n      self.samplePromise || reloadSample(self, options),\n      options\n    );\n  }\n\n  /**\n   * Gets the top aggregate UDFs for the entry if it's a table or view. It will fetch it if not cached or if the refresh option is set.\n   *\n   * @param {Object} [options]\n   * @param {boolean} [options.silenceErrors] - Default false\n   * @param {boolean} [options.cachedOnly] - Default false\n   * @param {boolean} [options.refreshCache] - Default false\n   * @param {boolean} [options.cancellable] - Default false\n   *\n   * @return {CancellablePromise}\n   */\n  getTopAggs(options) {\n    const self = this;\n    return getFromMultiTableCatalog(self, options, 'getTopAggs');\n  }\n\n  /**\n   * Gets the top filters for the entry if it's a table or view. It will fetch it if not cached or if the refresh option is set.\n   *\n   * @param {Object} [options]\n   * @param {boolean} [options.silenceErrors] - Default false\n   * @param {boolean} [options.cachedOnly] - Default false\n   * @param {boolean} [options.refreshCache] - Default false\n   * @param {boolean} [options.cancellable] - Default false\n   *\n   * @return {CancellablePromise}\n   */\n  getTopFilters(options) {\n    const self = this;\n    return getFromMultiTableCatalog(self, options, 'getTopFilters');\n  }\n\n  /**\n   * Gets the top joins for the entry if it's a table or view. It will fetch it if not cached or if the refresh option is set.\n   *\n   * @param {Object} [options]\n   * @param {boolean} [options.silenceErrors] - Default false\n   * @param {boolean} [options.cachedOnly] - Default false\n   * @param {boolean} [options.refreshCache] - Default false\n   * @param {boolean} [options.cancellable] - Default false\n   *\n   * @return {CancellablePromise}\n   */\n  getTopJoins(options) {\n    const self = this;\n    return getFromMultiTableCatalog(self, options, 'getTopJoins');\n  }\n}\n\nexport default DataCatalogEntry;\n","// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport $ from 'jquery';\nimport localforage from 'localforage';\n\nimport apiHelper from 'api/apiHelper';\n\nconst STORAGE_POSTFIX = window.LOGGED_USERNAME;\nconst DATA_CATALOG_VERSION = 5;\n\nclass GeneralDataCatalog {\n  constructor() {\n    const self = this;\n    self.store = localforage.createInstance({\n      name: 'HueDataCatalog_' + STORAGE_POSTFIX\n    });\n\n    self.allNavigatorTagsPromise = undefined;\n  }\n\n  /**\n   * @param {Object} [options]\n   * @param {boolean} [options.silenceErrors]\n   * @param {boolean} [options.refreshCache]\n   *\n   * @return {Promise}\n   */\n  getAllNavigatorTags(options) {\n    const self = this;\n    if (self.allNavigatorTagsPromise && (!options || !options.refreshCache)) {\n      return self.allNavigatorTagsPromise;\n    }\n\n    const deferred = $.Deferred();\n\n    if (!window.HAS_CATALOG) {\n      return deferred.reject().promise();\n    }\n\n    self.allNavigatorTagsPromise = deferred.promise();\n\n    const reloadAllTags = () => {\n      apiHelper\n        .fetchAllNavigatorTags({\n          silenceErrors: options && options.silenceErrors\n        })\n        .done(deferred.resolve)\n        .fail(deferred.reject);\n\n      if (window.CACHEABLE_TTL.default > 0) {\n        deferred.done(allTags => {\n          self.store.setItem('hue.dataCatalog.allNavTags', {\n            allTags: allTags,\n            hueTimestamp: Date.now(),\n            version: DATA_CATALOG_VERSION\n          });\n        });\n      }\n    };\n\n    if (window.CACHEABLE_TTL.default > 0 && (!options || !options.refreshCache)) {\n      self.store\n        .getItem('hue.dataCatalog.allNavTags')\n        .then(storeEntry => {\n          if (\n            storeEntry &&\n            storeEntry.version === DATA_CATALOG_VERSION &&\n            (!storeEntry.hueTimestamp ||\n              Date.now() - storeEntry.hueTimestamp < CACHEABLE_TTL.default)\n          ) {\n            deferred.resolve(storeEntry.allTags);\n          } else {\n            reloadAllTags();\n          }\n        })\n        .catch(reloadAllTags);\n    } else {\n      reloadAllTags();\n    }\n\n    return self.allNavigatorTagsPromise;\n  }\n\n  /**\n   * @param {string[]} tagsToAdd\n   * @param {string[]} tagsToRemove\n   */\n  updateAllNavigatorTags(tagsToAdd, tagsToRemove) {\n    const self = this;\n    if (self.allNavigatorTagsPromise) {\n      self.allNavigatorTagsPromise.done(allTags => {\n        tagsToAdd.forEach(newTag => {\n          if (!allTags[newTag]) {\n            allTags[newTag] = 0;\n          }\n          allTags[newTag]++;\n        });\n        tagsToRemove.forEach(removedTag => {\n          if (!allTags[removedTag]) {\n            allTags[removedTag]--;\n            if (allTags[removedTag] === 0) {\n              delete allTags[removedTag];\n            }\n          }\n        });\n        self.store.setItem('hue.dataCatalog.allNavTags', {\n          allTags: allTags,\n          hueTimestamp: Date.now(),\n          version: DATA_CATALOG_VERSION\n        });\n      });\n    }\n  }\n}\n\nexport default GeneralDataCatalog;\n","// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport $ from 'jquery';\n\nimport catalogUtils from 'catalog/catalogUtils';\n\n/**\n * Helper function to reload a NavOpt multi table attribute, like topAggs or topFilters\n *\n * @param {MultiTableEntry} multiTableEntry\n * @param {Object} [options]\n * @param {boolean} [options.silenceErrors] - Default true\n * @param {string} promiseAttribute\n * @param {string} dataAttribute\n * @param {string} apiHelperFunction\n * @return {CancellablePromise}\n */\nconst genericNavOptReload = function(\n  multiTableEntry,\n  options,\n  promiseAttribute,\n  dataAttribute,\n  apiHelperFunction\n) {\n  if (multiTableEntry.dataCatalog.canHaveNavOptMetadata()) {\n    return multiTableEntry.trackedPromise(\n      promiseAttribute,\n      catalogUtils.fetchAndSave(apiHelperFunction, dataAttribute, multiTableEntry, options)\n    );\n  }\n  multiTableEntry[promiseAttribute] = $.Deferred().reject();\n  return multiTableEntry[promiseAttribute];\n};\n\n/**\n * Helper function to get a NavOpt multi table attribute, like topAggs or topFilters\n *\n * @param {MultiTableEntry} multiTableEntry\n * @param {Object} [options]\n * @param {boolean} [options.silenceErrors] - Default false\n * @param {boolean} [options.refreshCache] - Default false\n * @param {boolean} [options.cachedOnly] - Default false\n * @param {boolean} [options.cancellable] - Default false\n * @param {string} promiseAttribute\n * @param {string} dataAttribute\n * @param {string} apiHelperFunction\n * @return {CancellablePromise}\n */\nconst genericNavOptGet = function(\n  multiTableEntry,\n  options,\n  promiseAttribute,\n  dataAttribute,\n  apiHelperFunction\n) {\n  if (options && options.cachedOnly) {\n    return (\n      catalogUtils.applyCancellable(multiTableEntry[promiseAttribute], options) ||\n      $.Deferred()\n        .reject(false)\n        .promise()\n    );\n  }\n  if (options && options.refreshCache) {\n    return catalogUtils.applyCancellable(\n      genericNavOptReload(\n        multiTableEntry,\n        options,\n        promiseAttribute,\n        dataAttribute,\n        apiHelperFunction\n      ),\n      options\n    );\n  }\n  return catalogUtils.applyCancellable(\n    multiTableEntry[promiseAttribute] ||\n      genericNavOptReload(\n        multiTableEntry,\n        options,\n        promiseAttribute,\n        dataAttribute,\n        apiHelperFunction\n      ),\n    options\n  );\n};\n\nclass MultiTableEntry {\n  /**\n   *\n   * @param {Object} options\n   * @param {string} options.identifier\n   * @param {DataCatalog} options.dataCatalog\n   * @param {string[][]} options.paths\n   * @constructor\n   */\n  constructor(options) {\n    const self = this;\n    self.identifier = options.identifier;\n    self.dataCatalog = options.dataCatalog;\n    self.paths = options.paths;\n\n    self.topAggs = undefined;\n    self.topAggsPromise = undefined;\n\n    self.topColumns = undefined;\n    self.topColumnsPromise = undefined;\n\n    self.topFilters = undefined;\n    self.topFiltersPromise = undefined;\n\n    self.topJoins = undefined;\n    self.topJoinsPromise = undefined;\n  }\n\n  /**\n   * Save the multi table entry to cache\n   *\n   * @return {Promise}\n   */\n  save() {\n    const self = this;\n    window.clearTimeout(self.saveTimeout);\n    return self.dataCatalog.persistMultiTableEntry(self);\n  }\n\n  /**\n   * Save the multi table entry at a later point of time\n   */\n  saveLater() {\n    const self = this;\n    if (CACHEABLE_TTL.default > 0) {\n      window.clearTimeout(self.saveTimeout);\n      self.saveTimeout = window.setTimeout(() => {\n        self.save();\n      }, 1000);\n    }\n  }\n  /**\n   * Helper function that ensure that cancellable promises are not tracked anymore when cancelled\n   *\n   * @param {string} promiseName - The attribute name to use\n   * @param {CancellablePromise} cancellablePromise\n   */\n  trackedPromise(promiseName, cancellablePromise) {\n    const self = this;\n    self[promiseName] = cancellablePromise;\n    return cancellablePromise.fail(() => {\n      if (cancellablePromise.cancelled) {\n        delete self[promiseName];\n      }\n    });\n  }\n\n  /**\n   * Gets the top aggregate UDFs for the entry. It will fetch it if not cached or if the refresh option is set.\n   *\n   * @param {Object} [options]\n   * @param {boolean} [options.silenceErrors] - Default false\n   * @param {boolean} [options.cachedOnly] - Default false\n   * @param {boolean} [options.refreshCache] - Default false\n   * @param {boolean} [options.cancellable] - Default false\n   *\n   * @return {CancellablePromise}\n   */\n  getTopAggs(options) {\n    const self = this;\n    return genericNavOptGet(self, options, 'topAggsPromise', 'topAggs', 'fetchNavOptTopAggs');\n  }\n\n  /**\n   * Gets the top columns for the entry. It will fetch it if not cached or if the refresh option is set.\n   *\n   * @param {Object} [options]\n   * @param {boolean} [options.silenceErrors] - Default false\n   * @param {boolean} [options.cachedOnly] - Default false\n   * @param {boolean} [options.refreshCache] - Default false\n   * @param {boolean} [options.cancellable] - Default false\n   *\n   * @return {CancellablePromise}\n   */\n  getTopColumns(options) {\n    const self = this;\n    return genericNavOptGet(\n      self,\n      options,\n      'topColumnsPromise',\n      'topColumns',\n      'fetchNavOptTopColumns'\n    );\n  }\n\n  /**\n   * Gets the top filters for the entry. It will fetch it if not cached or if the refresh option is set.\n   *\n   * @param {Object} [options]\n   * @param {boolean} [options.silenceErrors] - Default false\n   * @param {boolean} [options.cachedOnly] - Default false\n   * @param {boolean} [options.refreshCache] - Default false\n   * @param {boolean} [options.cancellable] - Default false\n   *\n   * @return {CancellablePromise}\n   */\n  getTopFilters(options) {\n    const self = this;\n    return genericNavOptGet(\n      self,\n      options,\n      'topFiltersPromise',\n      'topFilters',\n      'fetchNavOptTopFilters'\n    );\n  }\n\n  /**\n   * Gets the top joins for the entry. It will fetch it if not cached or if the refresh option is set.\n   *\n   * @param {Object} [options]\n   * @param {boolean} [options.silenceErrors] - Default false\n   * @param {boolean} [options.cachedOnly] - Default false\n   * @param {boolean} [options.refreshCache] - Default false\n   * @param {boolean} [options.cancellable] - Default false\n   *\n   * @return {CancellablePromise}\n   */\n  getTopJoins(options) {\n    const self = this;\n    return genericNavOptGet(self, options, 'topJoinsPromise', 'topJoins', 'fetchNavOptTopJoins');\n  }\n}\n\nexport default MultiTableEntry;\n","// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport $ from 'jquery';\n\nimport CancellablePromise from 'api/cancellablePromise';\nimport dataCatalog from 'catalog/dataCatalog';\n\nconst hiveReservedKeywords = {\n  ALL: true,\n  ALTER: true,\n  AND: true,\n  ARRAY: true,\n  AS: true,\n  AUTHORIZATION: true,\n  BETWEEN: true,\n  BIGINT: true,\n  BINARY: true,\n  BOOLEAN: true,\n  BOTH: true,\n  BY: true,\n  CACHE: true,\n  CASE: true,\n  CAST: true,\n  CHAR: true,\n  COLUMN: true,\n  COMMIT: true,\n  CONF: true,\n  CONSTRAINT: true,\n  CREATE: true,\n  CROSS: true,\n  CUBE: true,\n  CURRENT: true,\n  CURRENT_DATE: true,\n  CURRENT_TIMESTAMP: true,\n  CURSOR: true,\n  DATABASE: true,\n  DATE: true,\n  DAYOFWEEK: true,\n  DECIMAL: true,\n  DELETE: true,\n  DESCRIBE: true,\n  DISTINCT: true,\n  DIV: true,\n  DOUBLE: true,\n  DROP: true,\n  ELSE: true,\n  END: true,\n  EXCHANGE: true,\n  EXISTS: true,\n  EXTENDED: true,\n  EXTERNAL: true,\n  EXTRACT: true,\n  FALSE: true,\n  FETCH: true,\n  FLOAT: true,\n  FLOOR: true,\n  FOLLOWING: true,\n  FOR: true,\n  FOREIGN: true,\n  FROM: true,\n  FULL: true,\n  FUNCTION: true,\n  GRANT: true,\n  GROUP: true,\n  GROUPING: true,\n  HAVING: true,\n  IF: true,\n  IMPORT: true,\n  IN: true,\n  INNER: true,\n  INSERT: true,\n  INT: true,\n  INTEGER: true,\n  INTERSECT: true,\n  INTERVAL: true,\n  INTO: true,\n  IS: true,\n  JOIN: true,\n  LATERAL: true,\n  LEFT: true,\n  LESS: true,\n  LIKE: true,\n  LOCAL: true,\n  MACRO: true,\n  MAP: true,\n  MORE: true,\n  NONE: true,\n  NOT: true,\n  NULL: true,\n  NUMERIC: true,\n  OF: true,\n  ON: true,\n  ONLY: true,\n  OR: true,\n  ORDER: true,\n  OUT: true,\n  OUTER: true,\n  OVER: true,\n  PARTIALSCAN: true,\n  PARTITION: true,\n  PERCENT: true,\n  PRECEDING: true,\n  PRECISION: true,\n  PRESERVE: true,\n  PRIMARY: true,\n  PROCEDURE: true,\n  RANGE: true,\n  READS: true,\n  REDUCE: true,\n  REFERENCES: true,\n  REGEXP: true,\n  REVOKE: true,\n  RIGHT: true,\n  RLIKE: true,\n  ROLLBACK: true,\n  ROLLUP: true,\n  ROW: true,\n  ROWS: true,\n  SELECT: true,\n  SET: true,\n  SMALLINT: true,\n  START: true,\n  SYNC: true,\n  TABLE: true,\n  TABLESAMPLE: true,\n  THEN: true,\n  TIME: true,\n  TIMESTAMP: true,\n  TO: true,\n  TRANSFORM: true,\n  TRIGGER: true,\n  TRUE: true,\n  TRUNCATE: true,\n  UNBOUNDED: true,\n  UNION: true,\n  UNIQUEJOIN: true,\n  UPDATE: true,\n  USER: true,\n  USING: true,\n  UTC_TIMESTAMP: true,\n  VALUES: true,\n  VARCHAR: true,\n  VIEWS: true,\n  WHEN: true,\n  WHERE: true,\n  WINDOW: true,\n  WITH: true\n};\n\nconst extraHiveReservedKeywords = {\n  ASC: true,\n  CLUSTER: true,\n  DESC: true,\n  DISTRIBUTE: true,\n  FORMATTED: true,\n  FUNCTION: true,\n  INDEX: true,\n  INDEXES: true,\n  LIMIT: true,\n  LOCK: true,\n  SCHEMA: true,\n  SORT: true\n};\n\nconst impalaReservedKeywords = {\n  ADD: true,\n  AGGREGATE: true,\n  ALL: true,\n  ALLOCATE: true,\n  ALTER: true,\n  ANALYTIC: true,\n  AND: true,\n  ANTI: true,\n  ANY: true,\n  API_VERSION: true,\n  ARE: true,\n  ARRAY: true,\n  ARRAY_AGG: true,\n  ARRAY_MAX_CARDINALITY: true,\n  AS: true,\n  ASC: true,\n  ASENSITIVE: true,\n  ASYMMETRIC: true,\n  AT: true,\n  ATOMIC: true,\n  AUTHORIZATION: true,\n  AVRO: true,\n  BEGIN_FRAME: true,\n  BEGIN_PARTITION: true,\n  BETWEEN: true,\n  BIGINT: true,\n  BINARY: true,\n  BLOB: true,\n  BLOCK_SIZE: true,\n  BOOLEAN: true,\n  BOTH: true,\n  BY: true,\n  CACHED: true,\n  CALLED: true,\n  CARDINALITY: true,\n  CASCADE: true,\n  CASCADED: true,\n  CASE: true,\n  CAST: true,\n  CHANGE: true,\n  CHAR: true,\n  CHARACTER: true,\n  CLASS: true,\n  CLOB: true,\n  CLOSE_FN: true,\n  COLLATE: true,\n  COLLECT: true,\n  COLUMN: true,\n  COLUMNS: true,\n  COMMENT: true,\n  COMMIT: true,\n  COMPRESSION: true,\n  COMPUTE: true,\n  CONDITION: true,\n  CONNECT: true,\n  CONSTRAINT: true,\n  CONTAINS: true,\n  CONVERT: true,\n  COPY: true,\n  CORR: true,\n  CORRESPONDING: true,\n  COVAR_POP: true,\n  COVAR_SAMP: true,\n  CREATE: true,\n  CROSS: true,\n  CUBE: true,\n  CURRENT: true,\n  CURRENT_DATE: true,\n  CURRENT_DEFAULT_TRANSFORM_GROUP: true,\n  CURRENT_PATH: true,\n  CURRENT_ROLE: true,\n  CURRENT_ROW: true,\n  CURRENT_SCHEMA: true,\n  CURRENT_TIME: true,\n  CURRENT_TRANSFORM_GROUP_FOR_TYPE: true,\n  CURSOR: true,\n  CYCLE: true,\n  DATA: true,\n  DATABASE: true,\n  DATABASES: true,\n  DATE: true,\n  DATETIME: true,\n  DEALLOCATE: true,\n  DEC: true,\n  DECFLOAT: true,\n  DECIMAL: true,\n  DECLARE: true,\n  DEFINE: true,\n  DELETE: true,\n  DELIMITED: true,\n  DEREF: true,\n  DESC: true,\n  DESCRIBE: true,\n  DETERMINISTIC: true,\n  DISCONNECT: true,\n  DISTINCT: true,\n  DIV: true,\n  DOUBLE: true,\n  DROP: true,\n  DYNAMIC: true,\n  EACH: true,\n  ELEMENT: true,\n  ELSE: true,\n  EMPTY: true,\n  ENCODING: true,\n  END: true,\n  END_FRAME: true,\n  END_PARTITION: true,\n  EQUALS: true,\n  ESCAPE: true,\n  ESCAPED: true,\n  EVERY: true,\n  EXCEPT: true,\n  EXEC: true,\n  EXECUTE: true,\n  EXISTS: true,\n  EXPLAIN: true,\n  EXTENDED: true,\n  EXTERNAL: true,\n  FALSE: true,\n  FETCH: true,\n  FIELDS: true,\n  FILEFORMAT: true,\n  FILES: true,\n  FILTER: true,\n  FINALIZE_FN: true,\n  FIRST: true,\n  FLOAT: true,\n  FOLLOWING: true,\n  FOR: true,\n  FOREIGN: true,\n  FORMAT: true,\n  FORMATTED: true,\n  FRAME_ROW: true,\n  FREE: true,\n  FROM: true,\n  FULL: true,\n  FUNCTION: true,\n  FUNCTIONS: true,\n  FUSION: true,\n  GET: true,\n  GLOBAL: true,\n  GRANT: true,\n  GROUP: true,\n  GROUPING: true,\n  GROUPS: true,\n  HASH: true,\n  HAVING: true,\n  HOLD: true,\n  IF: true,\n  IGNORE: true,\n  ILIKE: true,\n  IN: true,\n  INCREMENTAL: true,\n  INDICATOR: true,\n  INIT_FN: true,\n  INITIAL: true,\n  INNER: true,\n  INOUT: true,\n  INPATH: true,\n  INSENSITIVE: true,\n  INSERT: true,\n  INT: true,\n  INTEGER: true,\n  INTERMEDIATE: true,\n  INTERSECT: true,\n  INTERSECTION: true,\n  INTERVAL: true,\n  INTO: true,\n  INVALIDATE: true,\n  IREGEXP: true,\n  IS: true,\n  JOIN: true,\n  JSON_ARRAY: true,\n  JSON_ARRAYAGG: true,\n  JSON_EXISTS: true,\n  JSON_OBJECT: true,\n  JSON_OBJECTAGG: true,\n  JSON_QUERY: true,\n  JSON_TABLE: true,\n  JSON_TABLE_PRIMITIVE: true,\n  JSON_VALUE: true,\n  KEY: true,\n  KUDU: true,\n  LARGE: true,\n  LAST: true,\n  LATERAL: true,\n  LEADING: true,\n  LEFT: true,\n  LIKE: true,\n  LIKE_REGEX: true,\n  LIMIT: true,\n  LINES: true,\n  LISTAGG: true,\n  LOAD: true,\n  LOCAL: true,\n  LOCALTIMESTAMP: true,\n  LOCATION: true,\n  MAP: true,\n  MATCH: true,\n  MATCH_NUMBER: true,\n  MATCH_RECOGNIZE: true,\n  MATCHES: true,\n  MERGE: true,\n  MERGE_FN: true,\n  METADATA: true,\n  METHOD: true,\n  MODIFIES: true,\n  MULTISET: true,\n  NATIONAL: true,\n  NATURAL: true,\n  NCHAR: true,\n  NCLOB: true,\n  NO: true,\n  NONE: true,\n  NORMALIZE: true,\n  NOT: true,\n  NTH_VALUE: true,\n  NULL: true,\n  NULLS: true,\n  NUMERIC: true,\n  OCCURRENCES_REGEX: true,\n  OCTET_LENGTH: true,\n  OF: true,\n  OFFSET: true,\n  OMIT: true,\n  ON: true,\n  ONE: true,\n  ONLY: true,\n  OR: true,\n  ORDER: true,\n  OUT: true,\n  OUTER: true,\n  OVER: true,\n  OVERLAPS: true,\n  OVERLAY: true,\n  OVERWRITE: true,\n  PARQUET: true,\n  PARQUETFILE: true,\n  PARTITION: true,\n  PARTITIONED: true,\n  PARTITIONS: true,\n  PATTERN: true,\n  PER: true,\n  PERCENT: true,\n  PERCENTILE_CONT: true,\n  PERCENTILE_DISC: true,\n  PORTION: true,\n  POSITION: true,\n  POSITION_REGEX: true,\n  PRECEDES: true,\n  PRECEDING: true,\n  PREPARE: true,\n  PREPARE_FN: true,\n  PRIMARY: true,\n  PROCEDURE: true,\n  PRODUCED: true,\n  PTF: true,\n  PURGE: true,\n  RANGE: true,\n  RCFILE: true,\n  READS: true,\n  REAL: true,\n  RECOVER: true,\n  RECURSIVE: true,\n  REF: true,\n  REFERENCES: true,\n  REFERENCING: true,\n  REFRESH: true,\n  REGEXP: true,\n  REGR_AVGX: true,\n  REGR_AVGY: true,\n  REGR_COUNT: true,\n  REGR_INTERCEPT: true,\n  REGR_R2: true,\n  REGR_SLOPE: true,\n  REGR_SXX: true,\n  REGR_SXY: true,\n  REGR_SYY: true,\n  RELEASE: true,\n  RENAME: true,\n  REPEATABLE: true,\n  REPLACE: true,\n  REPLICATION: true,\n  RESTRICT: true,\n  RETURNS: true,\n  REVOKE: true,\n  RIGHT: true,\n  RLIKE: true,\n  ROLE: true,\n  ROLES: true,\n  ROLLBACK: true,\n  ROLLUP: true,\n  ROW: true,\n  ROWS: true,\n  RUNNING: true,\n  SAVEPOINT: true,\n  SCHEMA: true,\n  SCHEMAS: true,\n  SCOPE: true,\n  SCROLL: true,\n  SEARCH: true,\n  SEEK: true,\n  SELECT: true,\n  SEMI: true,\n  SENSITIVE: true,\n  SEQUENCEFILE: true,\n  SERDEPROPERTIES: true,\n  SERIALIZE_FN: true,\n  SET: true,\n  SHOW: true,\n  SIMILAR: true,\n  SKIP: true,\n  SMALLINT: true,\n  SOME: true,\n  SORT: true,\n  SPECIFIC: true,\n  SPECIFICTYPE: true,\n  SQLEXCEPTION: true,\n  SQLSTATE: true,\n  SQLWARNING: true,\n  STATIC: true,\n  STATS: true,\n  STORED: true,\n  STRAIGHT_JOIN: true,\n  STRING: true,\n  STRUCT: true,\n  SUBMULTISET: true,\n  SUBSET: true,\n  SUBSTRING_REGEX: true,\n  SUCCEEDS: true,\n  SYMBOL: true,\n  SYMMETRIC: true,\n  SYSTEM_TIME: true,\n  SYSTEM_USER: true,\n  TABLE: true,\n  TABLES: true,\n  TABLESAMPLE: true,\n  TBLPROPERTIES: true,\n  TERMINATED: true,\n  TEXTFILE: true,\n  THEN: true,\n  TIMESTAMP: true,\n  TIMEZONE_HOUR: true,\n  TIMEZONE_MINUTE: true,\n  TINYINT: true,\n  TO: true,\n  TRAILING: true,\n  TRANSLATE_REGEX: true,\n  TRANSLATION: true,\n  TREAT: true,\n  TRIGGER: true,\n  TRIM_ARRAY: true,\n  TRUE: true,\n  TRUNCATE: true,\n  UESCAPE: true,\n  UNBOUNDED: true,\n  UNCACHED: true,\n  UNION: true,\n  UNIQUE: true,\n  UNKNOWN: true,\n  UNNEST: true,\n  UPDATE: true,\n  UPDATE_FN: true,\n  UPSERT: true,\n  USE: true,\n  USER: true,\n  USING: true,\n  VALUE_OF: true,\n  VALUES: true,\n  VARBINARY: true,\n  VARCHAR: true,\n  VARYING: true,\n  VERSIONING: true,\n  VIEW: true,\n  WHEN: true,\n  WHENEVER: true,\n  WHERE: true,\n  WIDTH_BUCKET: true,\n  WINDOW: true,\n  WITH: true,\n  WITHIN: true,\n  WITHOUT: true\n};\n\nconst identifierEquals = (a, b) =>\n  a &&\n  b &&\n  a\n    .replace(/^\\s*`/, '')\n    .replace(/`\\s*$/, '')\n    .toLowerCase() ===\n    b\n      .replace(/^\\s*`/, '')\n      .replace(/`\\s*$/, '')\n      .toLowerCase();\n\nconst autocompleteFilter = (filter, entries) => {\n  const lowerCaseFilter = filter.toLowerCase();\n  return entries.filter(suggestion => {\n    // TODO: Extend with fuzzy matches\n    let foundIndex = suggestion.value.toLowerCase().indexOf(lowerCaseFilter);\n    if (foundIndex !== -1) {\n      if (\n        foundIndex === 0 ||\n        (suggestion.filterValue &&\n          suggestion.filterValue.toLowerCase().indexOf(lowerCaseFilter) === 0)\n      ) {\n        suggestion.filterWeight = 3;\n      } else {\n        suggestion.filterWeight = 2;\n      }\n    } else if (\n      suggestion.details &&\n      suggestion.details.comment &&\n      lowerCaseFilter.indexOf(' ') === -1\n    ) {\n      foundIndex = suggestion.details.comment.toLowerCase().indexOf(lowerCaseFilter);\n      if (foundIndex !== -1) {\n        suggestion.filterWeight = 1;\n        suggestion.matchComment = true;\n      }\n    }\n    if (foundIndex !== -1) {\n      suggestion.matchIndex = foundIndex;\n      suggestion.matchLength = filter.length;\n      return true;\n    }\n    return false;\n  });\n};\n\nconst sortSuggestions = (suggestions, filter, sortOverride) => {\n  suggestions.sort((a, b) => {\n    if (filter) {\n      if (\n        typeof a.filterWeight !== 'undefined' &&\n        typeof b.filterWeight !== 'undefined' &&\n        b.filterWeight !== a.filterWeight\n      ) {\n        return b.filterWeight - a.filterWeight;\n      }\n      if (typeof a.filterWeight !== 'undefined' && typeof b.filterWeight === 'undefined') {\n        return -1;\n      }\n      if (typeof a.filterWeight === 'undefined' && typeof b.filterWeight !== 'undefined') {\n        return 1;\n      }\n    }\n    if (sortOverride && sortOverride.partitionColumnsFirst) {\n      if (a.partitionKey && !b.partitionKey) {\n        return -1;\n      }\n      if (b.partitionKey && !a.partitionKey) {\n        return 1;\n      }\n    }\n    const aWeight = a.category.weight + (a.weightAdjust || 0);\n    const bWeight = b.category.weight + (b.weightAdjust || 0);\n    if (typeof aWeight !== 'undefined' && typeof bWeight !== 'undefined' && bWeight !== aWeight) {\n      return bWeight - aWeight;\n    }\n    if (typeof aWeight !== 'undefined' && typeof bWeight === 'undefined') {\n      return -1;\n    }\n    if (typeof aWeight === 'undefined' && typeof bWeight !== 'undefined') {\n      return 1;\n    }\n    return a.value.localeCompare(b.value);\n  });\n};\n\nconst identifierChainToPath = identifierChain => identifierChain.map(identifier => identifier.name);\n\n/**\n *\n * @param {Object} options\n * @param {String} options.sourceType\n * @param {ContextNamespace} options.namespace\n * @param {ContextCompute} options.compute\n * @param {boolean} [options.temporaryOnly] - Default: false\n * @param {Object[]} [options.identifierChain]\n * @param {Object[]} [options.tables]\n * @param {Object} [options.cancellable]\n * @param {Object} [options.cachedOnly]\n *\n * @return {CancellablePromise}\n */\nconst resolveCatalogEntry = options => {\n  const cancellablePromises = [];\n  const deferred = $.Deferred();\n  const promise = new CancellablePromise(deferred, undefined, cancellablePromises);\n  dataCatalog.applyCancellable(promise, options);\n\n  if (!options.identifierChain) {\n    deferred.reject();\n    return promise;\n  }\n\n  const findInTree = (currentEntry, fieldsToGo) => {\n    if (fieldsToGo.length === 0) {\n      deferred.reject();\n      return;\n    }\n\n    let nextField;\n    if (currentEntry.getType() === 'map') {\n      nextField = 'value';\n    } else if (currentEntry.getType() === 'array') {\n      nextField = 'item';\n    } else {\n      nextField = fieldsToGo.shift();\n    }\n\n    cancellablePromises.push(\n      currentEntry\n        .getChildren({\n          cancellable: options.cancellable,\n          cachedOnly: options.cachedOnly,\n          silenceErrors: true\n        })\n        .done(childEntries => {\n          let foundEntry = undefined;\n          childEntries.some(childEntry => {\n            if (identifierEquals(childEntry.name, nextField)) {\n              foundEntry = childEntry;\n              return true;\n            }\n          });\n          if (foundEntry && fieldsToGo.length) {\n            findInTree(foundEntry, fieldsToGo);\n          } else if (foundEntry) {\n            deferred.resolve(foundEntry);\n          } else {\n            deferred.reject();\n          }\n        })\n        .fail(deferred.reject)\n    );\n  };\n\n  const findTable = tablesToGo => {\n    if (tablesToGo.length === 0) {\n      deferred.reject();\n      return;\n    }\n\n    const nextTable = tablesToGo.pop();\n    if (typeof nextTable.subQuery !== 'undefined') {\n      findTable(tablesToGo);\n      return;\n    }\n\n    cancellablePromises.push(\n      dataCatalog\n        .getChildren({\n          sourceType: options.sourceType,\n          namespace: options.namespace,\n          compute: options.compute,\n          path: identifierChainToPath(nextTable.identifierChain),\n          cachedOnly: options && options.cachedOnly,\n          cancellable: options && options.cancellable,\n          temporaryOnly: options && options.temporaryOnly,\n          silenceErrors: true\n        })\n        .done(childEntries => {\n          let foundEntry = undefined;\n          childEntries.some(childEntry => {\n            if (identifierEquals(childEntry.name, options.identifierChain[0].name)) {\n              foundEntry = childEntry;\n              return true;\n            }\n          });\n\n          if (foundEntry && options.identifierChain.length > 1) {\n            findInTree(foundEntry, identifierChainToPath(options.identifierChain.slice(1)));\n          } else if (foundEntry) {\n            deferred.resolve(foundEntry);\n          } else {\n            findTable(tablesToGo);\n          }\n        })\n        .fail(deferred.reject)\n    );\n  };\n\n  if (options.tables) {\n    findTable(options.tables.concat());\n  } else {\n    dataCatalog\n      .getEntry({\n        sourceType: options.sourceType,\n        namespace: options.namespace,\n        compute: options.compute,\n        path: [],\n        cachedOnly: options && options.cachedOnly,\n        cancellable: options && options.cancellable,\n        temporaryOnly: options && options.temporaryOnly,\n        silenceErrors: true\n      })\n      .done(entry => {\n        findInTree(entry, identifierChainToPath(options.identifierChain));\n      });\n  }\n\n  return promise;\n};\n\nexport default {\n  autocompleteFilter: autocompleteFilter,\n  backTickIfNeeded: (sourceType, identifier) => {\n    if (identifier.indexOf('`') === 0) {\n      return identifier;\n    }\n    const upperIdentifier = identifier.toUpperCase();\n    if (\n      sourceType === 'hive' &&\n      (hiveReservedKeywords[upperIdentifier] || extraHiveReservedKeywords[upperIdentifier])\n    ) {\n      return '`' + identifier + '`';\n    }\n    if (sourceType === 'impala' && impalaReservedKeywords[upperIdentifier]) {\n      return '`' + identifier + '`';\n    }\n    if (\n      sourceType !== 'impala' &&\n      sourceType !== 'hive' &&\n      (impalaReservedKeywords[upperIdentifier] ||\n        hiveReservedKeywords[upperIdentifier] ||\n        extraHiveReservedKeywords[upperIdentifier])\n    ) {\n      return '`' + identifier + '`';\n    }\n    if (!/^[A-Za-z][A-Za-z0-9_]*$/.test(identifier)) {\n      return '`' + identifier + '`';\n    }\n    return identifier;\n  },\n  locationEquals: (a, b) =>\n    a &&\n    b &&\n    a.first_line === b.first_line &&\n    a.first_column === b.first_column &&\n    a.last_line === b.last_line &&\n    a.last_column === b.last_column,\n  identifierEquals: identifierEquals,\n  sortSuggestions: sortSuggestions,\n  resolveCatalogEntry: resolveCatalogEntry,\n  identifierChainToPath: identifierChainToPath\n};\n","// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport $ from 'jquery';\n\nimport dataCatalog from 'catalog/dataCatalog';\nimport huePubSub from 'utils/huePubSub';\nimport sqlUtils from 'sql/sqlUtils';\n\nconst attachEntryResolver = function(location, sourceType, namespace, compute) {\n  location.resolveCatalogEntry = function(options) {\n    if (!options) {\n      options = {};\n    }\n    if (location.resolvePathPromise && !location.resolvePathPromise.cancelled) {\n      dataCatalog.applyCancellable(location.resolvePathPromise, options);\n      return location.resolvePathPromise;\n    }\n\n    if (!location.identifierChain && !location.colRef && !location.colRef.identifierChain) {\n      if (!location.resolvePathPromise) {\n        location.resolvePathPromise = $.Deferred()\n          .reject()\n          .promise();\n      }\n      return location.resolvePathPromise;\n    }\n\n    const promise = sqlUtils.resolveCatalogEntry({\n      sourceType: sourceType,\n      namespace: namespace,\n      compute: compute,\n      temporaryOnly: options.temporaryOnly,\n      cancellable: options.cancellable,\n      cachedOnly: options.cachedOnly,\n      identifierChain: location.identifierChain || location.colRef.identifierChain,\n      tables: location.tables || (location.colRef && location.colRef.tables)\n    });\n\n    if (!options.cachedOnly) {\n      location.resolvePathPromise = promise;\n    }\n    return promise;\n  };\n};\n\nlet registered = false;\n\nexport default {\n  registerWorkers: function() {\n    if (!window.IS_EMBEDDED && !registered && window.Worker) {\n      // It can take a while before the worker is active\n      const whenWorkerIsReady = function(worker, message) {\n        if (!worker.isReady) {\n          window.clearTimeout(worker.pingTimeout);\n          worker.postMessage({ ping: true });\n          worker.pingTimeout = window.setTimeout(() => {\n            whenWorkerIsReady(worker, message);\n          }, 500);\n        } else {\n          worker.postMessage(message);\n        }\n      };\n\n      // For syntax checking\n      const aceSqlSyntaxWorker = new Worker(\n        window.HUE_BASE_URL + '/desktop/workers/aceSqlSyntaxWorker.js?v=' + window.HUE_VERSION\n      );\n      aceSqlSyntaxWorker.onmessage = function(e) {\n        if (e.data.ping) {\n          aceSqlSyntaxWorker.isReady = true;\n        } else {\n          huePubSub.publish('ace.sql.syntax.worker.message', e);\n        }\n      };\n\n      huePubSub.subscribe('ace.sql.syntax.worker.post', message => {\n        whenWorkerIsReady(aceSqlSyntaxWorker, message);\n      });\n\n      // For location marking\n      const aceSqlLocationWorker = new Worker(\n          window.HUE_BASE_URL + '/desktop/workers/aceSqlLocationWorker.js?v=' + window.HUE_VERSION\n      );\n      aceSqlLocationWorker.onmessage = function(e) {\n        if (e.data.ping) {\n          aceSqlLocationWorker.isReady = true;\n        } else {\n          if (e.data.locations) {\n            e.data.locations.forEach(location => {\n              attachEntryResolver(location, e.data.sourceType, e.data.namespace, e.data.compute);\n            });\n          }\n          huePubSub.publish('ace.sql.location.worker.message', e);\n        }\n      };\n\n      huePubSub.subscribe('ace.sql.location.worker.post', message => {\n        whenWorkerIsReady(aceSqlLocationWorker, message);\n      });\n\n      registered = true;\n    }\n  }\n};\n","// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport localforage from 'localforage';\n\nconst hueDebug = {\n  clearCaches: function() {\n    const promises = [];\n    const clearInstance = function(prefix) {\n      promises.push(localforage.createInstance({ name: prefix + window.LOGGED_USERNAME }).clear());\n    };\n    clearInstance('HueContextCatalog_');\n    clearInstance('HueDataCatalog_');\n    clearInstance('HueDataCatalog_hive_');\n    clearInstance('HueDataCatalog_hive_multiTable_');\n    clearInstance('HueDataCatalog_impala_');\n    clearInstance('HueDataCatalog_impala_multiTable_');\n    Promise.all(promises).then(() => {\n      console.log('Done! Refresh the browser.');\n    });\n  }\n};\n\nexport default hueDebug;\n","// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Based on original pub/sub implementation from http://davidwalsh.name/pubsub-javascript\n\nconst topics = {};\nconst hOP = topics.hasOwnProperty;\n\nconst huePubSub = {\n  subscribe: function(topic, listener, app) {\n    if (!hOP.call(topics, topic)) {\n      topics[topic] = [];\n    }\n\n    const index =\n      topics[topic].push({\n        listener: listener,\n        app: app,\n        status: 'running'\n      }) - 1;\n\n    return {\n      remove: function() {\n        delete topics[topic][index];\n      }\n    };\n  },\n  removeAll: function(topic) {\n    topics[topic] = [];\n  },\n  subscribeOnce: function(topic, listener, app) {\n    const ephemeral = this.subscribe(\n      topic,\n      function() {\n        listener.apply(listener, arguments);\n        ephemeral.remove();\n      },\n      app\n    );\n  },\n  publish: function(topic, info) {\n    if (!hOP.call(topics, topic)) {\n      return;\n    }\n\n    topics[topic].forEach(item => {\n      if (item.status === 'running') {\n        item.listener(info);\n      }\n    });\n  },\n  getTopics: function() {\n    return topics;\n  },\n  pauseAppSubscribers: function(app) {\n    if (app) {\n      Object.keys(topics).forEach(topicName => {\n        topics[topicName].forEach(topic => {\n          if (\n            typeof topic.app !== 'undefined' &&\n            topic.app !== null &&\n            (topic.app === app || topic.app.split('-')[0] === app)\n          ) {\n            topic.status = 'paused';\n          }\n        });\n      });\n    }\n  },\n  resumeAppSubscribers: function(app) {\n    if (app) {\n      Object.keys(topics).forEach(topicName => {\n        topics[topicName].forEach(topic => {\n          if (\n            typeof topic.app !== 'undefined' &&\n            topic.app !== null &&\n            (topic.app === app || topic.app.split('-')[0] === app)\n          ) {\n            topic.status = 'running';\n          }\n        });\n      });\n    }\n  },\n  clearAppSubscribers: function(app) {\n    if (app) {\n      Object.keys(topics).forEach(topicName => {\n        topics[topicName] = topics[topicName].filter(obj => {\n          return obj.app !== app;\n        });\n      });\n    }\n  }\n};\n\nexport default huePubSub;\n","// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport $ from 'jquery';\n\nconst bootstrapRatios = {\n  span3() {\n    const windowWidth = $(window).width();\n    if (windowWidth >= 1200) {\n      return 23.07692308;\n    } else if (windowWidth >= 768 && windowWidth <= 979) {\n      return 22.9281768;\n    } else {\n      return 23.17073171;\n    }\n  },\n  span9() {\n    const windowWidth = $(window).width();\n    if (windowWidth >= 1200) {\n      return 74.35897436;\n    } else if (windowWidth >= 768 && windowWidth <= 979) {\n      return 74.30939227;\n    } else {\n      return 74.3902439;\n    }\n  },\n  margin() {\n    return 2.56410256;\n  }\n};\n\n/**\n * Convert text to URLs\n * Selector arg can be jQuery or document.querySelectorAll()\n *\n * @param selectors\n * @return {default}\n */\nconst text2Url = selectors => {\n  let i = 0;\n  const len = selectors.length;\n\n  for (i; i < len; i++) {\n    const arr = [],\n      selector = selectors[i],\n      val = selector.innerHTML.replace(/&nbsp;/g, ' ').split(' ');\n\n    val.forEach(word => {\n      let matched = null;\n      const re = /(https?:\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?/gi;\n\n      if (re.test(word)) {\n        matched = word.match(re);\n        word = word.replace(matched, '<a href=\"' + matched + '\">' + matched + '</a>');\n        arr.push(word);\n      } else {\n        arr.push(word);\n      }\n    });\n\n    selector.innerHTML = arr.join(' ');\n  }\n  return this;\n};\n\n/**\n * Create a in-memory div, set it's inner text(which jQuery automatically encodes)\n * then grab the encoded contents back out.\n *\n * @param value\n * @return {*|jQuery}\n */\nconst htmlEncode = value => {\n  return $('<div/>')\n    .text(value)\n    .html();\n};\n\nconst html2text = value => {\n  return $('<div/>')\n    .html(value)\n    .text()\n    .replace(/\\u00A0/g, ' ');\n};\n\nconst goFullScreen = () => {\n  if (\n    !document.fullscreenElement &&\n    !document.mozFullScreenElement &&\n    !document.webkitFullscreenElement &&\n    !document.msFullscreenElement\n  ) {\n    if (document.documentElement.requestFullscreen) {\n      document.documentElement.requestFullscreen();\n    } else if (document.documentElement.msRequestFullscreen) {\n      document.documentElement.msRequestFullscreen();\n    } else if (document.documentElement.mozRequestFullScreen) {\n      document.documentElement.mozRequestFullScreen();\n    } else if (document.documentElement.webkitRequestFullscreen) {\n      document.documentElement.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);\n    }\n  }\n};\n\nconst exitFullScreen = () => {\n  if (\n    document.fullscreenElement ||\n    document.mozFullScreenElement ||\n    document.webkitFullscreenElement ||\n    document.msFullscreenElement\n  ) {\n    if (document.exitFullscreen) {\n      document.exitFullscreen();\n    } else if (document.msExitFullscreen) {\n      document.msExitFullscreen();\n    } else if (document.mozCancelFullScreen) {\n      document.mozCancelFullScreen();\n    } else if (document.webkitExitFullscreen) {\n      document.webkitExitFullscreen();\n    }\n  }\n};\n\nconst changeURL = (newURL, params) => {\n  let extraSearch = '';\n  if (params) {\n    const newSearchKeys = Object.keys(params);\n    if (newSearchKeys.length) {\n      while (newSearchKeys.length) {\n        const newKey = newSearchKeys.pop();\n        extraSearch += newKey + '=' + params[newKey];\n        if (newSearchKeys.length) {\n          extraSearch += '&';\n        }\n      }\n    }\n  }\n\n  if (typeof IS_EMBEDDED !== 'undefined' && IS_EMBEDDED) {\n    let search = window.location.search;\n    if (extraSearch) {\n      search += (search ? '&' : '?') + extraSearch;\n    }\n    newURL = window.location.pathname + search + '#!' + newURL.replace('/hue', '');\n    window.history.pushState(null, null, newURL);\n    return;\n  }\n\n  const hashSplit = newURL.split('#');\n  var base = hashSplit[0].length && hashSplit[0].indexOf(window.HUE_BASE_URL) !== 0 ? window.HUE_BASE_URL : '';\n  let url = base + hashSplit[0];\n  if (extraSearch) {\n    url += (url.indexOf('?') === -1 ? '?' : '&') + extraSearch;\n  }\n  if (hashSplit.length > 1) {\n    url += '#' + hashSplit[1];\n  } else if (window.location.hash) {\n    url += window.location.hash;\n  }\n  window.history.pushState(null, null, url);\n};\n\nconst replaceURL = newURL => {\n  window.history.replaceState(null, null, newURL);\n};\n\nconst changeURLParameter = (param, value) => {\n  if (typeof IS_EMBEDDED !== 'undefined' && IS_EMBEDDED) {\n    const currentUrl = window.location.hash.replace('#!', '');\n    const parts = currentUrl.split('?');\n    const path = parts[0];\n    let search = parts.length > 1 ? parts[1] : '';\n    if (~search.indexOf(param + '=' + value)) {\n      return;\n    }\n    if (~search.indexOf(param + '=')) {\n      if (!value) {\n        search = search.replace(new RegExp(param + '=[^&]*&?'), '');\n      } else {\n        search = search.replace(new RegExp(param + '=[^&]*'), param + '=' + value);\n      }\n    } else if (value) {\n      if (search) {\n        search += '&';\n      }\n      search += param + '=' + value;\n    } else {\n      return;\n    }\n\n    changeURL(search ? path + '?' + search : path);\n  } else {\n    let newSearch = '';\n    if (window.location.getParameter(param, true) !== null) {\n      newSearch += '?';\n      window.location.search\n        .replace(/\\?/gi, '')\n        .split('&')\n        .forEach(p => {\n          if (p.split('=')[0] !== param) {\n            newSearch += p;\n          }\n        });\n      if (value) {\n        newSearch += (newSearch !== '?' ? '&' : '') + param + '=' + value;\n      }\n    } else {\n      newSearch =\n        window.location.search +\n        (value ? (window.location.search.indexOf('?') > -1 ? '&' : '?') + param + '=' + value : '');\n    }\n\n    if (newSearch === '?') {\n      newSearch = '';\n    }\n\n    changeURL(window.location.pathname + newSearch);\n  }\n};\n\nconst removeURLParameter = param => {\n  changeURLParameter(param, null);\n};\n\nconst parseHivePseudoJson = pseudoJson => {\n  // Hive returns a pseudo-json with parameters, like\n  // \"{Lead Developer=John Foo, Lead Developer Email=jfoo@somewhere.com, date=2013-07-11 }\"\n  const parsedParams = {};\n  if (pseudoJson && pseudoJson.length > 2) {\n    const splits = pseudoJson.substring(1, pseudoJson.length - 1).split(', ');\n    splits.forEach(part => {\n      if (part.indexOf('=') > -1) {\n        parsedParams[part.split('=')[0]] = part.split('=')[1];\n      }\n    });\n  }\n  return parsedParams;\n};\n\nconst isOverflowing = element => {\n  if (element instanceof $) {\n    element = element[0];\n  }\n  return element.scrollHeight > element.clientHeight || element.scrollWidth > element.clientWidth;\n};\n\nconst waitForRendered = (selector, condition, callback, timeout) => {\n  const $el = selector instanceof $ ? selector : $(selector);\n  if (condition($el)) {\n    callback($el);\n  } else {\n    window.clearTimeout($el.data('waitForRenderTimeout'));\n    const waitForRenderTimeout = window.setTimeout(() => {\n      waitForRendered(selector, condition, callback);\n    }, timeout || 100);\n    $el.data('waitForRenderTimeout', waitForRenderTimeout);\n  }\n};\n\nconst waitForObservable = (observable, callback) => {\n  if (observable()) {\n    callback(observable);\n  } else {\n    const subscription = observable.subscribe(newValue => {\n      if (newValue) {\n        subscription.dispose();\n        callback(observable);\n      }\n    });\n  }\n};\n\nconst waitForVariable = (variable, callback, timeout) => {\n  if (variable) {\n    callback(variable);\n  } else {\n    window.setTimeout(() => {\n      waitForVariable(variable, callback);\n    }, timeout || 100);\n  }\n};\n\nconst scrollbarWidth = () => {\n  const $parent = $('<div style=\"width:50px;height:50px;overflow:auto\"><div/></div>').appendTo(\n    HUE_CONTAINER\n  );\n  const $children = $parent.children();\n  const width = $children.innerWidth() - $children.height(99).innerWidth();\n  $parent.remove();\n  return width;\n};\n\nconst getSearchParameter = (search, name, returnNull) => {\n  name = name.replace(/[\\[]/, '\\\\[').replace(/[\\]]/, '\\\\]');\n  const regex = new RegExp('[\\\\?&]' + name + '=([^&#]*)'),\n    results = regex.exec(search);\n  if (returnNull && results === null) {\n    return null;\n  }\n  return results === null ? '' : decodeURIComponent(results[1].replace(/\\+/g, ' '));\n};\n\nif (!window.location.getParameter) {\n  window.location.getParameter = function(name, returnNull) {\n    return getSearchParameter(window.location.search, name, returnNull);\n  };\n}\n\nconst logError = error => {\n  if (typeof window.console !== 'undefined' && typeof window.console.error !== 'undefined') {\n    if (typeof error !== 'undefined') {\n      console.error(error);\n    }\n    console.error(new Error().stack);\n  }\n};\n\nconst equalIgnoreCase = (a, b) => a && b && a.toLowerCase() === b.toLowerCase();\n\nconst deXSS = str => {\n  if (typeof str !== 'undefined' && str !== null && typeof str === 'string') {\n    return str.replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '');\n  }\n  return str;\n};\n\nconst getStyleFromCSSClass = cssClass => {\n  for (let i = 0; i < document.styleSheets.length; i++) {\n    const cssClasses = document.styleSheets[i].rules || document.styleSheets[i].cssRules;\n    for (let x = 0; x < cssClasses.length; x++) {\n      if (cssClasses[x].selectorText === cssClass) {\n        return cssClasses[x].style ? cssClasses[x].style : cssClasses[x];\n      }\n    }\n  }\n};\n\nconst highlight = (text, searchTerm) => {\n  if (searchTerm === '' || text === '') {\n    return text;\n  }\n\n  let remText = text;\n  let highLightedText = '';\n  searchTerm = searchTerm.toLowerCase();\n\n  let startIndex;\n  do {\n    const remLowerText = remText.toLowerCase();\n    startIndex = remLowerText.indexOf(searchTerm);\n    if (startIndex >= 0) {\n      highLightedText +=\n        remText.substring(0, startIndex) +\n        '<strong>' +\n        remText.substring(startIndex, startIndex + searchTerm.length) +\n        '</strong>';\n      remText = remText.substring(startIndex + searchTerm.length);\n    } else {\n      highLightedText += remText;\n    }\n  } while (startIndex >= 0);\n\n  return highLightedText;\n};\n\nconst dfs = (node, callback) => {\n  if (!node || typeof node !== 'object') {\n    return;\n  }\n  Object.keys(node).forEach(key => {\n    callback(node, key);\n    dfs(node[key], callback);\n  });\n};\n\nconst deleteAllEmptyStringKey = node => {\n  const fDeleteEmptyStringKey = function(node, key) {\n    if (node[key] || typeof node[key] !== 'string') {\n      return;\n    }\n    delete node[key];\n  };\n  dfs(node, fDeleteEmptyStringKey);\n};\n\nconst s4 = () =>\n  Math.floor((1 + Math.random()) * 0x10000)\n    .toString(16)\n    .substring(1);\n\nconst UUID = () => s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n\nconst escapeOutput = str =>\n  $('<span>')\n    .text(str)\n    .html()\n    .trim();\n\nconst getFileBrowseButton = (\n  inputElement,\n  selectFolder,\n  valueAccessor,\n  stripHdfsPrefix,\n  allBindingsAccessor,\n  isAddon,\n  isNestedModal,\n  linkMarkup\n) => {\n  let _btn;\n  if (isAddon) {\n    _btn = $('<span>')\n      .addClass('add-on muted pointer filechooser-clickable')\n      .text('..');\n  } else if (linkMarkup) {\n    _btn = $('<a>')\n      .addClass('btn')\n      .addClass('fileChooserBtn filechooser-clickable')\n      .text('..');\n  } else {\n    _btn = $('<button>')\n      .addClass('btn')\n      .addClass('fileChooserBtn filechooser-clickable')\n      .text('..');\n  }\n  _btn.click(e => {\n    e.preventDefault();\n    if (!isNestedModal) {\n      $(window.HUE_CONTAINER).addClass('modal-open');\n    }\n\n    function callFileChooser() {\n      let _initialPath = $.trim(inputElement.val()) !== '' ? inputElement.val() : '/';\n      if (\n        (allBindingsAccessor &&\n          allBindingsAccessor().filechooserOptions &&\n          allBindingsAccessor().filechooserOptions.skipInitialPathIfEmpty &&\n          inputElement.val() === '') ||\n        (allBindingsAccessor && allBindingsAccessor().filechooserPrefixSeparator)\n      ) {\n        _initialPath = '';\n      }\n      if (inputElement.data('fullPath')) {\n        _initialPath = inputElement.data('fullPath');\n      }\n      if (_initialPath.indexOf('hdfs://') > -1) {\n        _initialPath = _initialPath.substring(7);\n      }\n\n      let supportSelectFolder = !!selectFolder;\n      if (\n        allBindingsAccessor &&\n        typeof allBindingsAccessor().filechooserOptions !== 'undefined' &&\n        typeof allBindingsAccessor().filechooserOptions.selectFolder !== 'undefined'\n      ) {\n        supportSelectFolder = allBindingsAccessor().filechooserOptions.selectFolder;\n      }\n\n      $('#filechooser').jHueFileChooser({\n        suppressErrors: true,\n        selectFolder: supportSelectFolder,\n        onFolderChoose: function(filePath) {\n          handleChoice(filePath, stripHdfsPrefix);\n          if (selectFolder) {\n            $('#chooseFile').modal('hide');\n            if (!isNestedModal) {\n              $('.modal-backdrop').remove();\n            }\n          }\n        },\n        onFileChoose: function(filePath) {\n          handleChoice(filePath, stripHdfsPrefix);\n          $('#chooseFile').modal('hide');\n          if (!isNestedModal) {\n            $('.modal-backdrop').remove();\n          }\n        },\n        createFolder:\n          allBindingsAccessor &&\n          allBindingsAccessor().filechooserOptions &&\n          allBindingsAccessor().filechooserOptions.createFolder,\n        uploadFile:\n          allBindingsAccessor &&\n          allBindingsAccessor().filechooserOptions &&\n          allBindingsAccessor().filechooserOptions.uploadFile,\n        initialPath: _initialPath,\n        errorRedirectPath: '',\n        forceRefresh: true,\n        showExtraHome:\n          allBindingsAccessor &&\n          allBindingsAccessor().filechooserOptions &&\n          allBindingsAccessor().filechooserOptions.showExtraHome,\n        extraHomeProperties:\n          allBindingsAccessor &&\n          allBindingsAccessor().filechooserOptions &&\n          allBindingsAccessor().filechooserOptions.extraHomeProperties\n            ? allBindingsAccessor().filechooserOptions.extraHomeProperties\n            : {},\n        filterExtensions:\n          allBindingsAccessor && allBindingsAccessor().filechooserFilter\n            ? allBindingsAccessor().filechooserFilter\n            : '',\n        displayOnlyFolders:\n          allBindingsAccessor &&\n          allBindingsAccessor().filechooserOptions &&\n          allBindingsAccessor().filechooserOptions.displayOnlyFolders\n      });\n      if (window.isIE11) {\n        const oldFocus = $().modal.Constructor.prototype.enforceFocus;\n        $().modal.Constructor.prototype.enforceFocus = function() {};\n        $('#chooseFile').modal('show');\n        window.setTimeout(() => {\n          $().modal.Constructor.prototype.enforceFocus = oldFocus;\n        }, 5000);\n      } else {\n        $('#chooseFile').modal('show');\n      }\n      if (!isNestedModal) {\n        $('#chooseFile').on('hidden', () => {\n          $(window.HUE_CONTAINER).removeClass('modal-open');\n          $('.modal-backdrop').remove();\n        });\n      }\n    }\n\n    // check if it's a relative path\n    callFileChooser();\n\n    function handleChoice(filePath, stripHdfsPrefix) {\n      if (allBindingsAccessor && allBindingsAccessor().filechooserPrefixSeparator) {\n        filePath =\n          inputElement.val().split(allBindingsAccessor().filechooserPrefixSeparator)[0] +\n          '=' +\n          filePath;\n      }\n      if (\n        allBindingsAccessor &&\n        allBindingsAccessor().filechooserOptions &&\n        allBindingsAccessor().filechooserOptions.deploymentDir\n      ) {\n        inputElement.data('fullPath', filePath);\n        inputElement.attr('data-original-title', filePath);\n        if (filePath.indexOf(allBindingsAccessor().filechooserOptions.deploymentDir) === 0) {\n          filePath = filePath.substr(\n            allBindingsAccessor().filechooserOptions.deploymentDir.length + 1\n          );\n        }\n      }\n      if (stripHdfsPrefix) {\n        inputElement.val(filePath);\n      } else {\n        inputElement.val('hdfs://' + filePath);\n      }\n      inputElement.change();\n      if (valueAccessor) {\n        if (typeof valueAccessor() == 'function' || typeof valueAccessor().value == 'function') {\n          if (valueAccessor().value) {\n            valueAccessor().value(inputElement.val());\n            if (valueAccessor().displayJustLastBit) {\n              inputElement.data('fullPath', inputElement.val());\n              inputElement.attr('data-original-title', inputElement.val());\n              const _val = inputElement.val();\n              inputElement.val(_val.split('/')[_val.split('/').length - 1]);\n            }\n          } else {\n            valueAccessor()(inputElement.val());\n          }\n        } else {\n          valueAccessor(inputElement.val());\n        }\n      }\n    }\n  });\n  if (allBindingsAccessor && allBindingsAccessor().filechooserDisabled) {\n    _btn.addClass('disabled').attr('disabled', 'disabled');\n  }\n  return _btn;\n};\n\nconst stripHtml = html => {\n  const tmp = document.createElement('DIV');\n  tmp.innerHTML = html;\n  return tmp.textContent || tmp.innerText;\n};\n\nconst stripHtmlFromFunctions = template => {\n  // strips HTML from inside the functions\n  let _tmpl = template;\n  const _mustacheFunctions = _tmpl.match(/{{#(.[\\s\\S]*?){{\\//g);\n  if (_mustacheFunctions) {\n    $.each(_mustacheFunctions, (cnt, fn) => {\n      _tmpl = _tmpl.replace(\n        fn,\n        fn.substr(0, fn.indexOf('}}') + 2) +\n          $.trim(stripHtml(fn.substr(fn.indexOf('}}') + 2).slice(0, -3))) +\n          '{{/'\n      );\n    });\n  }\n  return _tmpl;\n};\n\nexport default {\n  bootstrapRatios: bootstrapRatios,\n  getFileBrowseButton: getFileBrowseButton,\n  text2Url: text2Url,\n  htmlEncode: htmlEncode,\n  html2text: html2text,\n  goFullScreen: goFullScreen,\n  exitFullScreen: exitFullScreen,\n  changeURL: changeURL,\n  replaceURL: replaceURL,\n  changeURLParameter: changeURLParameter,\n  removeURLParameter: removeURLParameter,\n  parseHivePseudoJson: parseHivePseudoJson,\n  isOverflowing: isOverflowing,\n  waitForRendered: waitForRendered,\n  waitForObservable: waitForObservable,\n  waitForVariable: waitForVariable,\n  scrollbarWidth: scrollbarWidth,\n  getSearchParameter: getSearchParameter,\n  logError: logError,\n  equalIgnoreCase: equalIgnoreCase,\n  deXSS: deXSS,\n  getStyleFromCSSClass: getStyleFromCSSClass,\n  highlight: highlight,\n  dfs: dfs,\n  deleteAllEmptyStringKey: deleteAllEmptyStringKey,\n  UUID: UUID,\n  escapeOutput: escapeOutput,\n  stripHtmlFromFunctions: stripHtmlFromFunctions\n};\n","// Licensed to Cloudera, Inc. under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  Cloudera, Inc. licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nconst I18n = identifier => HUE_I18n[identifier] || identifier;\n\nexport default I18n;\n"],"sourceRoot":""}